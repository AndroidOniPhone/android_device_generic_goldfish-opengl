// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_transform
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_transform.h"


#include "goldfish_vk_extension_structs_guest.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void transform_extension_struct(
    ResourceTracker* resourceTracker,
    void* structExtension_out);

#ifdef VK_VERSION_1_0
void transform_VkApplicationInfo(
    ResourceTracker* resourceTracker,
    VkApplicationInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkInstanceCreateInfo(
    ResourceTracker* resourceTracker,
    VkInstanceCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pApplicationInfo)
    {
        transform_VkApplicationInfo(resourceTracker, (VkApplicationInfo*)(toTransform->pApplicationInfo));
    }
}

void transform_VkAllocationCallbacks(
    ResourceTracker* resourceTracker,
    VkAllocationCallbacks* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPhysicalDeviceFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkFormatProperties(
    ResourceTracker* resourceTracker,
    VkFormatProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkExtent3D(
    ResourceTracker* resourceTracker,
    VkExtent3D* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkImageFormatProperties(
    ResourceTracker* resourceTracker,
    VkImageFormatProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->maxExtent));
}

void transform_VkPhysicalDeviceLimits(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceLimits* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPhysicalDeviceSparseProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSparseProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPhysicalDeviceProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkPhysicalDeviceLimits(resourceTracker, (VkPhysicalDeviceLimits*)(&toTransform->limits));
    transform_VkPhysicalDeviceSparseProperties(resourceTracker, (VkPhysicalDeviceSparseProperties*)(&toTransform->sparseProperties));
}

void transform_VkQueueFamilyProperties(
    ResourceTracker* resourceTracker,
    VkQueueFamilyProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->minImageTransferGranularity));
}

void transform_VkMemoryType(
    ResourceTracker* resourceTracker,
    VkMemoryType* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkMemoryHeap(
    ResourceTracker* resourceTracker,
    VkMemoryHeap* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPhysicalDeviceMemoryProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceMemoryProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        transform_VkMemoryType(resourceTracker, (VkMemoryType*)(toTransform->memoryTypes + i));
    }
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        transform_VkMemoryHeap(resourceTracker, (VkMemoryHeap*)(toTransform->memoryHeaps + i));
    }
}

void transform_VkDeviceQueueCreateInfo(
    ResourceTracker* resourceTracker,
    VkDeviceQueueCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceCreateInfo(
    ResourceTracker* resourceTracker,
    VkDeviceCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pQueueCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->queueCreateInfoCount; ++i)
        {
            transform_VkDeviceQueueCreateInfo(resourceTracker, (VkDeviceQueueCreateInfo*)(toTransform->pQueueCreateInfos + i));
        }
    }
    if (toTransform->pEnabledFeatures)
    {
        transform_VkPhysicalDeviceFeatures(resourceTracker, (VkPhysicalDeviceFeatures*)(toTransform->pEnabledFeatures));
    }
}

void transform_VkExtensionProperties(
    ResourceTracker* resourceTracker,
    VkExtensionProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkLayerProperties(
    ResourceTracker* resourceTracker,
    VkLayerProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkSubmitInfo(
    ResourceTracker* resourceTracker,
    VkSubmitInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryAllocateInfo(
    ResourceTracker* resourceTracker,
    VkMemoryAllocateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(nullptr, 1, nullptr, 1, nullptr, 1, &toTransform->memoryTypeIndex, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMappedMemoryRange(
    ResourceTracker* resourceTracker,
    VkMappedMemoryRange* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, &toTransform->offset, 1, &toTransform->size, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryRequirements(
    ResourceTracker* resourceTracker,
    VkMemoryRequirements* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1, &toTransform->memoryTypeBits, 1);
}

void transform_VkSparseImageFormatProperties(
    ResourceTracker* resourceTracker,
    VkSparseImageFormatProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->imageGranularity));
}

void transform_VkSparseImageMemoryRequirements(
    ResourceTracker* resourceTracker,
    VkSparseImageMemoryRequirements* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkSparseImageFormatProperties(resourceTracker, (VkSparseImageFormatProperties*)(&toTransform->formatProperties));
}

void transform_VkSparseMemoryBind(
    ResourceTracker* resourceTracker,
    VkSparseMemoryBind* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, &toTransform->memoryOffset, 1, nullptr, 1, nullptr, 1, nullptr, 1);
}

void transform_VkSparseBufferMemoryBindInfo(
    ResourceTracker* resourceTracker,
    VkSparseBufferMemoryBindInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pBinds)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->bindCount; ++i)
        {
            transform_VkSparseMemoryBind(resourceTracker, (VkSparseMemoryBind*)(toTransform->pBinds + i));
        }
    }
}

void transform_VkSparseImageOpaqueMemoryBindInfo(
    ResourceTracker* resourceTracker,
    VkSparseImageOpaqueMemoryBindInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pBinds)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->bindCount; ++i)
        {
            transform_VkSparseMemoryBind(resourceTracker, (VkSparseMemoryBind*)(toTransform->pBinds + i));
        }
    }
}

void transform_VkImageSubresource(
    ResourceTracker* resourceTracker,
    VkImageSubresource* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkOffset3D(
    ResourceTracker* resourceTracker,
    VkOffset3D* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkSparseImageMemoryBind(
    ResourceTracker* resourceTracker,
    VkSparseImageMemoryBind* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, &toTransform->memoryOffset, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    transform_VkImageSubresource(resourceTracker, (VkImageSubresource*)(&toTransform->subresource));
    transform_VkOffset3D(resourceTracker, (VkOffset3D*)(&toTransform->offset));
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->extent));
}

void transform_VkSparseImageMemoryBindInfo(
    ResourceTracker* resourceTracker,
    VkSparseImageMemoryBindInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pBinds)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->bindCount; ++i)
        {
            transform_VkSparseImageMemoryBind(resourceTracker, (VkSparseImageMemoryBind*)(toTransform->pBinds + i));
        }
    }
}

void transform_VkBindSparseInfo(
    ResourceTracker* resourceTracker,
    VkBindSparseInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pBufferBinds)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->bufferBindCount; ++i)
        {
            transform_VkSparseBufferMemoryBindInfo(resourceTracker, (VkSparseBufferMemoryBindInfo*)(toTransform->pBufferBinds + i));
        }
    }
    if (toTransform->pImageOpaqueBinds)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->imageOpaqueBindCount; ++i)
        {
            transform_VkSparseImageOpaqueMemoryBindInfo(resourceTracker, (VkSparseImageOpaqueMemoryBindInfo*)(toTransform->pImageOpaqueBinds + i));
        }
    }
    if (toTransform->pImageBinds)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->imageBindCount; ++i)
        {
            transform_VkSparseImageMemoryBindInfo(resourceTracker, (VkSparseImageMemoryBindInfo*)(toTransform->pImageBinds + i));
        }
    }
}

void transform_VkFenceCreateInfo(
    ResourceTracker* resourceTracker,
    VkFenceCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSemaphoreCreateInfo(
    ResourceTracker* resourceTracker,
    VkSemaphoreCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkEventCreateInfo(
    ResourceTracker* resourceTracker,
    VkEventCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkQueryPoolCreateInfo(
    ResourceTracker* resourceTracker,
    VkQueryPoolCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBufferCreateInfo(
    ResourceTracker* resourceTracker,
    VkBufferCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBufferViewCreateInfo(
    ResourceTracker* resourceTracker,
    VkBufferViewCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkImageCreateInfo(
    ResourceTracker* resourceTracker,
    VkImageCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->extent));
}

void transform_VkSubresourceLayout(
    ResourceTracker* resourceTracker,
    VkSubresourceLayout* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkComponentMapping(
    ResourceTracker* resourceTracker,
    VkComponentMapping* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkImageSubresourceRange(
    ResourceTracker* resourceTracker,
    VkImageSubresourceRange* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkImageViewCreateInfo(
    ResourceTracker* resourceTracker,
    VkImageViewCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkComponentMapping(resourceTracker, (VkComponentMapping*)(&toTransform->components));
    transform_VkImageSubresourceRange(resourceTracker, (VkImageSubresourceRange*)(&toTransform->subresourceRange));
}

void transform_VkShaderModuleCreateInfo(
    ResourceTracker* resourceTracker,
    VkShaderModuleCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineCacheCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineCacheCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSpecializationMapEntry(
    ResourceTracker* resourceTracker,
    VkSpecializationMapEntry* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkSpecializationInfo(
    ResourceTracker* resourceTracker,
    VkSpecializationInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pMapEntries)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->mapEntryCount; ++i)
        {
            transform_VkSpecializationMapEntry(resourceTracker, (VkSpecializationMapEntry*)(toTransform->pMapEntries + i));
        }
    }
}

void transform_VkPipelineShaderStageCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineShaderStageCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pSpecializationInfo)
    {
        transform_VkSpecializationInfo(resourceTracker, (VkSpecializationInfo*)(toTransform->pSpecializationInfo));
    }
}

void transform_VkVertexInputBindingDescription(
    ResourceTracker* resourceTracker,
    VkVertexInputBindingDescription* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkVertexInputAttributeDescription(
    ResourceTracker* resourceTracker,
    VkVertexInputAttributeDescription* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineVertexInputStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineVertexInputStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pVertexBindingDescriptions)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->vertexBindingDescriptionCount; ++i)
        {
            transform_VkVertexInputBindingDescription(resourceTracker, (VkVertexInputBindingDescription*)(toTransform->pVertexBindingDescriptions + i));
        }
    }
    if (toTransform->pVertexAttributeDescriptions)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->vertexAttributeDescriptionCount; ++i)
        {
            transform_VkVertexInputAttributeDescription(resourceTracker, (VkVertexInputAttributeDescription*)(toTransform->pVertexAttributeDescriptions + i));
        }
    }
}

void transform_VkPipelineInputAssemblyStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineInputAssemblyStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineTessellationStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineTessellationStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkViewport(
    ResourceTracker* resourceTracker,
    VkViewport* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkOffset2D(
    ResourceTracker* resourceTracker,
    VkOffset2D* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkExtent2D(
    ResourceTracker* resourceTracker,
    VkExtent2D* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkRect2D(
    ResourceTracker* resourceTracker,
    VkRect2D* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkOffset2D(resourceTracker, (VkOffset2D*)(&toTransform->offset));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->extent));
}

void transform_VkPipelineViewportStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineViewportStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->viewportCount; ++i)
        {
            transform_VkViewport(resourceTracker, (VkViewport*)(toTransform->pViewports + i));
        }
    }
    if (toTransform->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->scissorCount; ++i)
        {
            transform_VkRect2D(resourceTracker, (VkRect2D*)(toTransform->pScissors + i));
        }
    }
}

void transform_VkPipelineRasterizationStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineRasterizationStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineMultisampleStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineMultisampleStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkStencilOpState(
    ResourceTracker* resourceTracker,
    VkStencilOpState* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineDepthStencilStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineDepthStencilStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkStencilOpState(resourceTracker, (VkStencilOpState*)(&toTransform->front));
    transform_VkStencilOpState(resourceTracker, (VkStencilOpState*)(&toTransform->back));
}

void transform_VkPipelineColorBlendAttachmentState(
    ResourceTracker* resourceTracker,
    VkPipelineColorBlendAttachmentState* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineColorBlendStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineColorBlendStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->attachmentCount; ++i)
        {
            transform_VkPipelineColorBlendAttachmentState(resourceTracker, (VkPipelineColorBlendAttachmentState*)(toTransform->pAttachments + i));
        }
    }
}

void transform_VkPipelineDynamicStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineDynamicStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkGraphicsPipelineCreateInfo(
    ResourceTracker* resourceTracker,
    VkGraphicsPipelineCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pStages)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->stageCount; ++i)
        {
            transform_VkPipelineShaderStageCreateInfo(resourceTracker, (VkPipelineShaderStageCreateInfo*)(toTransform->pStages + i));
        }
    }
    if (toTransform->pVertexInputState)
    {
        transform_VkPipelineVertexInputStateCreateInfo(resourceTracker, (VkPipelineVertexInputStateCreateInfo*)(toTransform->pVertexInputState));
    }
    if (toTransform->pInputAssemblyState)
    {
        transform_VkPipelineInputAssemblyStateCreateInfo(resourceTracker, (VkPipelineInputAssemblyStateCreateInfo*)(toTransform->pInputAssemblyState));
    }
    if (toTransform->pTessellationState)
    {
        transform_VkPipelineTessellationStateCreateInfo(resourceTracker, (VkPipelineTessellationStateCreateInfo*)(toTransform->pTessellationState));
    }
    if (toTransform->pViewportState)
    {
        transform_VkPipelineViewportStateCreateInfo(resourceTracker, (VkPipelineViewportStateCreateInfo*)(toTransform->pViewportState));
    }
    if (toTransform->pRasterizationState)
    {
        transform_VkPipelineRasterizationStateCreateInfo(resourceTracker, (VkPipelineRasterizationStateCreateInfo*)(toTransform->pRasterizationState));
    }
    if (toTransform->pMultisampleState)
    {
        transform_VkPipelineMultisampleStateCreateInfo(resourceTracker, (VkPipelineMultisampleStateCreateInfo*)(toTransform->pMultisampleState));
    }
    if (toTransform->pDepthStencilState)
    {
        transform_VkPipelineDepthStencilStateCreateInfo(resourceTracker, (VkPipelineDepthStencilStateCreateInfo*)(toTransform->pDepthStencilState));
    }
    if (toTransform->pColorBlendState)
    {
        transform_VkPipelineColorBlendStateCreateInfo(resourceTracker, (VkPipelineColorBlendStateCreateInfo*)(toTransform->pColorBlendState));
    }
    if (toTransform->pDynamicState)
    {
        transform_VkPipelineDynamicStateCreateInfo(resourceTracker, (VkPipelineDynamicStateCreateInfo*)(toTransform->pDynamicState));
    }
}

void transform_VkComputePipelineCreateInfo(
    ResourceTracker* resourceTracker,
    VkComputePipelineCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkPipelineShaderStageCreateInfo(resourceTracker, (VkPipelineShaderStageCreateInfo*)(&toTransform->stage));
}

void transform_VkPushConstantRange(
    ResourceTracker* resourceTracker,
    VkPushConstantRange* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineLayoutCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineLayoutCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pPushConstantRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->pushConstantRangeCount; ++i)
        {
            transform_VkPushConstantRange(resourceTracker, (VkPushConstantRange*)(toTransform->pPushConstantRanges + i));
        }
    }
}

void transform_VkSamplerCreateInfo(
    ResourceTracker* resourceTracker,
    VkSamplerCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDescriptorSetLayoutBinding(
    ResourceTracker* resourceTracker,
    VkDescriptorSetLayoutBinding* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDescriptorSetLayoutCreateInfo(
    ResourceTracker* resourceTracker,
    VkDescriptorSetLayoutCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pBindings)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->bindingCount; ++i)
        {
            transform_VkDescriptorSetLayoutBinding(resourceTracker, (VkDescriptorSetLayoutBinding*)(toTransform->pBindings + i));
        }
    }
}

void transform_VkDescriptorPoolSize(
    ResourceTracker* resourceTracker,
    VkDescriptorPoolSize* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDescriptorPoolCreateInfo(
    ResourceTracker* resourceTracker,
    VkDescriptorPoolCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pPoolSizes)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->poolSizeCount; ++i)
        {
            transform_VkDescriptorPoolSize(resourceTracker, (VkDescriptorPoolSize*)(toTransform->pPoolSizes + i));
        }
    }
}

void transform_VkDescriptorSetAllocateInfo(
    ResourceTracker* resourceTracker,
    VkDescriptorSetAllocateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDescriptorImageInfo(
    ResourceTracker* resourceTracker,
    VkDescriptorImageInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDescriptorBufferInfo(
    ResourceTracker* resourceTracker,
    VkDescriptorBufferInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkWriteDescriptorSet(
    ResourceTracker* resourceTracker,
    VkWriteDescriptorSet* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pImageInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->descriptorCount; ++i)
        {
            transform_VkDescriptorImageInfo(resourceTracker, (VkDescriptorImageInfo*)(toTransform->pImageInfo + i));
        }
    }
    if (toTransform->pBufferInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->descriptorCount; ++i)
        {
            transform_VkDescriptorBufferInfo(resourceTracker, (VkDescriptorBufferInfo*)(toTransform->pBufferInfo + i));
        }
    }
}

void transform_VkCopyDescriptorSet(
    ResourceTracker* resourceTracker,
    VkCopyDescriptorSet* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkFramebufferCreateInfo(
    ResourceTracker* resourceTracker,
    VkFramebufferCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkAttachmentDescription(
    ResourceTracker* resourceTracker,
    VkAttachmentDescription* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkAttachmentReference(
    ResourceTracker* resourceTracker,
    VkAttachmentReference* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkSubpassDescription(
    ResourceTracker* resourceTracker,
    VkSubpassDescription* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pInputAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->inputAttachmentCount; ++i)
        {
            transform_VkAttachmentReference(resourceTracker, (VkAttachmentReference*)(toTransform->pInputAttachments + i));
        }
    }
    if (toTransform->pColorAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->colorAttachmentCount; ++i)
        {
            transform_VkAttachmentReference(resourceTracker, (VkAttachmentReference*)(toTransform->pColorAttachments + i));
        }
    }
    if (toTransform->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->colorAttachmentCount; ++i)
        {
            transform_VkAttachmentReference(resourceTracker, (VkAttachmentReference*)(toTransform->pResolveAttachments + i));
        }
    }
    if (toTransform->pDepthStencilAttachment)
    {
        transform_VkAttachmentReference(resourceTracker, (VkAttachmentReference*)(toTransform->pDepthStencilAttachment));
    }
}

void transform_VkSubpassDependency(
    ResourceTracker* resourceTracker,
    VkSubpassDependency* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkRenderPassCreateInfo(
    ResourceTracker* resourceTracker,
    VkRenderPassCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->attachmentCount; ++i)
        {
            transform_VkAttachmentDescription(resourceTracker, (VkAttachmentDescription*)(toTransform->pAttachments + i));
        }
    }
    if (toTransform->pSubpasses)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->subpassCount; ++i)
        {
            transform_VkSubpassDescription(resourceTracker, (VkSubpassDescription*)(toTransform->pSubpasses + i));
        }
    }
    if (toTransform->pDependencies)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->dependencyCount; ++i)
        {
            transform_VkSubpassDependency(resourceTracker, (VkSubpassDependency*)(toTransform->pDependencies + i));
        }
    }
}

void transform_VkCommandPoolCreateInfo(
    ResourceTracker* resourceTracker,
    VkCommandPoolCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkCommandBufferAllocateInfo(
    ResourceTracker* resourceTracker,
    VkCommandBufferAllocateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkCommandBufferInheritanceInfo(
    ResourceTracker* resourceTracker,
    VkCommandBufferInheritanceInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkCommandBufferBeginInfo(
    ResourceTracker* resourceTracker,
    VkCommandBufferBeginInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pInheritanceInfo)
    {
        transform_VkCommandBufferInheritanceInfo(resourceTracker, (VkCommandBufferInheritanceInfo*)(toTransform->pInheritanceInfo));
    }
}

void transform_VkBufferCopy(
    ResourceTracker* resourceTracker,
    VkBufferCopy* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkImageSubresourceLayers(
    ResourceTracker* resourceTracker,
    VkImageSubresourceLayers* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkImageCopy(
    ResourceTracker* resourceTracker,
    VkImageCopy* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->srcSubresource));
    transform_VkOffset3D(resourceTracker, (VkOffset3D*)(&toTransform->srcOffset));
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->dstSubresource));
    transform_VkOffset3D(resourceTracker, (VkOffset3D*)(&toTransform->dstOffset));
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->extent));
}

void transform_VkImageBlit(
    ResourceTracker* resourceTracker,
    VkImageBlit* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        transform_VkOffset3D(resourceTracker, (VkOffset3D*)(toTransform->srcOffsets + i));
    }
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        transform_VkOffset3D(resourceTracker, (VkOffset3D*)(toTransform->dstOffsets + i));
    }
}

void transform_VkBufferImageCopy(
    ResourceTracker* resourceTracker,
    VkBufferImageCopy* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->imageSubresource));
    transform_VkOffset3D(resourceTracker, (VkOffset3D*)(&toTransform->imageOffset));
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->imageExtent));
}

void transform_VkClearColorValue(
    ResourceTracker* resourceTracker,
    VkClearColorValue* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkClearDepthStencilValue(
    ResourceTracker* resourceTracker,
    VkClearDepthStencilValue* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkClearValue(
    ResourceTracker* resourceTracker,
    VkClearValue* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkClearColorValue(resourceTracker, (VkClearColorValue*)(&toTransform->color));
    transform_VkClearDepthStencilValue(resourceTracker, (VkClearDepthStencilValue*)(&toTransform->depthStencil));
}

void transform_VkClearAttachment(
    ResourceTracker* resourceTracker,
    VkClearAttachment* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkClearValue(resourceTracker, (VkClearValue*)(&toTransform->clearValue));
}

void transform_VkClearRect(
    ResourceTracker* resourceTracker,
    VkClearRect* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkRect2D(resourceTracker, (VkRect2D*)(&toTransform->rect));
}

void transform_VkImageResolve(
    ResourceTracker* resourceTracker,
    VkImageResolve* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->srcSubresource));
    transform_VkOffset3D(resourceTracker, (VkOffset3D*)(&toTransform->srcOffset));
    transform_VkImageSubresourceLayers(resourceTracker, (VkImageSubresourceLayers*)(&toTransform->dstSubresource));
    transform_VkOffset3D(resourceTracker, (VkOffset3D*)(&toTransform->dstOffset));
    transform_VkExtent3D(resourceTracker, (VkExtent3D*)(&toTransform->extent));
}

void transform_VkMemoryBarrier(
    ResourceTracker* resourceTracker,
    VkMemoryBarrier* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBufferMemoryBarrier(
    ResourceTracker* resourceTracker,
    VkBufferMemoryBarrier* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkImageMemoryBarrier(
    ResourceTracker* resourceTracker,
    VkImageMemoryBarrier* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkImageSubresourceRange(resourceTracker, (VkImageSubresourceRange*)(&toTransform->subresourceRange));
}

void transform_VkRenderPassBeginInfo(
    ResourceTracker* resourceTracker,
    VkRenderPassBeginInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkRect2D(resourceTracker, (VkRect2D*)(&toTransform->renderArea));
    if (toTransform->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->clearValueCount; ++i)
        {
            transform_VkClearValue(resourceTracker, (VkClearValue*)(toTransform->pClearValues + i));
        }
    }
}

void transform_VkDispatchIndirectCommand(
    ResourceTracker* resourceTracker,
    VkDispatchIndirectCommand* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDrawIndexedIndirectCommand(
    ResourceTracker* resourceTracker,
    VkDrawIndexedIndirectCommand* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDrawIndirectCommand(
    ResourceTracker* resourceTracker,
    VkDrawIndirectCommand* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkBaseOutStructure(
    ResourceTracker* resourceTracker,
    VkBaseOutStructure* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBaseInStructure(
    ResourceTracker* resourceTracker,
    VkBaseInStructure* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_VERSION_1_1
void transform_VkPhysicalDeviceSubgroupProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSubgroupProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBindBufferMemoryInfo(
    ResourceTracker* resourceTracker,
    VkBindBufferMemoryInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, &toTransform->memoryOffset, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBindImageMemoryInfo(
    ResourceTracker* resourceTracker,
    VkBindImageMemoryInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, nullptr, 1, &toTransform->memoryOffset, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDevice16BitStorageFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDevice16BitStorageFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryDedicatedRequirements(
    ResourceTracker* resourceTracker,
    VkMemoryDedicatedRequirements* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryDedicatedAllocateInfo(
    ResourceTracker* resourceTracker,
    VkMemoryDedicatedAllocateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryAllocateFlagsInfo(
    ResourceTracker* resourceTracker,
    VkMemoryAllocateFlagsInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupRenderPassBeginInfo(
    ResourceTracker* resourceTracker,
    VkDeviceGroupRenderPassBeginInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pDeviceRenderAreas)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->deviceRenderAreaCount; ++i)
        {
            transform_VkRect2D(resourceTracker, (VkRect2D*)(toTransform->pDeviceRenderAreas + i));
        }
    }
}

void transform_VkDeviceGroupCommandBufferBeginInfo(
    ResourceTracker* resourceTracker,
    VkDeviceGroupCommandBufferBeginInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupSubmitInfo(
    ResourceTracker* resourceTracker,
    VkDeviceGroupSubmitInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupBindSparseInfo(
    ResourceTracker* resourceTracker,
    VkDeviceGroupBindSparseInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBindBufferMemoryDeviceGroupInfo(
    ResourceTracker* resourceTracker,
    VkBindBufferMemoryDeviceGroupInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBindImageMemoryDeviceGroupInfo(
    ResourceTracker* resourceTracker,
    VkBindImageMemoryDeviceGroupInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pSplitInstanceBindRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->splitInstanceBindRegionCount; ++i)
        {
            transform_VkRect2D(resourceTracker, (VkRect2D*)(toTransform->pSplitInstanceBindRegions + i));
        }
    }
}

void transform_VkPhysicalDeviceGroupProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceGroupProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupDeviceCreateInfo(
    ResourceTracker* resourceTracker,
    VkDeviceGroupDeviceCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBufferMemoryRequirementsInfo2(
    ResourceTracker* resourceTracker,
    VkBufferMemoryRequirementsInfo2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkImageMemoryRequirementsInfo2(
    ResourceTracker* resourceTracker,
    VkImageMemoryRequirementsInfo2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkImageSparseMemoryRequirementsInfo2(
    ResourceTracker* resourceTracker,
    VkImageSparseMemoryRequirementsInfo2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryRequirements2(
    ResourceTracker* resourceTracker,
    VkMemoryRequirements2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkMemoryRequirements(resourceTracker, (VkMemoryRequirements*)(&toTransform->memoryRequirements));
}

void transform_VkSparseImageMemoryRequirements2(
    ResourceTracker* resourceTracker,
    VkSparseImageMemoryRequirements2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkSparseImageMemoryRequirements(resourceTracker, (VkSparseImageMemoryRequirements*)(&toTransform->memoryRequirements));
}

void transform_VkPhysicalDeviceFeatures2(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceFeatures2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkPhysicalDeviceFeatures(resourceTracker, (VkPhysicalDeviceFeatures*)(&toTransform->features));
}

void transform_VkPhysicalDeviceProperties2(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceProperties2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkPhysicalDeviceProperties(resourceTracker, (VkPhysicalDeviceProperties*)(&toTransform->properties));
}

void transform_VkFormatProperties2(
    ResourceTracker* resourceTracker,
    VkFormatProperties2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkFormatProperties(resourceTracker, (VkFormatProperties*)(&toTransform->formatProperties));
}

void transform_VkImageFormatProperties2(
    ResourceTracker* resourceTracker,
    VkImageFormatProperties2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkImageFormatProperties(resourceTracker, (VkImageFormatProperties*)(&toTransform->imageFormatProperties));
}

void transform_VkPhysicalDeviceImageFormatInfo2(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceImageFormatInfo2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkQueueFamilyProperties2(
    ResourceTracker* resourceTracker,
    VkQueueFamilyProperties2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkQueueFamilyProperties(resourceTracker, (VkQueueFamilyProperties*)(&toTransform->queueFamilyProperties));
}

void transform_VkPhysicalDeviceMemoryProperties2(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceMemoryProperties2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkPhysicalDeviceMemoryProperties(resourceTracker, (VkPhysicalDeviceMemoryProperties*)(&toTransform->memoryProperties));
}

void transform_VkSparseImageFormatProperties2(
    ResourceTracker* resourceTracker,
    VkSparseImageFormatProperties2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkSparseImageFormatProperties(resourceTracker, (VkSparseImageFormatProperties*)(&toTransform->properties));
}

void transform_VkPhysicalDeviceSparseImageFormatInfo2(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSparseImageFormatInfo2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDevicePointClippingProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDevicePointClippingProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkInputAttachmentAspectReference(
    ResourceTracker* resourceTracker,
    VkInputAttachmentAspectReference* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkRenderPassInputAttachmentAspectCreateInfo(
    ResourceTracker* resourceTracker,
    VkRenderPassInputAttachmentAspectCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pAspectReferences)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->aspectReferenceCount; ++i)
        {
            transform_VkInputAttachmentAspectReference(resourceTracker, (VkInputAttachmentAspectReference*)(toTransform->pAspectReferences + i));
        }
    }
}

void transform_VkImageViewUsageCreateInfo(
    ResourceTracker* resourceTracker,
    VkImageViewUsageCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineTessellationDomainOriginStateCreateInfo(
    ResourceTracker* resourceTracker,
    VkPipelineTessellationDomainOriginStateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkRenderPassMultiviewCreateInfo(
    ResourceTracker* resourceTracker,
    VkRenderPassMultiviewCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceMultiviewFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceMultiviewFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceMultiviewProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceMultiviewProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceVariablePointerFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceVariablePointerFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceProtectedMemoryFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceProtectedMemoryFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceProtectedMemoryProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceProtectedMemoryProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceQueueInfo2(
    ResourceTracker* resourceTracker,
    VkDeviceQueueInfo2* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkProtectedSubmitInfo(
    ResourceTracker* resourceTracker,
    VkProtectedSubmitInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSamplerYcbcrConversionCreateInfo(
    ResourceTracker* resourceTracker,
    VkSamplerYcbcrConversionCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkComponentMapping(resourceTracker, (VkComponentMapping*)(&toTransform->components));
}

void transform_VkSamplerYcbcrConversionInfo(
    ResourceTracker* resourceTracker,
    VkSamplerYcbcrConversionInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBindImagePlaneMemoryInfo(
    ResourceTracker* resourceTracker,
    VkBindImagePlaneMemoryInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkImagePlaneMemoryRequirementsInfo(
    ResourceTracker* resourceTracker,
    VkImagePlaneMemoryRequirementsInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSamplerYcbcrConversionImageFormatProperties(
    ResourceTracker* resourceTracker,
    VkSamplerYcbcrConversionImageFormatProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDescriptorUpdateTemplateEntry(
    ResourceTracker* resourceTracker,
    VkDescriptorUpdateTemplateEntry* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDescriptorUpdateTemplateCreateInfo(
    ResourceTracker* resourceTracker,
    VkDescriptorUpdateTemplateCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pDescriptorUpdateEntries)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->descriptorUpdateEntryCount; ++i)
        {
            transform_VkDescriptorUpdateTemplateEntry(resourceTracker, (VkDescriptorUpdateTemplateEntry*)(toTransform->pDescriptorUpdateEntries + i));
        }
    }
}

void transform_VkExternalMemoryProperties(
    ResourceTracker* resourceTracker,
    VkExternalMemoryProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPhysicalDeviceExternalImageFormatInfo(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceExternalImageFormatInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalImageFormatProperties(
    ResourceTracker* resourceTracker,
    VkExternalImageFormatProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExternalMemoryProperties(resourceTracker, (VkExternalMemoryProperties*)(&toTransform->externalMemoryProperties));
}

void transform_VkPhysicalDeviceExternalBufferInfo(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceExternalBufferInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalBufferProperties(
    ResourceTracker* resourceTracker,
    VkExternalBufferProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExternalMemoryProperties(resourceTracker, (VkExternalMemoryProperties*)(&toTransform->externalMemoryProperties));
}

void transform_VkPhysicalDeviceIDProperties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceIDProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalMemoryImageCreateInfo(
    ResourceTracker* resourceTracker,
    VkExternalMemoryImageCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalMemoryBufferCreateInfo(
    ResourceTracker* resourceTracker,
    VkExternalMemoryBufferCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportMemoryAllocateInfo(
    ResourceTracker* resourceTracker,
    VkExportMemoryAllocateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceExternalFenceInfo(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceExternalFenceInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalFenceProperties(
    ResourceTracker* resourceTracker,
    VkExternalFenceProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportFenceCreateInfo(
    ResourceTracker* resourceTracker,
    VkExportFenceCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportSemaphoreCreateInfo(
    ResourceTracker* resourceTracker,
    VkExportSemaphoreCreateInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceExternalSemaphoreInfo(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceExternalSemaphoreInfo* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalSemaphoreProperties(
    ResourceTracker* resourceTracker,
    VkExternalSemaphoreProperties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceMaintenance3Properties(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceMaintenance3Properties* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDescriptorSetLayoutSupport(
    ResourceTracker* resourceTracker,
    VkDescriptorSetLayoutSupport* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceShaderDrawParameterFeatures(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceShaderDrawParameterFeatures* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_surface
void transform_VkSurfaceCapabilitiesKHR(
    ResourceTracker* resourceTracker,
    VkSurfaceCapabilitiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->currentExtent));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->minImageExtent));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->maxImageExtent));
}

void transform_VkSurfaceFormatKHR(
    ResourceTracker* resourceTracker,
    VkSurfaceFormatKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

#endif
#ifdef VK_KHR_swapchain
void transform_VkSwapchainCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkSwapchainCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->imageExtent));
}

void transform_VkPresentInfoKHR(
    ResourceTracker* resourceTracker,
    VkPresentInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkImageSwapchainCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkImageSwapchainCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkBindImageMemorySwapchainInfoKHR(
    ResourceTracker* resourceTracker,
    VkBindImageMemorySwapchainInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkAcquireNextImageInfoKHR(
    ResourceTracker* resourceTracker,
    VkAcquireNextImageInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupPresentCapabilitiesKHR(
    ResourceTracker* resourceTracker,
    VkDeviceGroupPresentCapabilitiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupPresentInfoKHR(
    ResourceTracker* resourceTracker,
    VkDeviceGroupPresentInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGroupSwapchainCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkDeviceGroupSwapchainCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_display
void transform_VkDisplayPropertiesKHR(
    ResourceTracker* resourceTracker,
    VkDisplayPropertiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->physicalDimensions));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->physicalResolution));
}

void transform_VkDisplayModeParametersKHR(
    ResourceTracker* resourceTracker,
    VkDisplayModeParametersKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->visibleRegion));
}

void transform_VkDisplayModePropertiesKHR(
    ResourceTracker* resourceTracker,
    VkDisplayModePropertiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkDisplayModeParametersKHR(resourceTracker, (VkDisplayModeParametersKHR*)(&toTransform->parameters));
}

void transform_VkDisplayModeCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkDisplayModeCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkDisplayModeParametersKHR(resourceTracker, (VkDisplayModeParametersKHR*)(&toTransform->parameters));
}

void transform_VkDisplayPlaneCapabilitiesKHR(
    ResourceTracker* resourceTracker,
    VkDisplayPlaneCapabilitiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkOffset2D(resourceTracker, (VkOffset2D*)(&toTransform->minSrcPosition));
    transform_VkOffset2D(resourceTracker, (VkOffset2D*)(&toTransform->maxSrcPosition));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->minSrcExtent));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->maxSrcExtent));
    transform_VkOffset2D(resourceTracker, (VkOffset2D*)(&toTransform->minDstPosition));
    transform_VkOffset2D(resourceTracker, (VkOffset2D*)(&toTransform->maxDstPosition));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->minDstExtent));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->maxDstExtent));
}

void transform_VkDisplayPlanePropertiesKHR(
    ResourceTracker* resourceTracker,
    VkDisplayPlanePropertiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkDisplaySurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkDisplaySurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void transform_VkDisplayPresentInfoKHR(
    ResourceTracker* resourceTracker,
    VkDisplayPresentInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkRect2D(resourceTracker, (VkRect2D*)(&toTransform->srcRect));
    transform_VkRect2D(resourceTracker, (VkRect2D*)(&toTransform->dstRect));
}

#endif
#ifdef VK_KHR_xlib_surface
void transform_VkXlibSurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkXlibSurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_xcb_surface
void transform_VkXcbSurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkXcbSurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_wayland_surface
void transform_VkWaylandSurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkWaylandSurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_mir_surface
void transform_VkMirSurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkMirSurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_android_surface
void transform_VkAndroidSurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkAndroidSurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_win32_surface
void transform_VkWin32SurfaceCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkWin32SurfaceCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void transform_VkImportMemoryWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkImportMemoryWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportMemoryWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkExportMemoryWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryWin32HandlePropertiesKHR(
    ResourceTracker* resourceTracker,
    VkMemoryWin32HandlePropertiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1, &toTransform->memoryTypeBits, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryGetWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkMemoryGetWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_external_memory_fd
void transform_VkImportMemoryFdInfoKHR(
    ResourceTracker* resourceTracker,
    VkImportMemoryFdInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryFdPropertiesKHR(
    ResourceTracker* resourceTracker,
    VkMemoryFdPropertiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1, &toTransform->memoryTypeBits, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryGetFdInfoKHR(
    ResourceTracker* resourceTracker,
    VkMemoryGetFdInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void transform_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    ResourceTracker* resourceTracker,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(toTransform->pReleaseSyncs, toTransform->releaseCount, nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void transform_VkImportSemaphoreWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkImportSemaphoreWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportSemaphoreWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkExportSemaphoreWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkD3D12FenceSubmitInfoKHR(
    ResourceTracker* resourceTracker,
    VkD3D12FenceSubmitInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSemaphoreGetWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkSemaphoreGetWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void transform_VkImportSemaphoreFdInfoKHR(
    ResourceTracker* resourceTracker,
    VkImportSemaphoreFdInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSemaphoreGetFdInfoKHR(
    ResourceTracker* resourceTracker,
    VkSemaphoreGetFdInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_push_descriptor
void transform_VkPhysicalDevicePushDescriptorPropertiesKHR(
    ResourceTracker* resourceTracker,
    VkPhysicalDevicePushDescriptorPropertiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void transform_VkRectLayerKHR(
    ResourceTracker* resourceTracker,
    VkRectLayerKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkOffset2D(resourceTracker, (VkOffset2D*)(&toTransform->offset));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->extent));
}

void transform_VkPresentRegionKHR(
    ResourceTracker* resourceTracker,
    VkPresentRegionKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->rectangleCount; ++i)
        {
            transform_VkRectLayerKHR(resourceTracker, (VkRectLayerKHR*)(toTransform->pRectangles + i));
        }
    }
}

void transform_VkPresentRegionsKHR(
    ResourceTracker* resourceTracker,
    VkPresentRegionsKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->swapchainCount; ++i)
        {
            transform_VkPresentRegionKHR(resourceTracker, (VkPresentRegionKHR*)(toTransform->pRegions + i));
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void transform_VkAttachmentDescription2KHR(
    ResourceTracker* resourceTracker,
    VkAttachmentDescription2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkAttachmentReference2KHR(
    ResourceTracker* resourceTracker,
    VkAttachmentReference2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSubpassDescription2KHR(
    ResourceTracker* resourceTracker,
    VkSubpassDescription2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pInputAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->inputAttachmentCount; ++i)
        {
            transform_VkAttachmentReference2KHR(resourceTracker, (VkAttachmentReference2KHR*)(toTransform->pInputAttachments + i));
        }
    }
    if (toTransform->pColorAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->colorAttachmentCount; ++i)
        {
            transform_VkAttachmentReference2KHR(resourceTracker, (VkAttachmentReference2KHR*)(toTransform->pColorAttachments + i));
        }
    }
    if (toTransform->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->colorAttachmentCount; ++i)
        {
            transform_VkAttachmentReference2KHR(resourceTracker, (VkAttachmentReference2KHR*)(toTransform->pResolveAttachments + i));
        }
    }
    if (toTransform->pDepthStencilAttachment)
    {
        transform_VkAttachmentReference2KHR(resourceTracker, (VkAttachmentReference2KHR*)(toTransform->pDepthStencilAttachment));
    }
}

void transform_VkSubpassDependency2KHR(
    ResourceTracker* resourceTracker,
    VkSubpassDependency2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkRenderPassCreateInfo2KHR(
    ResourceTracker* resourceTracker,
    VkRenderPassCreateInfo2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->attachmentCount; ++i)
        {
            transform_VkAttachmentDescription2KHR(resourceTracker, (VkAttachmentDescription2KHR*)(toTransform->pAttachments + i));
        }
    }
    if (toTransform->pSubpasses)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->subpassCount; ++i)
        {
            transform_VkSubpassDescription2KHR(resourceTracker, (VkSubpassDescription2KHR*)(toTransform->pSubpasses + i));
        }
    }
    if (toTransform->pDependencies)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->dependencyCount; ++i)
        {
            transform_VkSubpassDependency2KHR(resourceTracker, (VkSubpassDependency2KHR*)(toTransform->pDependencies + i));
        }
    }
}

void transform_VkSubpassBeginInfoKHR(
    ResourceTracker* resourceTracker,
    VkSubpassBeginInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSubpassEndInfoKHR(
    ResourceTracker* resourceTracker,
    VkSubpassEndInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_shared_presentable_image
void transform_VkSharedPresentSurfaceCapabilitiesKHR(
    ResourceTracker* resourceTracker,
    VkSharedPresentSurfaceCapabilitiesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void transform_VkImportFenceWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkImportFenceWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportFenceWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkExportFenceWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkFenceGetWin32HandleInfoKHR(
    ResourceTracker* resourceTracker,
    VkFenceGetWin32HandleInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_external_fence_fd
void transform_VkImportFenceFdInfoKHR(
    ResourceTracker* resourceTracker,
    VkImportFenceFdInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkFenceGetFdInfoKHR(
    ResourceTracker* resourceTracker,
    VkFenceGetFdInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void transform_VkPhysicalDeviceSurfaceInfo2KHR(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSurfaceInfo2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSurfaceCapabilities2KHR(
    ResourceTracker* resourceTracker,
    VkSurfaceCapabilities2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkSurfaceCapabilitiesKHR(resourceTracker, (VkSurfaceCapabilitiesKHR*)(&toTransform->surfaceCapabilities));
}

void transform_VkSurfaceFormat2KHR(
    ResourceTracker* resourceTracker,
    VkSurfaceFormat2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkSurfaceFormatKHR(resourceTracker, (VkSurfaceFormatKHR*)(&toTransform->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void transform_VkDisplayProperties2KHR(
    ResourceTracker* resourceTracker,
    VkDisplayProperties2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkDisplayPropertiesKHR(resourceTracker, (VkDisplayPropertiesKHR*)(&toTransform->displayProperties));
}

void transform_VkDisplayPlaneProperties2KHR(
    ResourceTracker* resourceTracker,
    VkDisplayPlaneProperties2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkDisplayPlanePropertiesKHR(resourceTracker, (VkDisplayPlanePropertiesKHR*)(&toTransform->displayPlaneProperties));
}

void transform_VkDisplayModeProperties2KHR(
    ResourceTracker* resourceTracker,
    VkDisplayModeProperties2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkDisplayModePropertiesKHR(resourceTracker, (VkDisplayModePropertiesKHR*)(&toTransform->displayModeProperties));
}

void transform_VkDisplayPlaneInfo2KHR(
    ResourceTracker* resourceTracker,
    VkDisplayPlaneInfo2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDisplayPlaneCapabilities2KHR(
    ResourceTracker* resourceTracker,
    VkDisplayPlaneCapabilities2KHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkDisplayPlaneCapabilitiesKHR(resourceTracker, (VkDisplayPlaneCapabilitiesKHR*)(&toTransform->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void transform_VkImageFormatListCreateInfoKHR(
    ResourceTracker* resourceTracker,
    VkImageFormatListCreateInfoKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void transform_VkPhysicalDevice8BitStorageFeaturesKHR(
    ResourceTracker* resourceTracker,
    VkPhysicalDevice8BitStorageFeaturesKHR* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void transform_VkNativeBufferANDROID(
    ResourceTracker* resourceTracker,
    VkNativeBufferANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_debug_report
void transform_VkDebugReportCallbackCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugReportCallbackCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void transform_VkPipelineRasterizationStateRasterizationOrderAMD(
    ResourceTracker* resourceTracker,
    VkPipelineRasterizationStateRasterizationOrderAMD* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void transform_VkDebugMarkerObjectNameInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugMarkerObjectNameInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDebugMarkerObjectTagInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugMarkerObjectTagInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDebugMarkerMarkerInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugMarkerMarkerInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void transform_VkDedicatedAllocationImageCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkDedicatedAllocationImageCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDedicatedAllocationBufferCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkDedicatedAllocationBufferCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDedicatedAllocationMemoryAllocateInfoNV(
    ResourceTracker* resourceTracker,
    VkDedicatedAllocationMemoryAllocateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void transform_VkTextureLODGatherFormatPropertiesAMD(
    ResourceTracker* resourceTracker,
    VkTextureLODGatherFormatPropertiesAMD* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_info
void transform_VkShaderResourceUsageAMD(
    ResourceTracker* resourceTracker,
    VkShaderResourceUsageAMD* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkShaderStatisticsInfoAMD(
    ResourceTracker* resourceTracker,
    VkShaderStatisticsInfoAMD* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkShaderResourceUsageAMD(resourceTracker, (VkShaderResourceUsageAMD*)(&toTransform->resourceUsage));
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void transform_VkExternalImageFormatPropertiesNV(
    ResourceTracker* resourceTracker,
    VkExternalImageFormatPropertiesNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkImageFormatProperties(resourceTracker, (VkImageFormatProperties*)(&toTransform->imageFormatProperties));
}

#endif
#ifdef VK_NV_external_memory
void transform_VkExternalMemoryImageCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkExternalMemoryImageCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportMemoryAllocateInfoNV(
    ResourceTracker* resourceTracker,
    VkExportMemoryAllocateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_external_memory_win32
void transform_VkImportMemoryWin32HandleInfoNV(
    ResourceTracker* resourceTracker,
    VkImportMemoryWin32HandleInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExportMemoryWin32HandleInfoNV(
    ResourceTracker* resourceTracker,
    VkExportMemoryWin32HandleInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void transform_VkWin32KeyedMutexAcquireReleaseInfoNV(
    ResourceTracker* resourceTracker,
    VkWin32KeyedMutexAcquireReleaseInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(toTransform->pReleaseSyncs, toTransform->releaseCount, nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_validation_flags
void transform_VkValidationFlagsEXT(
    ResourceTracker* resourceTracker,
    VkValidationFlagsEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NN_vi_surface
void transform_VkViSurfaceCreateInfoNN(
    ResourceTracker* resourceTracker,
    VkViSurfaceCreateInfoNN* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void transform_VkConditionalRenderingBeginInfoEXT(
    ResourceTracker* resourceTracker,
    VkConditionalRenderingBeginInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    ResourceTracker* resourceTracker,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NVX_device_generated_commands
void transform_VkDeviceGeneratedCommandsFeaturesNVX(
    ResourceTracker* resourceTracker,
    VkDeviceGeneratedCommandsFeaturesNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceGeneratedCommandsLimitsNVX(
    ResourceTracker* resourceTracker,
    VkDeviceGeneratedCommandsLimitsNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkIndirectCommandsTokenNVX(
    ResourceTracker* resourceTracker,
    VkIndirectCommandsTokenNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkIndirectCommandsLayoutTokenNVX(
    ResourceTracker* resourceTracker,
    VkIndirectCommandsLayoutTokenNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkIndirectCommandsLayoutCreateInfoNVX(
    ResourceTracker* resourceTracker,
    VkIndirectCommandsLayoutCreateInfoNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pTokens)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->tokenCount; ++i)
        {
            transform_VkIndirectCommandsLayoutTokenNVX(resourceTracker, (VkIndirectCommandsLayoutTokenNVX*)(toTransform->pTokens + i));
        }
    }
}

void transform_VkCmdProcessCommandsInfoNVX(
    ResourceTracker* resourceTracker,
    VkCmdProcessCommandsInfoNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pIndirectCommandsTokens)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->indirectCommandsTokenCount; ++i)
        {
            transform_VkIndirectCommandsTokenNVX(resourceTracker, (VkIndirectCommandsTokenNVX*)(toTransform->pIndirectCommandsTokens + i));
        }
    }
}

void transform_VkCmdReserveSpaceForCommandsInfoNVX(
    ResourceTracker* resourceTracker,
    VkCmdReserveSpaceForCommandsInfoNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkObjectTableCreateInfoNVX(
    ResourceTracker* resourceTracker,
    VkObjectTableCreateInfoNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkObjectTableEntryNVX(
    ResourceTracker* resourceTracker,
    VkObjectTableEntryNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkObjectTablePipelineEntryNVX(
    ResourceTracker* resourceTracker,
    VkObjectTablePipelineEntryNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkObjectTableDescriptorSetEntryNVX(
    ResourceTracker* resourceTracker,
    VkObjectTableDescriptorSetEntryNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkObjectTableVertexBufferEntryNVX(
    ResourceTracker* resourceTracker,
    VkObjectTableVertexBufferEntryNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkObjectTableIndexBufferEntryNVX(
    ResourceTracker* resourceTracker,
    VkObjectTableIndexBufferEntryNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkObjectTablePushConstantEntryNVX(
    ResourceTracker* resourceTracker,
    VkObjectTablePushConstantEntryNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void transform_VkViewportWScalingNV(
    ResourceTracker* resourceTracker,
    VkViewportWScalingNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineViewportWScalingStateCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkPipelineViewportWScalingStateCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->viewportCount; ++i)
        {
            transform_VkViewportWScalingNV(resourceTracker, (VkViewportWScalingNV*)(toTransform->pViewportWScalings + i));
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void transform_VkSurfaceCapabilities2EXT(
    ResourceTracker* resourceTracker,
    VkSurfaceCapabilities2EXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->currentExtent));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->minImageExtent));
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->maxImageExtent));
}

#endif
#ifdef VK_EXT_display_control
void transform_VkDisplayPowerInfoEXT(
    ResourceTracker* resourceTracker,
    VkDisplayPowerInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDeviceEventInfoEXT(
    ResourceTracker* resourceTracker,
    VkDeviceEventInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDisplayEventInfoEXT(
    ResourceTracker* resourceTracker,
    VkDisplayEventInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkSwapchainCounterCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkSwapchainCounterCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_display_timing
void transform_VkRefreshCycleDurationGOOGLE(
    ResourceTracker* resourceTracker,
    VkRefreshCycleDurationGOOGLE* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPastPresentationTimingGOOGLE(
    ResourceTracker* resourceTracker,
    VkPastPresentationTimingGOOGLE* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPresentTimeGOOGLE(
    ResourceTracker* resourceTracker,
    VkPresentTimeGOOGLE* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPresentTimesInfoGOOGLE(
    ResourceTracker* resourceTracker,
    VkPresentTimesInfoGOOGLE* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->swapchainCount; ++i)
        {
            transform_VkPresentTimeGOOGLE(resourceTracker, (VkPresentTimeGOOGLE*)(toTransform->pTimes + i));
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void transform_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_viewport_swizzle
void transform_VkViewportSwizzleNV(
    ResourceTracker* resourceTracker,
    VkViewportSwizzleNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineViewportSwizzleStateCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkPipelineViewportSwizzleStateCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->viewportCount; ++i)
        {
            transform_VkViewportSwizzleNV(resourceTracker, (VkViewportSwizzleNV*)(toTransform->pViewportSwizzles + i));
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void transform_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineDiscardRectangleStateCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkPipelineDiscardRectangleStateCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->discardRectangleCount; ++i)
        {
            transform_VkRect2D(resourceTracker, (VkRect2D*)(toTransform->pDiscardRectangles + i));
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void transform_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void transform_VkXYColorEXT(
    ResourceTracker* resourceTracker,
    VkXYColorEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkHdrMetadataEXT(
    ResourceTracker* resourceTracker,
    VkHdrMetadataEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkXYColorEXT(resourceTracker, (VkXYColorEXT*)(&toTransform->displayPrimaryRed));
    transform_VkXYColorEXT(resourceTracker, (VkXYColorEXT*)(&toTransform->displayPrimaryGreen));
    transform_VkXYColorEXT(resourceTracker, (VkXYColorEXT*)(&toTransform->displayPrimaryBlue));
    transform_VkXYColorEXT(resourceTracker, (VkXYColorEXT*)(&toTransform->whitePoint));
}

#endif
#ifdef VK_MVK_ios_surface
void transform_VkIOSSurfaceCreateInfoMVK(
    ResourceTracker* resourceTracker,
    VkIOSSurfaceCreateInfoMVK* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_MVK_macos_surface
void transform_VkMacOSSurfaceCreateInfoMVK(
    ResourceTracker* resourceTracker,
    VkMacOSSurfaceCreateInfoMVK* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void transform_VkDebugUtilsObjectNameInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugUtilsObjectNameInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDebugUtilsObjectTagInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugUtilsObjectTagInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDebugUtilsLabelEXT(
    ResourceTracker* resourceTracker,
    VkDebugUtilsLabelEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDebugUtilsMessengerCallbackDataEXT(
    ResourceTracker* resourceTracker,
    VkDebugUtilsMessengerCallbackDataEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->queueLabelCount; ++i)
        {
            transform_VkDebugUtilsLabelEXT(resourceTracker, (VkDebugUtilsLabelEXT*)(toTransform->pQueueLabels + i));
        }
    }
    if (toTransform->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->cmdBufLabelCount; ++i)
        {
            transform_VkDebugUtilsLabelEXT(resourceTracker, (VkDebugUtilsLabelEXT*)(toTransform->pCmdBufLabels + i));
        }
    }
    if (toTransform->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->objectCount; ++i)
        {
            transform_VkDebugUtilsObjectNameInfoEXT(resourceTracker, (VkDebugUtilsObjectNameInfoEXT*)(toTransform->pObjects + i));
        }
    }
}

void transform_VkDebugUtilsMessengerCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkDebugUtilsMessengerCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void transform_VkAndroidHardwareBufferUsageANDROID(
    ResourceTracker* resourceTracker,
    VkAndroidHardwareBufferUsageANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkAndroidHardwareBufferPropertiesANDROID(
    ResourceTracker* resourceTracker,
    VkAndroidHardwareBufferPropertiesANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1, &toTransform->memoryTypeBits, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkAndroidHardwareBufferFormatPropertiesANDROID(
    ResourceTracker* resourceTracker,
    VkAndroidHardwareBufferFormatPropertiesANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkComponentMapping(resourceTracker, (VkComponentMapping*)(&toTransform->samplerYcbcrConversionComponents));
}

void transform_VkImportAndroidHardwareBufferInfoANDROID(
    ResourceTracker* resourceTracker,
    VkImportAndroidHardwareBufferInfoANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    ResourceTracker* resourceTracker,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(&toTransform->memory, 1, nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkExternalFormatANDROID(
    ResourceTracker* resourceTracker,
    VkExternalFormatANDROID* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void transform_VkSamplerReductionModeCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkSamplerReductionModeCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void transform_VkSampleLocationEXT(
    ResourceTracker* resourceTracker,
    VkSampleLocationEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkSampleLocationsInfoEXT(
    ResourceTracker* resourceTracker,
    VkSampleLocationsInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->sampleLocationGridSize));
    if (toTransform->pSampleLocations)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->sampleLocationsCount; ++i)
        {
            transform_VkSampleLocationEXT(resourceTracker, (VkSampleLocationEXT*)(toTransform->pSampleLocations + i));
        }
    }
}

void transform_VkAttachmentSampleLocationsEXT(
    ResourceTracker* resourceTracker,
    VkAttachmentSampleLocationsEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkSampleLocationsInfoEXT(resourceTracker, (VkSampleLocationsInfoEXT*)(&toTransform->sampleLocationsInfo));
}

void transform_VkSubpassSampleLocationsEXT(
    ResourceTracker* resourceTracker,
    VkSubpassSampleLocationsEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    transform_VkSampleLocationsInfoEXT(resourceTracker, (VkSampleLocationsInfoEXT*)(&toTransform->sampleLocationsInfo));
}

void transform_VkRenderPassSampleLocationsBeginInfoEXT(
    ResourceTracker* resourceTracker,
    VkRenderPassSampleLocationsBeginInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pAttachmentInitialSampleLocations)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->attachmentInitialSampleLocationsCount; ++i)
        {
            transform_VkAttachmentSampleLocationsEXT(resourceTracker, (VkAttachmentSampleLocationsEXT*)(toTransform->pAttachmentInitialSampleLocations + i));
        }
    }
    if (toTransform->pPostSubpassSampleLocations)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->postSubpassSampleLocationsCount; ++i)
        {
            transform_VkSubpassSampleLocationsEXT(resourceTracker, (VkSubpassSampleLocationsEXT*)(toTransform->pPostSubpassSampleLocations + i));
        }
    }
}

void transform_VkPipelineSampleLocationsStateCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkPipelineSampleLocationsStateCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkSampleLocationsInfoEXT(resourceTracker, (VkSampleLocationsInfoEXT*)(&toTransform->sampleLocationsInfo));
}

void transform_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->maxSampleLocationGridSize));
}

void transform_VkMultisamplePropertiesEXT(
    ResourceTracker* resourceTracker,
    VkMultisamplePropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    transform_VkExtent2D(resourceTracker, (VkExtent2D*)(&toTransform->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void transform_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void transform_VkPipelineCoverageToColorStateCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkPipelineCoverageToColorStateCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void transform_VkPipelineCoverageModulationStateCreateInfoNV(
    ResourceTracker* resourceTracker,
    VkPipelineCoverageModulationStateCreateInfoNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void transform_VkValidationCacheCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkValidationCacheCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkShaderModuleValidationCacheCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkShaderModuleValidationCacheCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_descriptor_indexing
void transform_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    ResourceTracker* resourceTracker,
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    ResourceTracker* resourceTracker,
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void transform_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_external_memory_host
void transform_VkImportMemoryHostPointerInfoEXT(
    ResourceTracker* resourceTracker,
    VkImportMemoryHostPointerInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkMemoryHostPointerPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkMemoryHostPointerPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    resourceTracker->deviceMemoryTransform(nullptr, 1, nullptr, 1, nullptr, 1, nullptr, 1, &toTransform->memoryTypeBits, 1);
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void transform_VkPhysicalDeviceShaderCorePropertiesAMD(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceShaderCorePropertiesAMD* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void transform_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    ResourceTracker* resourceTracker,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkVertexInputBindingDivisorDescriptionEXT(
    ResourceTracker* resourceTracker,
    VkVertexInputBindingDivisorDescriptionEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
}

void transform_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    ResourceTracker* resourceTracker,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
    if (toTransform->pVertexBindingDivisors)
    {
        for (uint32_t i = 0; i < (uint32_t)toTransform->vertexBindingDivisorCount; ++i)
        {
            transform_VkVertexInputBindingDivisorDescriptionEXT(resourceTracker, (VkVertexInputBindingDivisorDescriptionEXT*)(toTransform->pVertexBindingDivisors + i));
        }
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void transform_VkQueueFamilyCheckpointPropertiesNV(
    ResourceTracker* resourceTracker,
    VkQueueFamilyCheckpointPropertiesNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

void transform_VkCheckpointDataNV(
    ResourceTracker* resourceTracker,
    VkCheckpointDataNV* toTransform)
{
    (void)resourceTracker;
    (void)toTransform;
    if (toTransform->pNext)
    {
        transform_extension_struct(resourceTracker, (void*)(toTransform->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
void transform_extension_struct(
    ResourceTracker* resourceTracker,
    void* structExtension_out)
{
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            transform_VkPhysicalDeviceSubgroupProperties(resourceTracker, reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            transform_VkPhysicalDevice16BitStorageFeatures(resourceTracker, reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            transform_VkMemoryDedicatedRequirements(resourceTracker, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            transform_VkMemoryDedicatedAllocateInfo(resourceTracker, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            transform_VkMemoryAllocateFlagsInfo(resourceTracker, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            transform_VkDeviceGroupRenderPassBeginInfo(resourceTracker, reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            transform_VkDeviceGroupCommandBufferBeginInfo(resourceTracker, reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            transform_VkDeviceGroupSubmitInfo(resourceTracker, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            transform_VkDeviceGroupBindSparseInfo(resourceTracker, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            transform_VkBindBufferMemoryDeviceGroupInfo(resourceTracker, reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            transform_VkBindImageMemoryDeviceGroupInfo(resourceTracker, reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            transform_VkDeviceGroupDeviceCreateInfo(resourceTracker, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            transform_VkPhysicalDeviceFeatures2(resourceTracker, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            transform_VkPhysicalDevicePointClippingProperties(resourceTracker, reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            transform_VkRenderPassInputAttachmentAspectCreateInfo(resourceTracker, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            transform_VkImageViewUsageCreateInfo(resourceTracker, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            transform_VkPipelineTessellationDomainOriginStateCreateInfo(resourceTracker, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            transform_VkRenderPassMultiviewCreateInfo(resourceTracker, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            transform_VkPhysicalDeviceMultiviewFeatures(resourceTracker, reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            transform_VkPhysicalDeviceMultiviewProperties(resourceTracker, reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            transform_VkPhysicalDeviceVariablePointerFeatures(resourceTracker, reinterpret_cast<VkPhysicalDeviceVariablePointerFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            transform_VkPhysicalDeviceProtectedMemoryFeatures(resourceTracker, reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            transform_VkPhysicalDeviceProtectedMemoryProperties(resourceTracker, reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            transform_VkProtectedSubmitInfo(resourceTracker, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            transform_VkSamplerYcbcrConversionInfo(resourceTracker, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            transform_VkBindImagePlaneMemoryInfo(resourceTracker, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            transform_VkImagePlaneMemoryRequirementsInfo(resourceTracker, reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            transform_VkPhysicalDeviceSamplerYcbcrConversionFeatures(resourceTracker, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            transform_VkSamplerYcbcrConversionImageFormatProperties(resourceTracker, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            transform_VkPhysicalDeviceExternalImageFormatInfo(resourceTracker, reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            transform_VkExternalImageFormatProperties(resourceTracker, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            transform_VkPhysicalDeviceIDProperties(resourceTracker, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            transform_VkExternalMemoryImageCreateInfo(resourceTracker, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            transform_VkExternalMemoryBufferCreateInfo(resourceTracker, reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            transform_VkExportMemoryAllocateInfo(resourceTracker, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            transform_VkExportFenceCreateInfo(resourceTracker, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            transform_VkExportSemaphoreCreateInfo(resourceTracker, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            transform_VkPhysicalDeviceMaintenance3Properties(resourceTracker, reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            transform_VkPhysicalDeviceShaderDrawParameterFeatures(resourceTracker, reinterpret_cast<VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            transform_VkImageSwapchainCreateInfoKHR(resourceTracker, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            transform_VkBindImageMemorySwapchainInfoKHR(resourceTracker, reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            transform_VkDeviceGroupPresentInfoKHR(resourceTracker, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            transform_VkDeviceGroupSwapchainCreateInfoKHR(resourceTracker, reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            transform_VkDisplayPresentInfoKHR(resourceTracker, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            transform_VkImportMemoryWin32HandleInfoKHR(resourceTracker, reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            transform_VkExportMemoryWin32HandleInfoKHR(resourceTracker, reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            transform_VkImportMemoryFdInfoKHR(resourceTracker, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            transform_VkWin32KeyedMutexAcquireReleaseInfoKHR(resourceTracker, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            transform_VkExportSemaphoreWin32HandleInfoKHR(resourceTracker, reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            transform_VkD3D12FenceSubmitInfoKHR(resourceTracker, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            transform_VkPhysicalDevicePushDescriptorPropertiesKHR(resourceTracker, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            transform_VkPresentRegionsKHR(resourceTracker, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            transform_VkSharedPresentSurfaceCapabilitiesKHR(resourceTracker, reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            transform_VkExportFenceWin32HandleInfoKHR(resourceTracker, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            transform_VkImageFormatListCreateInfoKHR(resourceTracker, reinterpret_cast<VkImageFormatListCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            transform_VkPhysicalDevice8BitStorageFeaturesKHR(resourceTracker, reinterpret_cast<VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            transform_VkNativeBufferANDROID(resourceTracker, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            transform_VkDebugReportCallbackCreateInfoEXT(resourceTracker, reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            transform_VkPipelineRasterizationStateRasterizationOrderAMD(resourceTracker, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            transform_VkDedicatedAllocationImageCreateInfoNV(resourceTracker, reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            transform_VkDedicatedAllocationBufferCreateInfoNV(resourceTracker, reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            transform_VkDedicatedAllocationMemoryAllocateInfoNV(resourceTracker, reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            transform_VkTextureLODGatherFormatPropertiesAMD(resourceTracker, reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            transform_VkExternalMemoryImageCreateInfoNV(resourceTracker, reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            transform_VkExportMemoryAllocateInfoNV(resourceTracker, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            transform_VkImportMemoryWin32HandleInfoNV(resourceTracker, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            transform_VkExportMemoryWin32HandleInfoNV(resourceTracker, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            transform_VkWin32KeyedMutexAcquireReleaseInfoNV(resourceTracker, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            transform_VkValidationFlagsEXT(resourceTracker, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            transform_VkPhysicalDeviceConditionalRenderingFeaturesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            transform_VkCommandBufferInheritanceConditionalRenderingInfoEXT(resourceTracker, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            transform_VkPipelineViewportWScalingStateCreateInfoNV(resourceTracker, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            transform_VkSwapchainCounterCreateInfoEXT(resourceTracker, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            transform_VkPresentTimesInfoGOOGLE(resourceTracker, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            transform_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(resourceTracker, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            transform_VkPipelineViewportSwizzleStateCreateInfoNV(resourceTracker, reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceDiscardRectanglePropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            transform_VkPipelineDiscardRectangleStateCreateInfoEXT(resourceTracker, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            transform_VkPipelineRasterizationConservativeStateCreateInfoEXT(resourceTracker, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            transform_VkDebugUtilsMessengerCreateInfoEXT(resourceTracker, reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            transform_VkAndroidHardwareBufferUsageANDROID(resourceTracker, reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            transform_VkAndroidHardwareBufferFormatPropertiesANDROID(resourceTracker, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            transform_VkImportAndroidHardwareBufferInfoANDROID(resourceTracker, reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            transform_VkExternalFormatANDROID(resourceTracker, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            transform_VkSamplerReductionModeCreateInfoEXT(resourceTracker, reinterpret_cast<VkSamplerReductionModeCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            transform_VkSampleLocationsInfoEXT(resourceTracker, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            transform_VkRenderPassSampleLocationsBeginInfoEXT(resourceTracker, reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            transform_VkPipelineSampleLocationsStateCreateInfoEXT(resourceTracker, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceSampleLocationsPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            transform_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            transform_VkPipelineColorBlendAdvancedStateCreateInfoEXT(resourceTracker, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            transform_VkPipelineCoverageToColorStateCreateInfoNV(resourceTracker, reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            transform_VkPipelineCoverageModulationStateCreateInfoNV(resourceTracker, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            transform_VkShaderModuleValidationCacheCreateInfoEXT(resourceTracker, reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            transform_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(resourceTracker, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            transform_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            transform_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(resourceTracker, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            transform_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(resourceTracker, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            transform_VkDeviceQueueGlobalPriorityCreateInfoEXT(resourceTracker, reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            transform_VkImportMemoryHostPointerInfoEXT(resourceTracker, reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            transform_VkPhysicalDeviceShaderCorePropertiesAMD(resourceTracker, reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            transform_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(resourceTracker, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            transform_VkPipelineVertexInputDivisorStateCreateInfoEXT(resourceTracker, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            transform_VkQueueFamilyCheckpointPropertiesNV(resourceTracker, reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out));
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}


} // namespace goldfish_vk
