// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkEncoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkEncoder.h"


#include "IOStream.h"
#include "Resources.h"
#include "ResourceTracker.h"
#include "Validation.h"
#include "VulkanStream.h"

#include "android/base/AlignedBuf.h"
#include "android/base/Pool.h"

#include "goldfish_vk_marshaling_guest.h"
#include "goldfish_vk_deepcopy_guest.h"
#include "goldfish_vk_handlemap_guest.h"
#include "goldfish_vk_private_defs.h"
#include "goldfish_vk_transform.h"


namespace goldfish_vk {



using namespace goldfish_vk;

using android::aligned_buf_alloc;
using android::aligned_buf_free;
using android::base::Pool;

class VkEncoder::Impl {
public:
    Impl(IOStream* stream) : m_stream(stream) { }
    VulkanCountingStream* countingStream() { return &m_countingStream; }
    VulkanStream* stream() { return &m_stream; }
    Pool* pool() { return &m_pool; }
    ResourceTracker* resources() { return ResourceTracker::get(); }
    Validation* validation() { return &m_validation; }
private:
    VulkanCountingStream m_countingStream;
    VulkanStream m_stream;
    Pool m_pool { 8, 4096, 64 };

    Validation m_validation;
};

VkEncoder::VkEncoder(IOStream *stream) :
    mImpl(new VkEncoder::Impl(stream)) { }

#define VALIDATE_RET(retType, success, validate) \
    retType goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != success) return goldfish_vk_validateResult; \

#define VALIDATE_VOID(validate) \
    VkResult goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != VK_SUCCESS) return; \

#ifdef VK_VERSION_1_0
VkResult VkEncoder::vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstanceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkInstanceCreateInfo*)pool->alloc(sizeof(const VkInstanceCreateInfo));
        deepcopy_VkInstanceCreateInfo(pool, pCreateInfo, (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkInstanceCreateInfo(mImpl->resources(), (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        marshal_VkInstanceCreateInfo(countingStream, (VkInstanceCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_0);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(pInstance, &cgen_var_1, 1);
        countingStream->write((uint64_t*)&cgen_var_1, 8);
    }
    uint32_t packetSize_vkCreateInstance = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateInstance = OP_vkCreateInstance;
    stream->write(&opcode_vkCreateInstance, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateInstance, sizeof(uint32_t));
    marshal_VkInstanceCreateInfo(stream, (VkInstanceCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_2);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->handleMapping()->mapHandles_VkInstance_u64(pInstance, &cgen_var_3, 1);
    stream->write((uint64_t*)&cgen_var_3, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_4;
    stream->read((uint64_t*)&cgen_var_4, 8);
    stream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_4, (VkInstance*)pInstance, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    stream->read(&vkCreateInstance_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateInstance_VkResult_return;
}

void VkEncoder::vkDestroyInstance(
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_5;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_5, 1);
        countingStream->write((uint64_t*)&cgen_var_5, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_6 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_6);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyInstance = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyInstance = OP_vkDestroyInstance;
    stream->write(&opcode_vkDestroyInstance, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyInstance, sizeof(uint32_t));
    uint64_t cgen_var_7;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_7, 1);
    stream->write((uint64_t*)&cgen_var_7, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_8 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_8);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkInstance((VkInstance*)&instance);
}

VkResult VkEncoder::vkEnumeratePhysicalDevices(
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    local_instance = instance;
    countingStream->rewind();
    {
        uint64_t cgen_var_9;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_9, 1);
        countingStream->write((uint64_t*)&cgen_var_9, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
        countingStream->putBe64(cgen_var_10);
        if (pPhysicalDeviceCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_11 = (uint64_t)(uintptr_t)pPhysicalDevices;
        countingStream->putBe64(cgen_var_11);
        if (pPhysicalDevices)
        {
            if ((*(pPhysicalDeviceCount)))
            {
                uint64_t* cgen_var_12;
                countingStream->alloc((void**)&cgen_var_12, (*(pPhysicalDeviceCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(pPhysicalDevices, cgen_var_12, (*(pPhysicalDeviceCount)));
                countingStream->write((uint64_t*)cgen_var_12, (*(pPhysicalDeviceCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDevices = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDevices = OP_vkEnumeratePhysicalDevices;
    stream->write(&opcode_vkEnumeratePhysicalDevices, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDevices, sizeof(uint32_t));
    uint64_t cgen_var_13;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_13, 1);
    stream->write((uint64_t*)&cgen_var_13, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_14 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
    stream->putBe64(cgen_var_14);
    if (pPhysicalDeviceCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_15 = (uint64_t)(uintptr_t)pPhysicalDevices;
    stream->putBe64(cgen_var_15);
    if (pPhysicalDevices)
    {
        if ((*(pPhysicalDeviceCount)))
        {
            uint64_t* cgen_var_16;
            stream->alloc((void**)&cgen_var_16, (*(pPhysicalDeviceCount)) * 8);
            stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(pPhysicalDevices, cgen_var_16, (*(pPhysicalDeviceCount)));
            stream->write((uint64_t*)cgen_var_16, (*(pPhysicalDeviceCount)) * 8);
        }
    }
    stream->setHandleMapping(resources->unwrapMapping());
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceCount;
    check_pPhysicalDeviceCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceCount)
    {
        if (!(check_pPhysicalDeviceCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->setHandleMapping(resources->createMapping());
    // WARNING PTR CHECK
    VkPhysicalDevice* check_pPhysicalDevices;
    check_pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)stream->getBe64();
    if (pPhysicalDevices)
    {
        if (!(check_pPhysicalDevices))
        {
            fprintf(stderr, "fatal: pPhysicalDevices inconsistent between guest and host\n");
        }
        if ((*(pPhysicalDeviceCount)))
        {
            uint64_t* cgen_var_19;
            stream->alloc((void**)&cgen_var_19, (*(pPhysicalDeviceCount)) * 8);
            stream->read((uint64_t*)cgen_var_19, (*(pPhysicalDeviceCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_19, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
        }
    }
    stream->unsetHandleMapping();
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEnumeratePhysicalDevices_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_20;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_20, 1);
        countingStream->write((uint64_t*)&cgen_var_20, 1 * 8);
        marshal_VkPhysicalDeviceFeatures(countingStream, (VkPhysicalDeviceFeatures*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures = OP_vkGetPhysicalDeviceFeatures;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures, sizeof(uint32_t));
    uint64_t cgen_var_21;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_21, 1);
    stream->write((uint64_t*)&cgen_var_21, 1 * 8);
    marshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
    unmarshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures(mImpl->resources(), (VkPhysicalDeviceFeatures*)(pFeatures));
    }
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    countingStream->rewind();
    {
        uint64_t cgen_var_22;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_22, 1);
        countingStream->write((uint64_t*)&cgen_var_22, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        marshal_VkFormatProperties(countingStream, (VkFormatProperties*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties = OP_vkGetPhysicalDeviceFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t));
    uint64_t cgen_var_23;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_23, 1);
    stream->write((uint64_t*)&cgen_var_23, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    marshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
    unmarshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties(mImpl->resources(), (VkFormatProperties*)(pFormatProperties));
    }
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_24;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_24, 1);
        countingStream->write((uint64_t*)&cgen_var_24, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&local_type, sizeof(VkImageType));
        countingStream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
        countingStream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
        marshal_VkImageFormatProperties(countingStream, (VkImageFormatProperties*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties = OP_vkGetPhysicalDeviceImageFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t));
    uint64_t cgen_var_25;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_25, 1);
    stream->write((uint64_t*)&cgen_var_25, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageType*)&local_type, sizeof(VkImageType));
    stream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    stream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    marshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    unmarshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties(mImpl->resources(), (VkImageFormatProperties*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_26;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_26, 1);
        countingStream->write((uint64_t*)&cgen_var_26, 1 * 8);
        marshal_VkPhysicalDeviceProperties(countingStream, (VkPhysicalDeviceProperties*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties = OP_vkGetPhysicalDeviceProperties;
    stream->write(&opcode_vkGetPhysicalDeviceProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties, sizeof(uint32_t));
    uint64_t cgen_var_27;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_27, 1);
    stream->write((uint64_t*)&cgen_var_27, 1 * 8);
    marshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
    unmarshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties(mImpl->resources(), (VkPhysicalDeviceProperties*)(pProperties));
    }
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_28;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_28, 1);
        countingStream->write((uint64_t*)&cgen_var_28, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_29 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
        countingStream->putBe64(cgen_var_29);
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_30 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
        countingStream->putBe64(cgen_var_30);
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties(countingStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties = OP_vkGetPhysicalDeviceQueueFamilyProperties;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t));
    uint64_t cgen_var_31;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_31, 1);
    stream->write((uint64_t*)&cgen_var_31, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_32 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    stream->putBe64(cgen_var_32);
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_33 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    stream->putBe64(cgen_var_33);
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties(mImpl->resources(), (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_36;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_36, 1);
        countingStream->write((uint64_t*)&cgen_var_36, 1 * 8);
        marshal_VkPhysicalDeviceMemoryProperties(countingStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties = OP_vkGetPhysicalDeviceMemoryProperties;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t));
    uint64_t cgen_var_37;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_37, 1);
    stream->write((uint64_t*)&cgen_var_37, 1 * 8);
    marshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    unmarshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties(mImpl->resources(), (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    mImpl->resources()->on_vkGetPhysicalDeviceMemoryProperties(this, physicalDevice, pMemoryProperties);
}

PFN_vkVoidFunction VkEncoder::vkGetInstanceProcAddr(
    VkInstance instance,
    const char* pName)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    char* local_pName;
    local_instance = instance;
    local_pName = nullptr;
    if (pName)
    {
        local_pName = pool->strDup(pName);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_38;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_38, 1);
        countingStream->write((uint64_t*)&cgen_var_38, 1 * 8);
        countingStream->putString(local_pName);
    }
    uint32_t packetSize_vkGetInstanceProcAddr = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetInstanceProcAddr = OP_vkGetInstanceProcAddr;
    stream->write(&opcode_vkGetInstanceProcAddr, sizeof(uint32_t));
    stream->write(&packetSize_vkGetInstanceProcAddr, sizeof(uint32_t));
    uint64_t cgen_var_39;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_39, 1);
    stream->write((uint64_t*)&cgen_var_39, 1 * 8);
    stream->putString(local_pName);
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction VkEncoder::vkGetDeviceProcAddr(
    VkDevice device,
    const char* pName)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    char* local_pName;
    local_device = device;
    local_pName = nullptr;
    if (pName)
    {
        local_pName = pool->strDup(pName);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_40;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_40, 1);
        countingStream->write((uint64_t*)&cgen_var_40, 1 * 8);
        countingStream->putString(local_pName);
    }
    uint32_t packetSize_vkGetDeviceProcAddr = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceProcAddr = OP_vkGetDeviceProcAddr;
    stream->write(&opcode_vkGetDeviceProcAddr, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceProcAddr, sizeof(uint32_t));
    uint64_t cgen_var_41;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_41, 1);
    stream->write((uint64_t*)&cgen_var_41, 1 * 8);
    stream->putString(local_pName);
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

VkResult VkEncoder::vkCreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDeviceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDeviceCreateInfo*)pool->alloc(sizeof(const VkDeviceCreateInfo));
        deepcopy_VkDeviceCreateInfo(pool, pCreateInfo, (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDeviceCreateInfo(mImpl->resources(), (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_42;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_42, 1);
        countingStream->write((uint64_t*)&cgen_var_42, 1 * 8);
        marshal_VkDeviceCreateInfo(countingStream, (VkDeviceCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_43 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_43);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_44;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(pDevice, &cgen_var_44, 1);
        countingStream->write((uint64_t*)&cgen_var_44, 8);
    }
    uint32_t packetSize_vkCreateDevice = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDevice = OP_vkCreateDevice;
    stream->write(&opcode_vkCreateDevice, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDevice, sizeof(uint32_t));
    uint64_t cgen_var_45;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_45, 1);
    stream->write((uint64_t*)&cgen_var_45, 1 * 8);
    marshal_VkDeviceCreateInfo(stream, (VkDeviceCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_46 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_46);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_47;
    stream->handleMapping()->mapHandles_VkDevice_u64(pDevice, &cgen_var_47, 1);
    stream->write((uint64_t*)&cgen_var_47, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_48;
    stream->read((uint64_t*)&cgen_var_48, 8);
    stream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_48, (VkDevice*)pDevice, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDevice_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->resources()->on_vkCreateDevice(this, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
    return vkCreateDevice_VkResult_return;
}

void VkEncoder::vkDestroyDevice(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator)
{
    mImpl->resources()->on_vkDestroyDevice_pre(this, device, pAllocator);
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_49;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_49, 1);
        countingStream->write((uint64_t*)&cgen_var_49, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_50 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_50);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDevice = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDevice = OP_vkDestroyDevice;
    stream->write(&opcode_vkDestroyDevice, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDevice, sizeof(uint32_t));
    uint64_t cgen_var_51;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_51, 1);
    stream->write((uint64_t*)&cgen_var_51, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_52 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_52);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDevice((VkDevice*)&device);
    stream->flush();
}

VkResult VkEncoder::vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    char* local_pLayerName;
    local_pLayerName = nullptr;
    if (pLayerName)
    {
        local_pLayerName = pool->strDup(pLayerName);
    }
    countingStream->rewind();
    {
        countingStream->putString(local_pLayerName);
        // WARNING PTR CHECK
        uint64_t cgen_var_53 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_53);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_54 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_54);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkExtensionProperties(countingStream, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceExtensionProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceExtensionProperties = OP_vkEnumerateInstanceExtensionProperties;
    stream->write(&opcode_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t));
    stream->putString(local_pLayerName);
    // WARNING PTR CHECK
    uint64_t cgen_var_55 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_55);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_56 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_56);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkExtensionProperties(mImpl->resources(), (VkExtensionProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    vkEnumerateDeviceExtensionProperties_VkResult_return = mImpl->resources()->on_vkEnumerateDeviceExtensionProperties(this, VK_SUCCESS, physicalDevice, pLayerName, pPropertyCount, pProperties);
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    countingStream->rewind();
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_59 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_59);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_60 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_60);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkLayerProperties(countingStream, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceLayerProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceLayerProperties = OP_vkEnumerateInstanceLayerProperties;
    stream->write(&opcode_vkEnumerateInstanceLayerProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceLayerProperties, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_61 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_61);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_62 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_62);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkLayerProperties(mImpl->resources(), (VkLayerProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_65;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_65, 1);
        countingStream->write((uint64_t*)&cgen_var_65, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_66 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_66);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_67 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_67);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkLayerProperties(countingStream, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceLayerProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateDeviceLayerProperties = OP_vkEnumerateDeviceLayerProperties;
    stream->write(&opcode_vkEnumerateDeviceLayerProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateDeviceLayerProperties, sizeof(uint32_t));
    uint64_t cgen_var_68;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_68, 1);
    stream->write((uint64_t*)&cgen_var_68, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_69 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_69);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_70 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_70);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkLayerProperties(mImpl->resources(), (VkLayerProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}

void VkEncoder::vkGetDeviceQueue(
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_queueFamilyIndex;
    uint32_t local_queueIndex;
    local_device = device;
    local_queueFamilyIndex = queueFamilyIndex;
    local_queueIndex = queueIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_73;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_73, 1);
        countingStream->write((uint64_t*)&cgen_var_73, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queueIndex, sizeof(uint32_t));
        uint64_t cgen_var_74;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_74, 1);
        countingStream->write((uint64_t*)&cgen_var_74, 8);
    }
    uint32_t packetSize_vkGetDeviceQueue = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceQueue = OP_vkGetDeviceQueue;
    stream->write(&opcode_vkGetDeviceQueue, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceQueue, sizeof(uint32_t));
    uint64_t cgen_var_75;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_75, 1);
    stream->write((uint64_t*)&cgen_var_75, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queueIndex, sizeof(uint32_t));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_76;
    stream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_76, 1);
    stream->write((uint64_t*)&cgen_var_76, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_77;
    stream->read((uint64_t*)&cgen_var_77, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_77, (VkQueue*)pQueue, 1);
    stream->unsetHandleMapping();
}

VkResult VkEncoder::vkQueueSubmit(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    uint32_t local_submitCount;
    VkSubmitInfo* local_pSubmits;
    VkFence local_fence;
    local_queue = queue;
    local_submitCount = submitCount;
    local_pSubmits = nullptr;
    if (pSubmits)
    {
        local_pSubmits = (VkSubmitInfo*)pool->alloc(((submitCount)) * sizeof(const VkSubmitInfo));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            deepcopy_VkSubmitInfo(pool, pSubmits + i, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    local_fence = fence;
    if (local_pSubmits)
    {
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            transform_tohost_VkSubmitInfo(mImpl->resources(), (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_78;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_78, 1);
        countingStream->write((uint64_t*)&cgen_var_78, 1 * 8);
        countingStream->write((uint32_t*)&local_submitCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            marshal_VkSubmitInfo(countingStream, (VkSubmitInfo*)(local_pSubmits + i));
        }
        uint64_t cgen_var_79;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_79, 1);
        countingStream->write((uint64_t*)&cgen_var_79, 1 * 8);
    }
    uint32_t packetSize_vkQueueSubmit = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueSubmit = OP_vkQueueSubmit;
    stream->write(&opcode_vkQueueSubmit, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueSubmit, sizeof(uint32_t));
    uint64_t cgen_var_80;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_80, 1);
    stream->write((uint64_t*)&cgen_var_80, 1 * 8);
    stream->write((uint32_t*)&local_submitCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        marshal_VkSubmitInfo(stream, (VkSubmitInfo*)(local_pSubmits + i));
    }
    uint64_t cgen_var_81;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_81, 1);
    stream->write((uint64_t*)&cgen_var_81, 1 * 8);
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkQueueSubmit_VkResult_return;
}

VkResult VkEncoder::vkQueueWaitIdle(
    VkQueue queue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    local_queue = queue;
    countingStream->rewind();
    {
        uint64_t cgen_var_82;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_82, 1);
        countingStream->write((uint64_t*)&cgen_var_82, 1 * 8);
    }
    uint32_t packetSize_vkQueueWaitIdle = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueWaitIdle = OP_vkQueueWaitIdle;
    stream->write(&opcode_vkQueueWaitIdle, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueWaitIdle, sizeof(uint32_t));
    uint64_t cgen_var_83;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_83, 1);
    stream->write((uint64_t*)&cgen_var_83, 1 * 8);
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkQueueWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkDeviceWaitIdle(
    VkDevice device)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    local_device = device;
    countingStream->rewind();
    {
        uint64_t cgen_var_84;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_84, 1);
        countingStream->write((uint64_t*)&cgen_var_84, 1 * 8);
    }
    uint32_t packetSize_vkDeviceWaitIdle = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDeviceWaitIdle = OP_vkDeviceWaitIdle;
    stream->write(&opcode_vkDeviceWaitIdle, sizeof(uint32_t));
    stream->write(&packetSize_vkDeviceWaitIdle, sizeof(uint32_t));
    uint64_t cgen_var_85;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_85, 1);
    stream->write((uint64_t*)&cgen_var_85, 1 * 8);
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkDeviceWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkAllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryAllocateInfo* local_pAllocateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkMemoryAllocateInfo*)pool->alloc(sizeof(const VkMemoryAllocateInfo));
        deepcopy_VkMemoryAllocateInfo(pool, pAllocateInfo, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocateInfo)
    {
        transform_tohost_VkMemoryAllocateInfo(mImpl->resources(), (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_86;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_86, 1);
        countingStream->write((uint64_t*)&cgen_var_86, 1 * 8);
        marshal_VkMemoryAllocateInfo(countingStream, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_87 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_87);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_88;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(pMemory, &cgen_var_88, 1);
        countingStream->write((uint64_t*)&cgen_var_88, 8);
    }
    uint32_t packetSize_vkAllocateMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateMemory = OP_vkAllocateMemory;
    stream->write(&opcode_vkAllocateMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateMemory, sizeof(uint32_t));
    uint64_t cgen_var_89;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_89, 1);
    stream->write((uint64_t*)&cgen_var_89, 1 * 8);
    marshal_VkMemoryAllocateInfo(stream, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_90 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_90);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_91;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(pMemory, &cgen_var_91, 1);
    stream->write((uint64_t*)&cgen_var_91, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_92;
    stream->read((uint64_t*)&cgen_var_92, 8);
    stream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_92, (VkDeviceMemory*)pMemory, 1);
    stream->unsetHandleMapping();
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAllocateMemory_VkResult_return;
}

void VkEncoder::vkFreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    mImpl->resources()->deviceMemoryTransform_tohost(&local_memory, 1, nullptr, 0, nullptr, 0, nullptr, 0, nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_93;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_93, 1);
        countingStream->write((uint64_t*)&cgen_var_93, 1 * 8);
        uint64_t cgen_var_94;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_94, 1);
        countingStream->write((uint64_t*)&cgen_var_94, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_95 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_95);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkFreeMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeMemory = OP_vkFreeMemory;
    stream->write(&opcode_vkFreeMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeMemory, sizeof(uint32_t));
    uint64_t cgen_var_96;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_96, 1);
    stream->write((uint64_t*)&cgen_var_96, 1 * 8);
    uint64_t cgen_var_97;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_97, 1);
    stream->write((uint64_t*)&cgen_var_97, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_98 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_98);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
}

VkResult VkEncoder::vkMapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData)
{
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    vkMapMemory_VkResult_return = mImpl->resources()->on_vkMapMemory(this, VK_SUCCESS, device, memory, offset, size, flags, ppData);
    return vkMapMemory_VkResult_return;
}

void VkEncoder::vkUnmapMemory(
    VkDevice device,
    VkDeviceMemory memory)
{
    mImpl->resources()->on_vkUnmapMemory(this, device, memory);
}

VkResult VkEncoder::vkFlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkFlushMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(mImpl->resources(), (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_99;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_99, 1);
        countingStream->write((uint64_t*)&cgen_var_99, 1 * 8);
        countingStream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            marshal_VkMappedMemoryRange(countingStream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (!resources->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { countingStream->write(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = resources->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? resources->getMappedSize(memory) : size;
            if (!hostPtr) { countingStream->write(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            countingStream->write(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            countingStream->write(targetRange, actualSize);
        }
    }
    uint32_t packetSize_vkFlushMappedMemoryRanges = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFlushMappedMemoryRanges = OP_vkFlushMappedMemoryRanges;
    stream->write(&opcode_vkFlushMappedMemoryRanges, sizeof(uint32_t));
    stream->write(&packetSize_vkFlushMappedMemoryRanges, sizeof(uint32_t));
    uint64_t cgen_var_100;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_100, 1);
    stream->write((uint64_t*)&cgen_var_100, 1 * 8);
    stream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(stream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
    }
    if (!resources->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = resources->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? resources->getMappedSize(memory) : size;
            if (!hostPtr) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->write(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->write(targetRange, actualSize);
        }
    }
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult VkEncoder::vkInvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkInvalidateMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(mImpl->resources(), (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_101;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_101, 1);
        countingStream->write((uint64_t*)&cgen_var_101, 1 * 8);
        countingStream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            marshal_VkMappedMemoryRange(countingStream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    uint32_t packetSize_vkInvalidateMappedMemoryRanges = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkInvalidateMappedMemoryRanges = OP_vkInvalidateMappedMemoryRanges;
    stream->write(&opcode_vkInvalidateMappedMemoryRanges, sizeof(uint32_t));
    stream->write(&packetSize_vkInvalidateMappedMemoryRanges, sizeof(uint32_t));
    uint64_t cgen_var_102;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_102, 1);
    stream->write((uint64_t*)&cgen_var_102, 1 * 8);
    stream->write((uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(stream, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
    }
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    if (!resources->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = resources->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? resources->getMappedSize(memory) : size;
            if (!hostPtr) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->read(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->read(targetRange, actualSize);
        }
    }
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}

void VkEncoder::vkGetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    mImpl->resources()->deviceMemoryTransform_tohost(&local_memory, 1, nullptr, 0, nullptr, 0, nullptr, 0, nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_103;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_103, 1);
        countingStream->write((uint64_t*)&cgen_var_103, 1 * 8);
        uint64_t cgen_var_104;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_104, 1);
        countingStream->write((uint64_t*)&cgen_var_104, 1 * 8);
        countingStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkGetDeviceMemoryCommitment = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceMemoryCommitment = OP_vkGetDeviceMemoryCommitment;
    stream->write(&opcode_vkGetDeviceMemoryCommitment, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceMemoryCommitment, sizeof(uint32_t));
    uint64_t cgen_var_105;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_105, 1);
    stream->write((uint64_t*)&cgen_var_105, 1 * 8);
    uint64_t cgen_var_106;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_106, 1);
    stream->write((uint64_t*)&cgen_var_106, 1 * 8);
    stream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    stream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
}

VkResult VkEncoder::vkBindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_buffer = buffer;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    mImpl->resources()->deviceMemoryTransform_tohost(&local_memory, 1, &local_memoryOffset, 1, nullptr, 0, nullptr, 0, nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_107;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_107, 1);
        countingStream->write((uint64_t*)&cgen_var_107, 1 * 8);
        uint64_t cgen_var_108;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_108, 1);
        countingStream->write((uint64_t*)&cgen_var_108, 1 * 8);
        uint64_t cgen_var_109;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_109, 1);
        countingStream->write((uint64_t*)&cgen_var_109, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkBindBufferMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory = OP_vkBindBufferMemory;
    stream->write(&opcode_vkBindBufferMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory, sizeof(uint32_t));
    uint64_t cgen_var_110;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_110, 1);
    stream->write((uint64_t*)&cgen_var_110, 1 * 8);
    uint64_t cgen_var_111;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_111, 1);
    stream->write((uint64_t*)&cgen_var_111, 1 * 8);
    uint64_t cgen_var_112;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_112, 1);
    stream->write((uint64_t*)&cgen_var_112, 1 * 8);
    stream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBindBufferMemory_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_image = image;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    mImpl->resources()->deviceMemoryTransform_tohost(&local_memory, 1, &local_memoryOffset, 1, nullptr, 0, nullptr, 0, nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_113;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_113, 1);
        countingStream->write((uint64_t*)&cgen_var_113, 1 * 8);
        uint64_t cgen_var_114;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_114, 1);
        countingStream->write((uint64_t*)&cgen_var_114, 1 * 8);
        uint64_t cgen_var_115;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_115, 1);
        countingStream->write((uint64_t*)&cgen_var_115, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkBindImageMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory = OP_vkBindImageMemory;
    stream->write(&opcode_vkBindImageMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory, sizeof(uint32_t));
    uint64_t cgen_var_116;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_116, 1);
    stream->write((uint64_t*)&cgen_var_116, 1 * 8);
    uint64_t cgen_var_117;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_117, 1);
    stream->write((uint64_t*)&cgen_var_117, 1 * 8);
    uint64_t cgen_var_118;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_118, 1);
    stream->write((uint64_t*)&cgen_var_118, 1 * 8);
    stream->write((VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBindImageMemory_VkResult_return;
}

void VkEncoder::vkGetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    local_device = device;
    local_buffer = buffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_119;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_119, 1);
        countingStream->write((uint64_t*)&cgen_var_119, 1 * 8);
        uint64_t cgen_var_120;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_120, 1);
        countingStream->write((uint64_t*)&cgen_var_120, 1 * 8);
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements = OP_vkGetBufferMemoryRequirements;
    stream->write(&opcode_vkGetBufferMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements, sizeof(uint32_t));
    uint64_t cgen_var_121;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_121, 1);
    stream->write((uint64_t*)&cgen_var_121, 1 * 8);
    uint64_t cgen_var_122;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_122, 1);
    stream->write((uint64_t*)&cgen_var_122, 1 * 8);
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(mImpl->resources(), (VkMemoryRequirements*)(pMemoryRequirements));
    }
}

void VkEncoder::vkGetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    countingStream->rewind();
    {
        uint64_t cgen_var_123;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_123, 1);
        countingStream->write((uint64_t*)&cgen_var_123, 1 * 8);
        uint64_t cgen_var_124;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_124, 1);
        countingStream->write((uint64_t*)&cgen_var_124, 1 * 8);
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements = OP_vkGetImageMemoryRequirements;
    stream->write(&opcode_vkGetImageMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements, sizeof(uint32_t));
    uint64_t cgen_var_125;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_125, 1);
    stream->write((uint64_t*)&cgen_var_125, 1 * 8);
    uint64_t cgen_var_126;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_126, 1);
    stream->write((uint64_t*)&cgen_var_126, 1 * 8);
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(mImpl->resources(), (VkMemoryRequirements*)(pMemoryRequirements));
    }
}

void VkEncoder::vkGetImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    countingStream->rewind();
    {
        uint64_t cgen_var_127;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_127, 1);
        countingStream->write((uint64_t*)&cgen_var_127, 1 * 8);
        uint64_t cgen_var_128;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_128, 1);
        countingStream->write((uint64_t*)&cgen_var_128, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_129 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
        countingStream->putBe64(cgen_var_129);
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_130 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
        countingStream->putBe64(cgen_var_130);
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements(countingStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements = OP_vkGetImageSparseMemoryRequirements;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements, sizeof(uint32_t));
    uint64_t cgen_var_131;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_131, 1);
    stream->write((uint64_t*)&cgen_var_131, 1 * 8);
    uint64_t cgen_var_132;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_132, 1);
    stream->write((uint64_t*)&cgen_var_132, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_133 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    stream->putBe64(cgen_var_133);
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_134 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    stream->putBe64(cgen_var_134);
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements(mImpl->resources(), (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkSampleCountFlagBits local_samples;
    VkImageUsageFlags local_usage;
    VkImageTiling local_tiling;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_samples = samples;
    local_usage = usage;
    local_tiling = tiling;
    countingStream->rewind();
    {
        uint64_t cgen_var_137;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_137, 1);
        countingStream->write((uint64_t*)&cgen_var_137, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&local_type, sizeof(VkImageType));
        countingStream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
        countingStream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
        // WARNING PTR CHECK
        uint64_t cgen_var_138 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_138);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_139 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_139);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties(countingStream, (VkSparseImageFormatProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties = OP_vkGetPhysicalDeviceSparseImageFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t));
    uint64_t cgen_var_140;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_140, 1);
    stream->write((uint64_t*)&cgen_var_140, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageType*)&local_type, sizeof(VkImageType));
    stream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    stream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    // WARNING PTR CHECK
    uint64_t cgen_var_141 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_141);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_142 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_142);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties(mImpl->resources(), (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
}

VkResult VkEncoder::vkQueueBindSparse(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    uint32_t local_bindInfoCount;
    VkBindSparseInfo* local_pBindInfo;
    VkFence local_fence;
    local_queue = queue;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfo = nullptr;
    if (pBindInfo)
    {
        local_pBindInfo = (VkBindSparseInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindSparseInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindSparseInfo(pool, pBindInfo + i, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    local_fence = fence;
    if (local_pBindInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindSparseInfo(mImpl->resources(), (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_145;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_145, 1);
        countingStream->write((uint64_t*)&cgen_var_145, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindSparseInfo(countingStream, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
        uint64_t cgen_var_146;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_146, 1);
        countingStream->write((uint64_t*)&cgen_var_146, 1 * 8);
    }
    uint32_t packetSize_vkQueueBindSparse = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueBindSparse = OP_vkQueueBindSparse;
    stream->write(&opcode_vkQueueBindSparse, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueBindSparse, sizeof(uint32_t));
    uint64_t cgen_var_147;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_147, 1);
    stream->write((uint64_t*)&cgen_var_147, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindSparseInfo(stream, (VkBindSparseInfo*)(local_pBindInfo + i));
    }
    uint64_t cgen_var_148;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_148, 1);
    stream->write((uint64_t*)&cgen_var_148, 1 * 8);
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    stream->read(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkQueueBindSparse_VkResult_return;
}

VkResult VkEncoder::vkCreateFence(
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFenceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFenceCreateInfo*)pool->alloc(sizeof(const VkFenceCreateInfo));
        deepcopy_VkFenceCreateInfo(pool, pCreateInfo, (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFenceCreateInfo(mImpl->resources(), (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_149;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_149, 1);
        countingStream->write((uint64_t*)&cgen_var_149, 1 * 8);
        marshal_VkFenceCreateInfo(countingStream, (VkFenceCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_150 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_150);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_151;
        countingStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_151, 1);
        countingStream->write((uint64_t*)&cgen_var_151, 8);
    }
    uint32_t packetSize_vkCreateFence = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateFence = OP_vkCreateFence;
    stream->write(&opcode_vkCreateFence, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateFence, sizeof(uint32_t));
    uint64_t cgen_var_152;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_152, 1);
    stream->write((uint64_t*)&cgen_var_152, 1 * 8);
    marshal_VkFenceCreateInfo(stream, (VkFenceCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_153 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_153);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_154;
    stream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_154, 1);
    stream->write((uint64_t*)&cgen_var_154, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_155;
    stream->read((uint64_t*)&cgen_var_155, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_155, (VkFence*)pFence, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFence_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateFence_VkResult_return;
}

void VkEncoder::vkDestroyFence(
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFence local_fence;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_fence = fence;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_156;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_156, 1);
        countingStream->write((uint64_t*)&cgen_var_156, 1 * 8);
        uint64_t cgen_var_157;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_157, 1);
        countingStream->write((uint64_t*)&cgen_var_157, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_158 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_158);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyFence = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyFence = OP_vkDestroyFence;
    stream->write(&opcode_vkDestroyFence, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyFence, sizeof(uint32_t));
    uint64_t cgen_var_159;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_159, 1);
    stream->write((uint64_t*)&cgen_var_159, 1 * 8);
    uint64_t cgen_var_160;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_160, 1);
    stream->write((uint64_t*)&cgen_var_160, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_161 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_161);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkFence((VkFence*)&fence);
}

VkResult VkEncoder::vkResetFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    local_device = device;
    local_fenceCount = fenceCount;
    local_pFences = nullptr;
    if (pFences)
    {
        local_pFences = (VkFence*)pool->dupArray(pFences, ((fenceCount)) * sizeof(const VkFence));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_162;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_162, 1);
        countingStream->write((uint64_t*)&cgen_var_162, 1 * 8);
        countingStream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
        if (((fenceCount)))
        {
            uint64_t* cgen_var_163;
            countingStream->alloc((void**)&cgen_var_163, ((fenceCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_163, ((fenceCount)));
            countingStream->write((uint64_t*)cgen_var_163, ((fenceCount)) * 8);
        }
    }
    uint32_t packetSize_vkResetFences = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetFences = OP_vkResetFences;
    stream->write(&opcode_vkResetFences, sizeof(uint32_t));
    stream->write(&packetSize_vkResetFences, sizeof(uint32_t));
    uint64_t cgen_var_164;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_164, 1);
    stream->write((uint64_t*)&cgen_var_164, 1 * 8);
    stream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
    if (((fenceCount)))
    {
        uint64_t* cgen_var_165;
        stream->alloc((void**)&cgen_var_165, ((fenceCount)) * 8);
        stream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_165, ((fenceCount)));
        stream->write((uint64_t*)cgen_var_165, ((fenceCount)) * 8);
    }
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    stream->read(&vkResetFences_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkResetFences_VkResult_return;
}

VkResult VkEncoder::vkGetFenceStatus(
    VkDevice device,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFence local_fence;
    local_device = device;
    local_fence = fence;
    countingStream->rewind();
    {
        uint64_t cgen_var_166;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_166, 1);
        countingStream->write((uint64_t*)&cgen_var_166, 1 * 8);
        uint64_t cgen_var_167;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_167, 1);
        countingStream->write((uint64_t*)&cgen_var_167, 1 * 8);
    }
    uint32_t packetSize_vkGetFenceStatus = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceStatus = OP_vkGetFenceStatus;
    stream->write(&opcode_vkGetFenceStatus, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceStatus, sizeof(uint32_t));
    uint64_t cgen_var_168;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_168, 1);
    stream->write((uint64_t*)&cgen_var_168, 1 * 8);
    uint64_t cgen_var_169;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_169, 1);
    stream->write((uint64_t*)&cgen_var_169, 1 * 8);
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetFenceStatus_VkResult_return;
}

VkResult VkEncoder::vkWaitForFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    VkBool32 local_waitAll;
    uint64_t local_timeout;
    local_device = device;
    local_fenceCount = fenceCount;
    local_pFences = nullptr;
    if (pFences)
    {
        local_pFences = (VkFence*)pool->dupArray(pFences, ((fenceCount)) * sizeof(const VkFence));
    }
    local_waitAll = waitAll;
    local_timeout = timeout;
    countingStream->rewind();
    {
        uint64_t cgen_var_170;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_170, 1);
        countingStream->write((uint64_t*)&cgen_var_170, 1 * 8);
        countingStream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
        if (((fenceCount)))
        {
            uint64_t* cgen_var_171;
            countingStream->alloc((void**)&cgen_var_171, ((fenceCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_171, ((fenceCount)));
            countingStream->write((uint64_t*)cgen_var_171, ((fenceCount)) * 8);
        }
        countingStream->write((VkBool32*)&local_waitAll, sizeof(VkBool32));
        countingStream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
    }
    uint32_t packetSize_vkWaitForFences = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkWaitForFences = OP_vkWaitForFences;
    stream->write(&opcode_vkWaitForFences, sizeof(uint32_t));
    stream->write(&packetSize_vkWaitForFences, sizeof(uint32_t));
    uint64_t cgen_var_172;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_172, 1);
    stream->write((uint64_t*)&cgen_var_172, 1 * 8);
    stream->write((uint32_t*)&local_fenceCount, sizeof(uint32_t));
    if (((fenceCount)))
    {
        uint64_t* cgen_var_173;
        stream->alloc((void**)&cgen_var_173, ((fenceCount)) * 8);
        stream->handleMapping()->mapHandles_VkFence_u64(local_pFences, cgen_var_173, ((fenceCount)));
        stream->write((uint64_t*)cgen_var_173, ((fenceCount)) * 8);
    }
    stream->write((VkBool32*)&local_waitAll, sizeof(VkBool32));
    stream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    stream->read(&vkWaitForFences_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkWaitForFences_VkResult_return;
}

VkResult VkEncoder::vkCreateSemaphore(
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphoreCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSemaphoreCreateInfo*)pool->alloc(sizeof(const VkSemaphoreCreateInfo));
        deepcopy_VkSemaphoreCreateInfo(pool, pCreateInfo, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSemaphoreCreateInfo(mImpl->resources(), (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_174;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_174, 1);
        countingStream->write((uint64_t*)&cgen_var_174, 1 * 8);
        marshal_VkSemaphoreCreateInfo(countingStream, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_175 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_175);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_176;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(pSemaphore, &cgen_var_176, 1);
        countingStream->write((uint64_t*)&cgen_var_176, 8);
    }
    uint32_t packetSize_vkCreateSemaphore = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSemaphore = OP_vkCreateSemaphore;
    stream->write(&opcode_vkCreateSemaphore, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSemaphore, sizeof(uint32_t));
    uint64_t cgen_var_177;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_177, 1);
    stream->write((uint64_t*)&cgen_var_177, 1 * 8);
    marshal_VkSemaphoreCreateInfo(stream, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_178 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_178);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_179;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(pSemaphore, &cgen_var_179, 1);
    stream->write((uint64_t*)&cgen_var_179, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_180;
    stream->read((uint64_t*)&cgen_var_180, 8);
    stream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_180, (VkSemaphore*)pSemaphore, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateSemaphore_VkResult_return;
}

void VkEncoder::vkDestroySemaphore(
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphore local_semaphore;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_semaphore = semaphore;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_181;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_181, 1);
        countingStream->write((uint64_t*)&cgen_var_181, 1 * 8);
        uint64_t cgen_var_182;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_182, 1);
        countingStream->write((uint64_t*)&cgen_var_182, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_183 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_183);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySemaphore = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySemaphore = OP_vkDestroySemaphore;
    stream->write(&opcode_vkDestroySemaphore, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySemaphore, sizeof(uint32_t));
    uint64_t cgen_var_184;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_184, 1);
    stream->write((uint64_t*)&cgen_var_184, 1 * 8);
    uint64_t cgen_var_185;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_185, 1);
    stream->write((uint64_t*)&cgen_var_185, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_186 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_186);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkSemaphore((VkSemaphore*)&semaphore);
}

VkResult VkEncoder::vkCreateEvent(
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEventCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkEventCreateInfo*)pool->alloc(sizeof(const VkEventCreateInfo));
        deepcopy_VkEventCreateInfo(pool, pCreateInfo, (VkEventCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkEventCreateInfo(mImpl->resources(), (VkEventCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_187;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_187, 1);
        countingStream->write((uint64_t*)&cgen_var_187, 1 * 8);
        marshal_VkEventCreateInfo(countingStream, (VkEventCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_188 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_188);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_189;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(pEvent, &cgen_var_189, 1);
        countingStream->write((uint64_t*)&cgen_var_189, 8);
    }
    uint32_t packetSize_vkCreateEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateEvent = OP_vkCreateEvent;
    stream->write(&opcode_vkCreateEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateEvent, sizeof(uint32_t));
    uint64_t cgen_var_190;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_190, 1);
    stream->write((uint64_t*)&cgen_var_190, 1 * 8);
    marshal_VkEventCreateInfo(stream, (VkEventCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_191 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_191);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_192;
    stream->handleMapping()->mapHandles_VkEvent_u64(pEvent, &cgen_var_192, 1);
    stream->write((uint64_t*)&cgen_var_192, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_193;
    stream->read((uint64_t*)&cgen_var_193, 8);
    stream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_193, (VkEvent*)pEvent, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    stream->read(&vkCreateEvent_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateEvent_VkResult_return;
}

void VkEncoder::vkDestroyEvent(
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_event = event;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_194;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_194, 1);
        countingStream->write((uint64_t*)&cgen_var_194, 1 * 8);
        uint64_t cgen_var_195;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_195, 1);
        countingStream->write((uint64_t*)&cgen_var_195, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_196 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_196);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyEvent = OP_vkDestroyEvent;
    stream->write(&opcode_vkDestroyEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyEvent, sizeof(uint32_t));
    uint64_t cgen_var_197;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_197, 1);
    stream->write((uint64_t*)&cgen_var_197, 1 * 8);
    uint64_t cgen_var_198;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_198, 1);
    stream->write((uint64_t*)&cgen_var_198, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_199 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_199);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkEvent((VkEvent*)&event);
}

VkResult VkEncoder::vkGetEventStatus(
    VkDevice device,
    VkEvent event)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    countingStream->rewind();
    {
        uint64_t cgen_var_200;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_200, 1);
        countingStream->write((uint64_t*)&cgen_var_200, 1 * 8);
        uint64_t cgen_var_201;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_201, 1);
        countingStream->write((uint64_t*)&cgen_var_201, 1 * 8);
    }
    uint32_t packetSize_vkGetEventStatus = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetEventStatus = OP_vkGetEventStatus;
    stream->write(&opcode_vkGetEventStatus, sizeof(uint32_t));
    stream->write(&packetSize_vkGetEventStatus, sizeof(uint32_t));
    uint64_t cgen_var_202;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_202, 1);
    stream->write((uint64_t*)&cgen_var_202, 1 * 8);
    uint64_t cgen_var_203;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_203, 1);
    stream->write((uint64_t*)&cgen_var_203, 1 * 8);
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetEventStatus_VkResult_return;
}

VkResult VkEncoder::vkSetEvent(
    VkDevice device,
    VkEvent event)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    countingStream->rewind();
    {
        uint64_t cgen_var_204;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_204, 1);
        countingStream->write((uint64_t*)&cgen_var_204, 1 * 8);
        uint64_t cgen_var_205;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_205, 1);
        countingStream->write((uint64_t*)&cgen_var_205, 1 * 8);
    }
    uint32_t packetSize_vkSetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetEvent = OP_vkSetEvent;
    stream->write(&opcode_vkSetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkSetEvent, sizeof(uint32_t));
    uint64_t cgen_var_206;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_206, 1);
    stream->write((uint64_t*)&cgen_var_206, 1 * 8);
    uint64_t cgen_var_207;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_207, 1);
    stream->write((uint64_t*)&cgen_var_207, 1 * 8);
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkSetEvent_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkSetEvent_VkResult_return;
}

VkResult VkEncoder::vkResetEvent(
    VkDevice device,
    VkEvent event)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    countingStream->rewind();
    {
        uint64_t cgen_var_208;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_208, 1);
        countingStream->write((uint64_t*)&cgen_var_208, 1 * 8);
        uint64_t cgen_var_209;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_209, 1);
        countingStream->write((uint64_t*)&cgen_var_209, 1 * 8);
    }
    uint32_t packetSize_vkResetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetEvent = OP_vkResetEvent;
    stream->write(&opcode_vkResetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkResetEvent, sizeof(uint32_t));
    uint64_t cgen_var_210;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_210, 1);
    stream->write((uint64_t*)&cgen_var_210, 1 * 8);
    uint64_t cgen_var_211;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_211, 1);
    stream->write((uint64_t*)&cgen_var_211, 1 * 8);
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkResetEvent_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkResetEvent_VkResult_return;
}

VkResult VkEncoder::vkCreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkQueryPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkQueryPoolCreateInfo*)pool->alloc(sizeof(const VkQueryPoolCreateInfo));
        deepcopy_VkQueryPoolCreateInfo(pool, pCreateInfo, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkQueryPoolCreateInfo(mImpl->resources(), (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_212;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_212, 1);
        countingStream->write((uint64_t*)&cgen_var_212, 1 * 8);
        marshal_VkQueryPoolCreateInfo(countingStream, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_213 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_213);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_214;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(pQueryPool, &cgen_var_214, 1);
        countingStream->write((uint64_t*)&cgen_var_214, 8);
    }
    uint32_t packetSize_vkCreateQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateQueryPool = OP_vkCreateQueryPool;
    stream->write(&opcode_vkCreateQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateQueryPool, sizeof(uint32_t));
    uint64_t cgen_var_215;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_215, 1);
    stream->write((uint64_t*)&cgen_var_215, 1 * 8);
    marshal_VkQueryPoolCreateInfo(stream, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_216 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_216);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_217;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(pQueryPool, &cgen_var_217, 1);
    stream->write((uint64_t*)&cgen_var_217, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_218;
    stream->read((uint64_t*)&cgen_var_218, 8);
    stream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_218, (VkQueryPool*)pQueryPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateQueryPool_VkResult_return;
}

void VkEncoder::vkDestroyQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkQueryPool local_queryPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_queryPool = queryPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_219;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_219, 1);
        countingStream->write((uint64_t*)&cgen_var_219, 1 * 8);
        uint64_t cgen_var_220;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_220, 1);
        countingStream->write((uint64_t*)&cgen_var_220, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_221 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_221);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyQueryPool = OP_vkDestroyQueryPool;
    stream->write(&opcode_vkDestroyQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyQueryPool, sizeof(uint32_t));
    uint64_t cgen_var_222;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_222, 1);
    stream->write((uint64_t*)&cgen_var_222, 1 * 8);
    uint64_t cgen_var_223;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_223, 1);
    stream->write((uint64_t*)&cgen_var_223, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_224 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_224);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkQueryPool((VkQueryPool*)&queryPool);
}

VkResult VkEncoder::vkGetQueryPoolResults(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    size_t local_dataSize;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_device = device;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dataSize = dataSize;
    local_stride = stride;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_225;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_225, 1);
        countingStream->write((uint64_t*)&cgen_var_225, 1 * 8);
        uint64_t cgen_var_226;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_226, 1);
        countingStream->write((uint64_t*)&cgen_var_226, 1 * 8);
        countingStream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
        uint64_t cgen_var_227 = (uint64_t)local_dataSize;
        countingStream->putBe64(cgen_var_227);
        countingStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
        countingStream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
        countingStream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    }
    uint32_t packetSize_vkGetQueryPoolResults = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetQueryPoolResults = OP_vkGetQueryPoolResults;
    stream->write(&opcode_vkGetQueryPoolResults, sizeof(uint32_t));
    stream->write(&packetSize_vkGetQueryPoolResults, sizeof(uint32_t));
    uint64_t cgen_var_228;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_228, 1);
    stream->write((uint64_t*)&cgen_var_228, 1 * 8);
    uint64_t cgen_var_229;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_229, 1);
    stream->write((uint64_t*)&cgen_var_229, 1 * 8);
    stream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    uint64_t cgen_var_230 = (uint64_t)local_dataSize;
    stream->putBe64(cgen_var_230);
    stream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
    stream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    stream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    stream->read(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetQueryPoolResults_VkResult_return;
}

VkResult VkEncoder::vkCreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(mImpl->resources(), (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_231;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_231, 1);
        countingStream->write((uint64_t*)&cgen_var_231, 1 * 8);
        marshal_VkBufferCreateInfo(countingStream, (VkBufferCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_232 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_232);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_233;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_233, 1);
        countingStream->write((uint64_t*)&cgen_var_233, 8);
    }
    uint32_t packetSize_vkCreateBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBuffer = OP_vkCreateBuffer;
    stream->write(&opcode_vkCreateBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBuffer, sizeof(uint32_t));
    uint64_t cgen_var_234;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_234, 1);
    stream->write((uint64_t*)&cgen_var_234, 1 * 8);
    marshal_VkBufferCreateInfo(stream, (VkBufferCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_235 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_235);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_236;
    stream->handleMapping()->mapHandles_VkBuffer_u64(pBuffer, &cgen_var_236, 1);
    stream->write((uint64_t*)&cgen_var_236, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_237;
    stream->read((uint64_t*)&cgen_var_237, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_237, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateBuffer_VkResult_return;
}

void VkEncoder::vkDestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBuffer local_buffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_buffer = buffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_238;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_238, 1);
        countingStream->write((uint64_t*)&cgen_var_238, 1 * 8);
        uint64_t cgen_var_239;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_239, 1);
        countingStream->write((uint64_t*)&cgen_var_239, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_240 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_240);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyBuffer = OP_vkDestroyBuffer;
    stream->write(&opcode_vkDestroyBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyBuffer, sizeof(uint32_t));
    uint64_t cgen_var_241;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_241, 1);
    stream->write((uint64_t*)&cgen_var_241, 1 * 8);
    uint64_t cgen_var_242;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_242, 1);
    stream->write((uint64_t*)&cgen_var_242, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_243 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_243);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkBuffer((VkBuffer*)&buffer);
}

VkResult VkEncoder::vkCreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferViewCreateInfo*)pool->alloc(sizeof(const VkBufferViewCreateInfo));
        deepcopy_VkBufferViewCreateInfo(pool, pCreateInfo, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferViewCreateInfo(mImpl->resources(), (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_244;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_244, 1);
        countingStream->write((uint64_t*)&cgen_var_244, 1 * 8);
        marshal_VkBufferViewCreateInfo(countingStream, (VkBufferViewCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_245 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_245);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_246;
        countingStream->handleMapping()->mapHandles_VkBufferView_u64(pView, &cgen_var_246, 1);
        countingStream->write((uint64_t*)&cgen_var_246, 8);
    }
    uint32_t packetSize_vkCreateBufferView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBufferView = OP_vkCreateBufferView;
    stream->write(&opcode_vkCreateBufferView, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBufferView, sizeof(uint32_t));
    uint64_t cgen_var_247;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_247, 1);
    stream->write((uint64_t*)&cgen_var_247, 1 * 8);
    marshal_VkBufferViewCreateInfo(stream, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_248 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_248);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_249;
    stream->handleMapping()->mapHandles_VkBufferView_u64(pView, &cgen_var_249, 1);
    stream->write((uint64_t*)&cgen_var_249, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_250;
    stream->read((uint64_t*)&cgen_var_250, 8);
    stream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_250, (VkBufferView*)pView, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateBufferView_VkResult_return;
}

void VkEncoder::vkDestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferView local_bufferView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_bufferView = bufferView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_251;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_251, 1);
        countingStream->write((uint64_t*)&cgen_var_251, 1 * 8);
        uint64_t cgen_var_252;
        countingStream->handleMapping()->mapHandles_VkBufferView_u64(&local_bufferView, &cgen_var_252, 1);
        countingStream->write((uint64_t*)&cgen_var_252, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_253 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_253);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyBufferView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyBufferView = OP_vkDestroyBufferView;
    stream->write(&opcode_vkDestroyBufferView, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyBufferView, sizeof(uint32_t));
    uint64_t cgen_var_254;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_254, 1);
    stream->write((uint64_t*)&cgen_var_254, 1 * 8);
    uint64_t cgen_var_255;
    stream->handleMapping()->mapHandles_VkBufferView_u64(&local_bufferView, &cgen_var_255, 1);
    stream->write((uint64_t*)&cgen_var_255, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_256 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_256);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkBufferView((VkBufferView*)&bufferView);
}

VkResult VkEncoder::vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    mImpl->resources()->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(mImpl->resources(), (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_257;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_257, 1);
        countingStream->write((uint64_t*)&cgen_var_257, 1 * 8);
        marshal_VkImageCreateInfo(countingStream, (VkImageCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_258 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_258);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_259;
        countingStream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_259, 1);
        countingStream->write((uint64_t*)&cgen_var_259, 8);
    }
    uint32_t packetSize_vkCreateImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImage = OP_vkCreateImage;
    stream->write(&opcode_vkCreateImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImage, sizeof(uint32_t));
    uint64_t cgen_var_260;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_260, 1);
    stream->write((uint64_t*)&cgen_var_260, 1 * 8);
    marshal_VkImageCreateInfo(stream, (VkImageCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_261 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_261);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_262;
    stream->handleMapping()->mapHandles_VkImage_u64(pImage, &cgen_var_262, 1);
    stream->write((uint64_t*)&cgen_var_262, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_263;
    stream->read((uint64_t*)&cgen_var_263, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_263, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImage_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateImage_VkResult_return;
}

void VkEncoder::vkDestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_image = image;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_264;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_264, 1);
        countingStream->write((uint64_t*)&cgen_var_264, 1 * 8);
        uint64_t cgen_var_265;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_265, 1);
        countingStream->write((uint64_t*)&cgen_var_265, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_266 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_266);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyImage = OP_vkDestroyImage;
    stream->write(&opcode_vkDestroyImage, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyImage, sizeof(uint32_t));
    uint64_t cgen_var_267;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_267, 1);
    stream->write((uint64_t*)&cgen_var_267, 1 * 8);
    uint64_t cgen_var_268;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_268, 1);
    stream->write((uint64_t*)&cgen_var_268, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_269 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_269);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkImage((VkImage*)&image);
}

void VkEncoder::vkGetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    VkImageSubresource* local_pSubresource;
    local_device = device;
    local_image = image;
    local_pSubresource = nullptr;
    if (pSubresource)
    {
        local_pSubresource = (VkImageSubresource*)pool->alloc(sizeof(const VkImageSubresource));
        deepcopy_VkImageSubresource(pool, pSubresource, (VkImageSubresource*)(local_pSubresource));
    }
    if (local_pSubresource)
    {
        transform_tohost_VkImageSubresource(mImpl->resources(), (VkImageSubresource*)(local_pSubresource));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_270;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_270, 1);
        countingStream->write((uint64_t*)&cgen_var_270, 1 * 8);
        uint64_t cgen_var_271;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_271, 1);
        countingStream->write((uint64_t*)&cgen_var_271, 1 * 8);
        marshal_VkImageSubresource(countingStream, (VkImageSubresource*)(local_pSubresource));
        marshal_VkSubresourceLayout(countingStream, (VkSubresourceLayout*)(pLayout));
    }
    uint32_t packetSize_vkGetImageSubresourceLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSubresourceLayout = OP_vkGetImageSubresourceLayout;
    stream->write(&opcode_vkGetImageSubresourceLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSubresourceLayout, sizeof(uint32_t));
    uint64_t cgen_var_272;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_272, 1);
    stream->write((uint64_t*)&cgen_var_272, 1 * 8);
    uint64_t cgen_var_273;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_273, 1);
    stream->write((uint64_t*)&cgen_var_273, 1 * 8);
    marshal_VkImageSubresource(stream, (VkImageSubresource*)(local_pSubresource));
    marshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
    unmarshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
    if (pLayout)
    {
        transform_fromhost_VkSubresourceLayout(mImpl->resources(), (VkSubresourceLayout*)(pLayout));
    }
}

VkResult VkEncoder::vkCreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageViewCreateInfo*)pool->alloc(sizeof(const VkImageViewCreateInfo));
        deepcopy_VkImageViewCreateInfo(pool, pCreateInfo, (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageViewCreateInfo(mImpl->resources(), (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_274;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_274, 1);
        countingStream->write((uint64_t*)&cgen_var_274, 1 * 8);
        marshal_VkImageViewCreateInfo(countingStream, (VkImageViewCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_275 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_275);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_276;
        countingStream->handleMapping()->mapHandles_VkImageView_u64(pView, &cgen_var_276, 1);
        countingStream->write((uint64_t*)&cgen_var_276, 8);
    }
    uint32_t packetSize_vkCreateImageView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImageView = OP_vkCreateImageView;
    stream->write(&opcode_vkCreateImageView, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImageView, sizeof(uint32_t));
    uint64_t cgen_var_277;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_277, 1);
    stream->write((uint64_t*)&cgen_var_277, 1 * 8);
    marshal_VkImageViewCreateInfo(stream, (VkImageViewCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_278 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_278);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_279;
    stream->handleMapping()->mapHandles_VkImageView_u64(pView, &cgen_var_279, 1);
    stream->write((uint64_t*)&cgen_var_279, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_280;
    stream->read((uint64_t*)&cgen_var_280, 8);
    stream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_280, (VkImageView*)pView, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageView_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateImageView_VkResult_return;
}

void VkEncoder::vkDestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageView local_imageView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_imageView = imageView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_281;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_281, 1);
        countingStream->write((uint64_t*)&cgen_var_281, 1 * 8);
        uint64_t cgen_var_282;
        countingStream->handleMapping()->mapHandles_VkImageView_u64(&local_imageView, &cgen_var_282, 1);
        countingStream->write((uint64_t*)&cgen_var_282, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_283 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_283);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyImageView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyImageView = OP_vkDestroyImageView;
    stream->write(&opcode_vkDestroyImageView, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyImageView, sizeof(uint32_t));
    uint64_t cgen_var_284;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_284, 1);
    stream->write((uint64_t*)&cgen_var_284, 1 * 8);
    uint64_t cgen_var_285;
    stream->handleMapping()->mapHandles_VkImageView_u64(&local_imageView, &cgen_var_285, 1);
    stream->write((uint64_t*)&cgen_var_285, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_286 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_286);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkImageView((VkImageView*)&imageView);
}

VkResult VkEncoder::vkCreateShaderModule(
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkShaderModuleCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkShaderModuleCreateInfo*)pool->alloc(sizeof(const VkShaderModuleCreateInfo));
        deepcopy_VkShaderModuleCreateInfo(pool, pCreateInfo, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkShaderModuleCreateInfo(mImpl->resources(), (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_287;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_287, 1);
        countingStream->write((uint64_t*)&cgen_var_287, 1 * 8);
        marshal_VkShaderModuleCreateInfo(countingStream, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_288 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_288);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_289;
        countingStream->handleMapping()->mapHandles_VkShaderModule_u64(pShaderModule, &cgen_var_289, 1);
        countingStream->write((uint64_t*)&cgen_var_289, 8);
    }
    uint32_t packetSize_vkCreateShaderModule = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateShaderModule = OP_vkCreateShaderModule;
    stream->write(&opcode_vkCreateShaderModule, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateShaderModule, sizeof(uint32_t));
    uint64_t cgen_var_290;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_290, 1);
    stream->write((uint64_t*)&cgen_var_290, 1 * 8);
    marshal_VkShaderModuleCreateInfo(stream, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_291 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_291);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_292;
    stream->handleMapping()->mapHandles_VkShaderModule_u64(pShaderModule, &cgen_var_292, 1);
    stream->write((uint64_t*)&cgen_var_292, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_293;
    stream->read((uint64_t*)&cgen_var_293, 8);
    stream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_293, (VkShaderModule*)pShaderModule, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    stream->read(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateShaderModule_VkResult_return;
}

void VkEncoder::vkDestroyShaderModule(
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkShaderModule local_shaderModule;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_shaderModule = shaderModule;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_294;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_294, 1);
        countingStream->write((uint64_t*)&cgen_var_294, 1 * 8);
        uint64_t cgen_var_295;
        countingStream->handleMapping()->mapHandles_VkShaderModule_u64(&local_shaderModule, &cgen_var_295, 1);
        countingStream->write((uint64_t*)&cgen_var_295, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_296 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_296);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyShaderModule = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyShaderModule = OP_vkDestroyShaderModule;
    stream->write(&opcode_vkDestroyShaderModule, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyShaderModule, sizeof(uint32_t));
    uint64_t cgen_var_297;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_297, 1);
    stream->write((uint64_t*)&cgen_var_297, 1 * 8);
    uint64_t cgen_var_298;
    stream->handleMapping()->mapHandles_VkShaderModule_u64(&local_shaderModule, &cgen_var_298, 1);
    stream->write((uint64_t*)&cgen_var_298, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_299 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_299);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkShaderModule((VkShaderModule*)&shaderModule);
}

VkResult VkEncoder::vkCreatePipelineCache(
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCacheCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineCacheCreateInfo*)pool->alloc(sizeof(const VkPipelineCacheCreateInfo));
        deepcopy_VkPipelineCacheCreateInfo(pool, pCreateInfo, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineCacheCreateInfo(mImpl->resources(), (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_300;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_300, 1);
        countingStream->write((uint64_t*)&cgen_var_300, 1 * 8);
        marshal_VkPipelineCacheCreateInfo(countingStream, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_301 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_301);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_302;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(pPipelineCache, &cgen_var_302, 1);
        countingStream->write((uint64_t*)&cgen_var_302, 8);
    }
    uint32_t packetSize_vkCreatePipelineCache = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreatePipelineCache = OP_vkCreatePipelineCache;
    stream->write(&opcode_vkCreatePipelineCache, sizeof(uint32_t));
    stream->write(&packetSize_vkCreatePipelineCache, sizeof(uint32_t));
    uint64_t cgen_var_303;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_303, 1);
    stream->write((uint64_t*)&cgen_var_303, 1 * 8);
    marshal_VkPipelineCacheCreateInfo(stream, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_304 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_304);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_305;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(pPipelineCache, &cgen_var_305, 1);
    stream->write((uint64_t*)&cgen_var_305, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_306;
    stream->read((uint64_t*)&cgen_var_306, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_306, (VkPipelineCache*)pPipelineCache, 1);
    stream->unsetHandleMapping();
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreatePipelineCache_VkResult_return;
}

void VkEncoder::vkDestroyPipelineCache(
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_307;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_307, 1);
        countingStream->write((uint64_t*)&cgen_var_307, 1 * 8);
        uint64_t cgen_var_308;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_308, 1);
        countingStream->write((uint64_t*)&cgen_var_308, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_309 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_309);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipelineCache = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipelineCache = OP_vkDestroyPipelineCache;
    stream->write(&opcode_vkDestroyPipelineCache, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipelineCache, sizeof(uint32_t));
    uint64_t cgen_var_310;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_310, 1);
    stream->write((uint64_t*)&cgen_var_310, 1 * 8);
    uint64_t cgen_var_311;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_311, 1);
    stream->write((uint64_t*)&cgen_var_311, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_312 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_312);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)&pipelineCache);
}

VkResult VkEncoder::vkGetPipelineCacheData(
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    local_device = device;
    local_pipelineCache = pipelineCache;
    countingStream->rewind();
    {
        uint64_t cgen_var_313;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_313, 1);
        countingStream->write((uint64_t*)&cgen_var_313, 1 * 8);
        uint64_t cgen_var_314;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_314, 1);
        countingStream->write((uint64_t*)&cgen_var_314, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_315 = (uint64_t)(uintptr_t)pDataSize;
        countingStream->putBe64(cgen_var_315);
        if (pDataSize)
        {
            uint64_t cgen_var_316 = (uint64_t)(*pDataSize);
            countingStream->putBe64(cgen_var_316);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_317 = (uint64_t)(uintptr_t)pData;
        countingStream->putBe64(cgen_var_317);
        if (pData)
        {
            countingStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetPipelineCacheData = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPipelineCacheData = OP_vkGetPipelineCacheData;
    stream->write(&opcode_vkGetPipelineCacheData, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPipelineCacheData, sizeof(uint32_t));
    uint64_t cgen_var_318;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_318, 1);
    stream->write((uint64_t*)&cgen_var_318, 1 * 8);
    uint64_t cgen_var_319;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_319, 1);
    stream->write((uint64_t*)&cgen_var_319, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_320 = (uint64_t)(uintptr_t)pDataSize;
    stream->putBe64(cgen_var_320);
    if (pDataSize)
    {
        uint64_t cgen_var_321 = (uint64_t)(*pDataSize);
        stream->putBe64(cgen_var_321);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_322 = (uint64_t)(uintptr_t)pData;
    stream->putBe64(cgen_var_322);
    if (pData)
    {
        stream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPipelineCacheData_VkResult_return;
}

VkResult VkEncoder::vkMergePipelineCaches(
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_dstCache;
    uint32_t local_srcCacheCount;
    VkPipelineCache* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    local_pSrcCaches = nullptr;
    if (pSrcCaches)
    {
        local_pSrcCaches = (VkPipelineCache*)pool->dupArray(pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_326;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_326, 1);
        countingStream->write((uint64_t*)&cgen_var_326, 1 * 8);
        uint64_t cgen_var_327;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_dstCache, &cgen_var_327, 1);
        countingStream->write((uint64_t*)&cgen_var_327, 1 * 8);
        countingStream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
        if (((srcCacheCount)))
        {
            uint64_t* cgen_var_328;
            countingStream->alloc((void**)&cgen_var_328, ((srcCacheCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(local_pSrcCaches, cgen_var_328, ((srcCacheCount)));
            countingStream->write((uint64_t*)cgen_var_328, ((srcCacheCount)) * 8);
        }
    }
    uint32_t packetSize_vkMergePipelineCaches = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMergePipelineCaches = OP_vkMergePipelineCaches;
    stream->write(&opcode_vkMergePipelineCaches, sizeof(uint32_t));
    stream->write(&packetSize_vkMergePipelineCaches, sizeof(uint32_t));
    uint64_t cgen_var_329;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_329, 1);
    stream->write((uint64_t*)&cgen_var_329, 1 * 8);
    uint64_t cgen_var_330;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_dstCache, &cgen_var_330, 1);
    stream->write((uint64_t*)&cgen_var_330, 1 * 8);
    stream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    if (((srcCacheCount)))
    {
        uint64_t* cgen_var_331;
        stream->alloc((void**)&cgen_var_331, ((srcCacheCount)) * 8);
        stream->handleMapping()->mapHandles_VkPipelineCache_u64(local_pSrcCaches, cgen_var_331, ((srcCacheCount)));
        stream->write((uint64_t*)cgen_var_331, ((srcCacheCount)) * 8);
    }
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    stream->read(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkMergePipelineCaches_VkResult_return;
}

VkResult VkEncoder::vkCreateGraphicsPipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkGraphicsPipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkGraphicsPipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkGraphicsPipelineCreateInfo(pool, pCreateInfos + i, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkGraphicsPipelineCreateInfo(mImpl->resources(), (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_332;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_332, 1);
        countingStream->write((uint64_t*)&cgen_var_332, 1 * 8);
        uint64_t cgen_var_333;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_333, 1);
        countingStream->write((uint64_t*)&cgen_var_333, 1 * 8);
        countingStream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            marshal_VkGraphicsPipelineCreateInfo(countingStream, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_334 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_334);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        if (((createInfoCount)))
        {
            uint64_t* cgen_var_335;
            countingStream->alloc((void**)&cgen_var_335, ((createInfoCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_335, ((createInfoCount)));
            countingStream->write((uint64_t*)cgen_var_335, ((createInfoCount)) * 8);
        }
    }
    uint32_t packetSize_vkCreateGraphicsPipelines = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateGraphicsPipelines = OP_vkCreateGraphicsPipelines;
    stream->write(&opcode_vkCreateGraphicsPipelines, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateGraphicsPipelines, sizeof(uint32_t));
    uint64_t cgen_var_336;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_336, 1);
    stream->write((uint64_t*)&cgen_var_336, 1 * 8);
    uint64_t cgen_var_337;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_337, 1);
    stream->write((uint64_t*)&cgen_var_337, 1 * 8);
    stream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkGraphicsPipelineCreateInfo(stream, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_338 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_338);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_339;
        stream->alloc((void**)&cgen_var_339, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_339, ((createInfoCount)));
        stream->write((uint64_t*)cgen_var_339, ((createInfoCount)) * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_340;
        stream->alloc((void**)&cgen_var_340, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_340, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_340, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateGraphicsPipelines_VkResult_return;
}

VkResult VkEncoder::vkCreateComputePipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkComputePipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkComputePipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkComputePipelineCreateInfo(pool, pCreateInfos + i, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkComputePipelineCreateInfo(mImpl->resources(), (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_341;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_341, 1);
        countingStream->write((uint64_t*)&cgen_var_341, 1 * 8);
        uint64_t cgen_var_342;
        countingStream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_342, 1);
        countingStream->write((uint64_t*)&cgen_var_342, 1 * 8);
        countingStream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            marshal_VkComputePipelineCreateInfo(countingStream, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_343 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_343);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        if (((createInfoCount)))
        {
            uint64_t* cgen_var_344;
            countingStream->alloc((void**)&cgen_var_344, ((createInfoCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_344, ((createInfoCount)));
            countingStream->write((uint64_t*)cgen_var_344, ((createInfoCount)) * 8);
        }
    }
    uint32_t packetSize_vkCreateComputePipelines = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateComputePipelines = OP_vkCreateComputePipelines;
    stream->write(&opcode_vkCreateComputePipelines, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateComputePipelines, sizeof(uint32_t));
    uint64_t cgen_var_345;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_345, 1);
    stream->write((uint64_t*)&cgen_var_345, 1 * 8);
    uint64_t cgen_var_346;
    stream->handleMapping()->mapHandles_VkPipelineCache_u64(&local_pipelineCache, &cgen_var_346, 1);
    stream->write((uint64_t*)&cgen_var_346, 1 * 8);
    stream->write((uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkComputePipelineCreateInfo(stream, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_347 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_347);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_348;
        stream->alloc((void**)&cgen_var_348, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_VkPipeline_u64(pPipelines, cgen_var_348, ((createInfoCount)));
        stream->write((uint64_t*)cgen_var_348, ((createInfoCount)) * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_349;
        stream->alloc((void**)&cgen_var_349, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_349, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_349, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateComputePipelines_VkResult_return;
}

void VkEncoder::vkDestroyPipeline(
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipeline = pipeline;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_350;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_350, 1);
        countingStream->write((uint64_t*)&cgen_var_350, 1 * 8);
        uint64_t cgen_var_351;
        countingStream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_351, 1);
        countingStream->write((uint64_t*)&cgen_var_351, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_352 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_352);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipeline = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipeline = OP_vkDestroyPipeline;
    stream->write(&opcode_vkDestroyPipeline, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipeline, sizeof(uint32_t));
    uint64_t cgen_var_353;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_353, 1);
    stream->write((uint64_t*)&cgen_var_353, 1 * 8);
    uint64_t cgen_var_354;
    stream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_354, 1);
    stream->write((uint64_t*)&cgen_var_354, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_355 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_355);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkPipeline((VkPipeline*)&pipeline);
}

VkResult VkEncoder::vkCreatePipelineLayout(
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineLayoutCreateInfo*)pool->alloc(sizeof(const VkPipelineLayoutCreateInfo));
        deepcopy_VkPipelineLayoutCreateInfo(pool, pCreateInfo, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineLayoutCreateInfo(mImpl->resources(), (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_356;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_356, 1);
        countingStream->write((uint64_t*)&cgen_var_356, 1 * 8);
        marshal_VkPipelineLayoutCreateInfo(countingStream, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_357 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_357);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_358;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(pPipelineLayout, &cgen_var_358, 1);
        countingStream->write((uint64_t*)&cgen_var_358, 8);
    }
    uint32_t packetSize_vkCreatePipelineLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreatePipelineLayout = OP_vkCreatePipelineLayout;
    stream->write(&opcode_vkCreatePipelineLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkCreatePipelineLayout, sizeof(uint32_t));
    uint64_t cgen_var_359;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_359, 1);
    stream->write((uint64_t*)&cgen_var_359, 1 * 8);
    marshal_VkPipelineLayoutCreateInfo(stream, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_360 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_360);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_361;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(pPipelineLayout, &cgen_var_361, 1);
    stream->write((uint64_t*)&cgen_var_361, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_362;
    stream->read((uint64_t*)&cgen_var_362, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_362, (VkPipelineLayout*)pPipelineLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreatePipelineLayout_VkResult_return;
}

void VkEncoder::vkDestroyPipelineLayout(
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipelineLayout local_pipelineLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineLayout = pipelineLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_363;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_363, 1);
        countingStream->write((uint64_t*)&cgen_var_363, 1 * 8);
        uint64_t cgen_var_364;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_pipelineLayout, &cgen_var_364, 1);
        countingStream->write((uint64_t*)&cgen_var_364, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_365 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_365);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipelineLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipelineLayout = OP_vkDestroyPipelineLayout;
    stream->write(&opcode_vkDestroyPipelineLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipelineLayout, sizeof(uint32_t));
    uint64_t cgen_var_366;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_366, 1);
    stream->write((uint64_t*)&cgen_var_366, 1 * 8);
    uint64_t cgen_var_367;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_pipelineLayout, &cgen_var_367, 1);
    stream->write((uint64_t*)&cgen_var_367, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_368 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_368);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)&pipelineLayout);
}

VkResult VkEncoder::vkCreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerCreateInfo*)pool->alloc(sizeof(const VkSamplerCreateInfo));
        deepcopy_VkSamplerCreateInfo(pool, pCreateInfo, (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerCreateInfo(mImpl->resources(), (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_369;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_369, 1);
        countingStream->write((uint64_t*)&cgen_var_369, 1 * 8);
        marshal_VkSamplerCreateInfo(countingStream, (VkSamplerCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_370 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_370);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_371;
        countingStream->handleMapping()->mapHandles_VkSampler_u64(pSampler, &cgen_var_371, 1);
        countingStream->write((uint64_t*)&cgen_var_371, 8);
    }
    uint32_t packetSize_vkCreateSampler = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSampler = OP_vkCreateSampler;
    stream->write(&opcode_vkCreateSampler, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSampler, sizeof(uint32_t));
    uint64_t cgen_var_372;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_372, 1);
    stream->write((uint64_t*)&cgen_var_372, 1 * 8);
    marshal_VkSamplerCreateInfo(stream, (VkSamplerCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_373 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_373);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_374;
    stream->handleMapping()->mapHandles_VkSampler_u64(pSampler, &cgen_var_374, 1);
    stream->write((uint64_t*)&cgen_var_374, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_375;
    stream->read((uint64_t*)&cgen_var_375, 8);
    stream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_375, (VkSampler*)pSampler, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSampler_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateSampler_VkResult_return;
}

void VkEncoder::vkDestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSampler local_sampler;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_sampler = sampler;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_376;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_376, 1);
        countingStream->write((uint64_t*)&cgen_var_376, 1 * 8);
        uint64_t cgen_var_377;
        countingStream->handleMapping()->mapHandles_VkSampler_u64(&local_sampler, &cgen_var_377, 1);
        countingStream->write((uint64_t*)&cgen_var_377, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_378 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_378);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySampler = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySampler = OP_vkDestroySampler;
    stream->write(&opcode_vkDestroySampler, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySampler, sizeof(uint32_t));
    uint64_t cgen_var_379;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_379, 1);
    stream->write((uint64_t*)&cgen_var_379, 1 * 8);
    uint64_t cgen_var_380;
    stream->handleMapping()->mapHandles_VkSampler_u64(&local_sampler, &cgen_var_380, 1);
    stream->write((uint64_t*)&cgen_var_380, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_381 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_381);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkSampler((VkSampler*)&sampler);
}

VkResult VkEncoder::vkCreateDescriptorSetLayout(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(mImpl->resources(), (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_382;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_382, 1);
        countingStream->write((uint64_t*)&cgen_var_382, 1 * 8);
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_383 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_383);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_384;
        countingStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(pSetLayout, &cgen_var_384, 1);
        countingStream->write((uint64_t*)&cgen_var_384, 8);
    }
    uint32_t packetSize_vkCreateDescriptorSetLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorSetLayout = OP_vkCreateDescriptorSetLayout;
    stream->write(&opcode_vkCreateDescriptorSetLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorSetLayout, sizeof(uint32_t));
    uint64_t cgen_var_385;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_385, 1);
    stream->write((uint64_t*)&cgen_var_385, 1 * 8);
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_386 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_386);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_387;
    stream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(pSetLayout, &cgen_var_387, 1);
    stream->write((uint64_t*)&cgen_var_387, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_388;
    stream->read((uint64_t*)&cgen_var_388, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_388, (VkDescriptorSetLayout*)pSetLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDescriptorSetLayout_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorSetLayout(
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayout local_descriptorSetLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorSetLayout = descriptorSetLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_389;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_389, 1);
        countingStream->write((uint64_t*)&cgen_var_389, 1 * 8);
        uint64_t cgen_var_390;
        countingStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(&local_descriptorSetLayout, &cgen_var_390, 1);
        countingStream->write((uint64_t*)&cgen_var_390, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_391 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_391);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorSetLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorSetLayout = OP_vkDestroyDescriptorSetLayout;
    stream->write(&opcode_vkDestroyDescriptorSetLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorSetLayout, sizeof(uint32_t));
    uint64_t cgen_var_392;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_392, 1);
    stream->write((uint64_t*)&cgen_var_392, 1 * 8);
    uint64_t cgen_var_393;
    stream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(&local_descriptorSetLayout, &cgen_var_393, 1);
    stream->write((uint64_t*)&cgen_var_393, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_394 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_394);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)&descriptorSetLayout);
}

VkResult VkEncoder::vkCreateDescriptorPool(
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorPoolCreateInfo*)pool->alloc(sizeof(const VkDescriptorPoolCreateInfo));
        deepcopy_VkDescriptorPoolCreateInfo(pool, pCreateInfo, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorPoolCreateInfo(mImpl->resources(), (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_395;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_395, 1);
        countingStream->write((uint64_t*)&cgen_var_395, 1 * 8);
        marshal_VkDescriptorPoolCreateInfo(countingStream, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_396 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_396);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_397;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(pDescriptorPool, &cgen_var_397, 1);
        countingStream->write((uint64_t*)&cgen_var_397, 8);
    }
    uint32_t packetSize_vkCreateDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorPool = OP_vkCreateDescriptorPool;
    stream->write(&opcode_vkCreateDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorPool, sizeof(uint32_t));
    uint64_t cgen_var_398;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_398, 1);
    stream->write((uint64_t*)&cgen_var_398, 1 * 8);
    marshal_VkDescriptorPoolCreateInfo(stream, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_399 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_399);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_400;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(pDescriptorPool, &cgen_var_400, 1);
    stream->write((uint64_t*)&cgen_var_400, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_401;
    stream->read((uint64_t*)&cgen_var_401, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_401, (VkDescriptorPool*)pDescriptorPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDescriptorPool_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_402;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_402, 1);
        countingStream->write((uint64_t*)&cgen_var_402, 1 * 8);
        uint64_t cgen_var_403;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_403, 1);
        countingStream->write((uint64_t*)&cgen_var_403, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_404 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_404);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorPool = OP_vkDestroyDescriptorPool;
    stream->write(&opcode_vkDestroyDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorPool, sizeof(uint32_t));
    uint64_t cgen_var_405;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_405, 1);
    stream->write((uint64_t*)&cgen_var_405, 1 * 8);
    uint64_t cgen_var_406;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_406, 1);
    stream->write((uint64_t*)&cgen_var_406, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_407 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_407);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)&descriptorPool);
}

VkResult VkEncoder::vkResetDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkDescriptorPoolResetFlags local_flags;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_408;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_408, 1);
        countingStream->write((uint64_t*)&cgen_var_408, 1 * 8);
        uint64_t cgen_var_409;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_409, 1);
        countingStream->write((uint64_t*)&cgen_var_409, 1 * 8);
        countingStream->write((VkDescriptorPoolResetFlags*)&local_flags, sizeof(VkDescriptorPoolResetFlags));
    }
    uint32_t packetSize_vkResetDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetDescriptorPool = OP_vkResetDescriptorPool;
    stream->write(&opcode_vkResetDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkResetDescriptorPool, sizeof(uint32_t));
    uint64_t cgen_var_410;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_410, 1);
    stream->write((uint64_t*)&cgen_var_410, 1 * 8);
    uint64_t cgen_var_411;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_411, 1);
    stream->write((uint64_t*)&cgen_var_411, 1 * 8);
    stream->write((VkDescriptorPoolResetFlags*)&local_flags, sizeof(VkDescriptorPoolResetFlags));
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkResetDescriptorPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateDescriptorSets(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkDescriptorSetAllocateInfo*)pool->alloc(sizeof(const VkDescriptorSetAllocateInfo));
        deepcopy_VkDescriptorSetAllocateInfo(pool, pAllocateInfo, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkDescriptorSetAllocateInfo(mImpl->resources(), (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_412;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_412, 1);
        countingStream->write((uint64_t*)&cgen_var_412, 1 * 8);
        marshal_VkDescriptorSetAllocateInfo(countingStream, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
        if (pAllocateInfo->descriptorSetCount)
        {
            uint64_t* cgen_var_413;
            countingStream->alloc((void**)&cgen_var_413, pAllocateInfo->descriptorSetCount * 8);
            countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(pDescriptorSets, cgen_var_413, pAllocateInfo->descriptorSetCount);
            countingStream->write((uint64_t*)cgen_var_413, pAllocateInfo->descriptorSetCount * 8);
        }
    }
    uint32_t packetSize_vkAllocateDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateDescriptorSets = OP_vkAllocateDescriptorSets;
    stream->write(&opcode_vkAllocateDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_414;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_414, 1);
    stream->write((uint64_t*)&cgen_var_414, 1 * 8);
    marshal_VkDescriptorSetAllocateInfo(stream, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (pAllocateInfo->descriptorSetCount)
    {
        uint64_t* cgen_var_415;
        stream->alloc((void**)&cgen_var_415, pAllocateInfo->descriptorSetCount * 8);
        stream->handleMapping()->mapHandles_VkDescriptorSet_u64(pDescriptorSets, cgen_var_415, pAllocateInfo->descriptorSetCount);
        stream->write((uint64_t*)cgen_var_415, pAllocateInfo->descriptorSetCount * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    if (pAllocateInfo->descriptorSetCount)
    {
        uint64_t* cgen_var_416;
        stream->alloc((void**)&cgen_var_416, pAllocateInfo->descriptorSetCount * 8);
        stream->read((uint64_t*)cgen_var_416, pAllocateInfo->descriptorSetCount * 8);
        stream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_416, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
    }
    stream->unsetHandleMapping();
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAllocateDescriptorSets_VkResult_return;
}

VkResult VkEncoder::vkFreeDescriptorSets(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_descriptorSetCount = descriptorSetCount;
    local_pDescriptorSets = nullptr;
    if (pDescriptorSets)
    {
        local_pDescriptorSets = (VkDescriptorSet*)pool->dupArray(pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_417;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_417, 1);
        countingStream->write((uint64_t*)&cgen_var_417, 1 * 8);
        uint64_t cgen_var_418;
        countingStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_418, 1);
        countingStream->write((uint64_t*)&cgen_var_418, 1 * 8);
        countingStream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_419 = (uint64_t)(uintptr_t)local_pDescriptorSets;
        countingStream->putBe64(cgen_var_419);
        if (local_pDescriptorSets)
        {
            if (((descriptorSetCount)))
            {
                uint64_t* cgen_var_420;
                countingStream->alloc((void**)&cgen_var_420, ((descriptorSetCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_420, ((descriptorSetCount)));
                countingStream->write((uint64_t*)cgen_var_420, ((descriptorSetCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkFreeDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeDescriptorSets = OP_vkFreeDescriptorSets;
    stream->write(&opcode_vkFreeDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_421;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_421, 1);
    stream->write((uint64_t*)&cgen_var_421, 1 * 8);
    uint64_t cgen_var_422;
    stream->handleMapping()->mapHandles_VkDescriptorPool_u64(&local_descriptorPool, &cgen_var_422, 1);
    stream->write((uint64_t*)&cgen_var_422, 1 * 8);
    stream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_423 = (uint64_t)(uintptr_t)local_pDescriptorSets;
    stream->putBe64(cgen_var_423);
    if (local_pDescriptorSets)
    {
        if (((descriptorSetCount)))
        {
            uint64_t* cgen_var_424;
            stream->alloc((void**)&cgen_var_424, ((descriptorSetCount)) * 8);
            stream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_424, ((descriptorSetCount)));
            stream->write((uint64_t*)cgen_var_424, ((descriptorSetCount)) * 8);
        }
    }
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    if (pDescriptorSets)
    {
        resources->destroyMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
    }
    return vkFreeDescriptorSets_VkResult_return;
}

void VkEncoder::vkUpdateDescriptorSets(
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    uint32_t local_descriptorCopyCount;
    VkCopyDescriptorSet* local_pDescriptorCopies;
    local_device = device;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    local_descriptorCopyCount = descriptorCopyCount;
    local_pDescriptorCopies = nullptr;
    if (pDescriptorCopies)
    {
        local_pDescriptorCopies = (VkCopyDescriptorSet*)pool->alloc(((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            deepcopy_VkCopyDescriptorSet(pool, pDescriptorCopies + i, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(mImpl->resources(), (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorCopies)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            transform_tohost_VkCopyDescriptorSet(mImpl->resources(), (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_425;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_425, 1);
        countingStream->write((uint64_t*)&cgen_var_425, 1 * 8);
        countingStream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            marshal_VkWriteDescriptorSet(countingStream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
        countingStream->write((uint32_t*)&local_descriptorCopyCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            marshal_VkCopyDescriptorSet(countingStream, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSets = OP_vkUpdateDescriptorSets;
    stream->write(&opcode_vkUpdateDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_426;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_426, 1);
    stream->write((uint64_t*)&cgen_var_426, 1 * 8);
    stream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(stream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
    }
    stream->write((uint32_t*)&local_descriptorCopyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        marshal_VkCopyDescriptorSet(stream, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
    }
}

VkResult VkEncoder::vkCreateFramebuffer(
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFramebufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFramebufferCreateInfo*)pool->alloc(sizeof(const VkFramebufferCreateInfo));
        deepcopy_VkFramebufferCreateInfo(pool, pCreateInfo, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFramebufferCreateInfo(mImpl->resources(), (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_427;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_427, 1);
        countingStream->write((uint64_t*)&cgen_var_427, 1 * 8);
        marshal_VkFramebufferCreateInfo(countingStream, (VkFramebufferCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_428 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_428);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_429;
        countingStream->handleMapping()->mapHandles_VkFramebuffer_u64(pFramebuffer, &cgen_var_429, 1);
        countingStream->write((uint64_t*)&cgen_var_429, 8);
    }
    uint32_t packetSize_vkCreateFramebuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateFramebuffer = OP_vkCreateFramebuffer;
    stream->write(&opcode_vkCreateFramebuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateFramebuffer, sizeof(uint32_t));
    uint64_t cgen_var_430;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_430, 1);
    stream->write((uint64_t*)&cgen_var_430, 1 * 8);
    marshal_VkFramebufferCreateInfo(stream, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_431 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_431);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_432;
    stream->handleMapping()->mapHandles_VkFramebuffer_u64(pFramebuffer, &cgen_var_432, 1);
    stream->write((uint64_t*)&cgen_var_432, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_433;
    stream->read((uint64_t*)&cgen_var_433, 8);
    stream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_433, (VkFramebuffer*)pFramebuffer, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateFramebuffer_VkResult_return;
}

void VkEncoder::vkDestroyFramebuffer(
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFramebuffer local_framebuffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_framebuffer = framebuffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_434;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_434, 1);
        countingStream->write((uint64_t*)&cgen_var_434, 1 * 8);
        uint64_t cgen_var_435;
        countingStream->handleMapping()->mapHandles_VkFramebuffer_u64(&local_framebuffer, &cgen_var_435, 1);
        countingStream->write((uint64_t*)&cgen_var_435, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_436 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_436);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyFramebuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyFramebuffer = OP_vkDestroyFramebuffer;
    stream->write(&opcode_vkDestroyFramebuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyFramebuffer, sizeof(uint32_t));
    uint64_t cgen_var_437;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_437, 1);
    stream->write((uint64_t*)&cgen_var_437, 1 * 8);
    uint64_t cgen_var_438;
    stream->handleMapping()->mapHandles_VkFramebuffer_u64(&local_framebuffer, &cgen_var_438, 1);
    stream->write((uint64_t*)&cgen_var_438, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_439 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_439);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)&framebuffer);
}

VkResult VkEncoder::vkCreateRenderPass(
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPassCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo*)pool->alloc(sizeof(const VkRenderPassCreateInfo));
        deepcopy_VkRenderPassCreateInfo(pool, pCreateInfo, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo(mImpl->resources(), (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_440;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_440, 1);
        countingStream->write((uint64_t*)&cgen_var_440, 1 * 8);
        marshal_VkRenderPassCreateInfo(countingStream, (VkRenderPassCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_441 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_441);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_442;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_442, 1);
        countingStream->write((uint64_t*)&cgen_var_442, 8);
    }
    uint32_t packetSize_vkCreateRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateRenderPass = OP_vkCreateRenderPass;
    stream->write(&opcode_vkCreateRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_443;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_443, 1);
    stream->write((uint64_t*)&cgen_var_443, 1 * 8);
    marshal_VkRenderPassCreateInfo(stream, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_444 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_444);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_445;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_445, 1);
    stream->write((uint64_t*)&cgen_var_445, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_446;
    stream->read((uint64_t*)&cgen_var_446, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_446, (VkRenderPass*)pRenderPass, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateRenderPass_VkResult_return;
}

void VkEncoder::vkDestroyRenderPass(
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPass local_renderPass;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_renderPass = renderPass;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_447;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_447, 1);
        countingStream->write((uint64_t*)&cgen_var_447, 1 * 8);
        uint64_t cgen_var_448;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_448, 1);
        countingStream->write((uint64_t*)&cgen_var_448, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_449 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_449);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyRenderPass = OP_vkDestroyRenderPass;
    stream->write(&opcode_vkDestroyRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_450;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_450, 1);
    stream->write((uint64_t*)&cgen_var_450, 1 * 8);
    uint64_t cgen_var_451;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_451, 1);
    stream->write((uint64_t*)&cgen_var_451, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_452 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_452);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkRenderPass((VkRenderPass*)&renderPass);
}

void VkEncoder::vkGetRenderAreaGranularity(
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPass local_renderPass;
    local_device = device;
    local_renderPass = renderPass;
    countingStream->rewind();
    {
        uint64_t cgen_var_453;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_453, 1);
        countingStream->write((uint64_t*)&cgen_var_453, 1 * 8);
        uint64_t cgen_var_454;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_454, 1);
        countingStream->write((uint64_t*)&cgen_var_454, 1 * 8);
        marshal_VkExtent2D(countingStream, (VkExtent2D*)(pGranularity));
    }
    uint32_t packetSize_vkGetRenderAreaGranularity = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRenderAreaGranularity = OP_vkGetRenderAreaGranularity;
    stream->write(&opcode_vkGetRenderAreaGranularity, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRenderAreaGranularity, sizeof(uint32_t));
    uint64_t cgen_var_455;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_455, 1);
    stream->write((uint64_t*)&cgen_var_455, 1 * 8);
    uint64_t cgen_var_456;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(&local_renderPass, &cgen_var_456, 1);
    stream->write((uint64_t*)&cgen_var_456, 1 * 8);
    marshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
    unmarshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
    if (pGranularity)
    {
        transform_fromhost_VkExtent2D(mImpl->resources(), (VkExtent2D*)(pGranularity));
    }
}

VkResult VkEncoder::vkCreateCommandPool(
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkCommandPoolCreateInfo*)pool->alloc(sizeof(const VkCommandPoolCreateInfo));
        deepcopy_VkCommandPoolCreateInfo(pool, pCreateInfo, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkCommandPoolCreateInfo(mImpl->resources(), (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_457;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_457, 1);
        countingStream->write((uint64_t*)&cgen_var_457, 1 * 8);
        marshal_VkCommandPoolCreateInfo(countingStream, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_458 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_458);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_459;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(pCommandPool, &cgen_var_459, 1);
        countingStream->write((uint64_t*)&cgen_var_459, 8);
    }
    uint32_t packetSize_vkCreateCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateCommandPool = OP_vkCreateCommandPool;
    stream->write(&opcode_vkCreateCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_460;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_460, 1);
    stream->write((uint64_t*)&cgen_var_460, 1 * 8);
    marshal_VkCommandPoolCreateInfo(stream, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_461 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_461);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_462;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(pCommandPool, &cgen_var_462, 1);
    stream->write((uint64_t*)&cgen_var_462, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_463;
    stream->read((uint64_t*)&cgen_var_463, 8);
    stream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_463, (VkCommandPool*)pCommandPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateCommandPool_VkResult_return;
}

void VkEncoder::vkDestroyCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_commandPool = commandPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_464;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_464, 1);
        countingStream->write((uint64_t*)&cgen_var_464, 1 * 8);
        uint64_t cgen_var_465;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_465, 1);
        countingStream->write((uint64_t*)&cgen_var_465, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_466 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_466);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyCommandPool = OP_vkDestroyCommandPool;
    stream->write(&opcode_vkDestroyCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_467;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_467, 1);
    stream->write((uint64_t*)&cgen_var_467, 1 * 8);
    uint64_t cgen_var_468;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_468, 1);
    stream->write((uint64_t*)&cgen_var_468, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_469 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_469);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkCommandPool((VkCommandPool*)&commandPool);
}

VkResult VkEncoder::vkResetCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolResetFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_470;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_470, 1);
        countingStream->write((uint64_t*)&cgen_var_470, 1 * 8);
        uint64_t cgen_var_471;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_471, 1);
        countingStream->write((uint64_t*)&cgen_var_471, 1 * 8);
        countingStream->write((VkCommandPoolResetFlags*)&local_flags, sizeof(VkCommandPoolResetFlags));
    }
    uint32_t packetSize_vkResetCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandPool = OP_vkResetCommandPool;
    stream->write(&opcode_vkResetCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_472;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_472, 1);
    stream->write((uint64_t*)&cgen_var_472, 1 * 8);
    uint64_t cgen_var_473;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_473, 1);
    stream->write((uint64_t*)&cgen_var_473, 1 * 8);
    stream->write((VkCommandPoolResetFlags*)&local_flags, sizeof(VkCommandPoolResetFlags));
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkResetCommandPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateCommandBuffers(
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandBufferAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkCommandBufferAllocateInfo*)pool->alloc(sizeof(const VkCommandBufferAllocateInfo));
        deepcopy_VkCommandBufferAllocateInfo(pool, pAllocateInfo, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkCommandBufferAllocateInfo(mImpl->resources(), (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_474;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_474, 1);
        countingStream->write((uint64_t*)&cgen_var_474, 1 * 8);
        marshal_VkCommandBufferAllocateInfo(countingStream, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
        if (pAllocateInfo->commandBufferCount)
        {
            uint64_t* cgen_var_475;
            countingStream->alloc((void**)&cgen_var_475, pAllocateInfo->commandBufferCount * 8);
            countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(pCommandBuffers, cgen_var_475, pAllocateInfo->commandBufferCount);
            countingStream->write((uint64_t*)cgen_var_475, pAllocateInfo->commandBufferCount * 8);
        }
    }
    uint32_t packetSize_vkAllocateCommandBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateCommandBuffers = OP_vkAllocateCommandBuffers;
    stream->write(&opcode_vkAllocateCommandBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateCommandBuffers, sizeof(uint32_t));
    uint64_t cgen_var_476;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_476, 1);
    stream->write((uint64_t*)&cgen_var_476, 1 * 8);
    marshal_VkCommandBufferAllocateInfo(stream, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (pAllocateInfo->commandBufferCount)
    {
        uint64_t* cgen_var_477;
        stream->alloc((void**)&cgen_var_477, pAllocateInfo->commandBufferCount * 8);
        stream->handleMapping()->mapHandles_VkCommandBuffer_u64(pCommandBuffers, cgen_var_477, pAllocateInfo->commandBufferCount);
        stream->write((uint64_t*)cgen_var_477, pAllocateInfo->commandBufferCount * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    if (pAllocateInfo->commandBufferCount)
    {
        uint64_t* cgen_var_478;
        stream->alloc((void**)&cgen_var_478, pAllocateInfo->commandBufferCount * 8);
        stream->read((uint64_t*)cgen_var_478, pAllocateInfo->commandBufferCount * 8);
        stream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_478, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
    }
    stream->unsetHandleMapping();
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAllocateCommandBuffers_VkResult_return;
}

void VkEncoder::vkFreeCommandBuffers(
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_device = device;
    local_commandPool = commandPool;
    local_commandBufferCount = commandBufferCount;
    local_pCommandBuffers = nullptr;
    if (pCommandBuffers)
    {
        local_pCommandBuffers = (VkCommandBuffer*)pool->dupArray(pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_479;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_479, 1);
        countingStream->write((uint64_t*)&cgen_var_479, 1 * 8);
        uint64_t cgen_var_480;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_480, 1);
        countingStream->write((uint64_t*)&cgen_var_480, 1 * 8);
        countingStream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_481 = (uint64_t)(uintptr_t)local_pCommandBuffers;
        countingStream->putBe64(cgen_var_481);
        if (local_pCommandBuffers)
        {
            if (((commandBufferCount)))
            {
                uint64_t* cgen_var_482;
                countingStream->alloc((void**)&cgen_var_482, ((commandBufferCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_482, ((commandBufferCount)));
                countingStream->write((uint64_t*)cgen_var_482, ((commandBufferCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkFreeCommandBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeCommandBuffers = OP_vkFreeCommandBuffers;
    stream->write(&opcode_vkFreeCommandBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeCommandBuffers, sizeof(uint32_t));
    uint64_t cgen_var_483;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_483, 1);
    stream->write((uint64_t*)&cgen_var_483, 1 * 8);
    uint64_t cgen_var_484;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_484, 1);
    stream->write((uint64_t*)&cgen_var_484, 1 * 8);
    stream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_485 = (uint64_t)(uintptr_t)local_pCommandBuffers;
    stream->putBe64(cgen_var_485);
    if (local_pCommandBuffers)
    {
        if (((commandBufferCount)))
        {
            uint64_t* cgen_var_486;
            stream->alloc((void**)&cgen_var_486, ((commandBufferCount)) * 8);
            stream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_486, ((commandBufferCount)));
            stream->write((uint64_t*)cgen_var_486, ((commandBufferCount)) * 8);
        }
    }
    if (pCommandBuffers)
    {
        resources->destroyMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
    }
}

VkResult VkEncoder::vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(mImpl->resources(), (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_487;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_487, 1);
        countingStream->write((uint64_t*)&cgen_var_487, 1 * 8);
        marshal_VkCommandBufferBeginInfo(countingStream, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    uint32_t packetSize_vkBeginCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBeginCommandBuffer = OP_vkBeginCommandBuffer;
    stream->write(&opcode_vkBeginCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkBeginCommandBuffer, sizeof(uint32_t));
    uint64_t cgen_var_488;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_488, 1);
    stream->write((uint64_t*)&cgen_var_488, 1 * 8);
    marshal_VkCommandBufferBeginInfo(stream, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBeginCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkEndCommandBuffer(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_489;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_489, 1);
        countingStream->write((uint64_t*)&cgen_var_489, 1 * 8);
    }
    uint32_t packetSize_vkEndCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEndCommandBuffer = OP_vkEndCommandBuffer;
    stream->write(&opcode_vkEndCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkEndCommandBuffer, sizeof(uint32_t));
    uint64_t cgen_var_490;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_490, 1);
    stream->write((uint64_t*)&cgen_var_490, 1 * 8);
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEndCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_491;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_491, 1);
        countingStream->write((uint64_t*)&cgen_var_491, 1 * 8);
        countingStream->write((VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    }
    uint32_t packetSize_vkResetCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandBuffer = OP_vkResetCommandBuffer;
    stream->write(&opcode_vkResetCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandBuffer, sizeof(uint32_t));
    uint64_t cgen_var_492;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_492, 1);
    stream->write((uint64_t*)&cgen_var_492, 1 * 8);
    stream->write((VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkResetCommandBuffer_VkResult_return;
}

void VkEncoder::vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipeline local_pipeline;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_pipeline = pipeline;
    countingStream->rewind();
    {
        uint64_t cgen_var_493;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_493, 1);
        countingStream->write((uint64_t*)&cgen_var_493, 1 * 8);
        countingStream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
        uint64_t cgen_var_494;
        countingStream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_494, 1);
        countingStream->write((uint64_t*)&cgen_var_494, 1 * 8);
    }
    uint32_t packetSize_vkCmdBindPipeline = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindPipeline = OP_vkCmdBindPipeline;
    stream->write(&opcode_vkCmdBindPipeline, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindPipeline, sizeof(uint32_t));
    uint64_t cgen_var_495;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_495, 1);
    stream->write((uint64_t*)&cgen_var_495, 1 * 8);
    stream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_496;
    stream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_496, 1);
    stream->write((uint64_t*)&cgen_var_496, 1 * 8);
}

void VkEncoder::vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewport* local_pViewports;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewports = nullptr;
    if (pViewports)
    {
        local_pViewports = (VkViewport*)pool->alloc(((viewportCount)) * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewport(pool, pViewports + i, (VkViewport*)(local_pViewports + i));
        }
    }
    if (local_pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewport(mImpl->resources(), (VkViewport*)(local_pViewports + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_497;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_497, 1);
        countingStream->write((uint64_t*)&cgen_var_497, 1 * 8);
        countingStream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            marshal_VkViewport(countingStream, (VkViewport*)(local_pViewports + i));
        }
    }
    uint32_t packetSize_vkCmdSetViewport = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetViewport = OP_vkCmdSetViewport;
    stream->write(&opcode_vkCmdSetViewport, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetViewport, sizeof(uint32_t));
    uint64_t cgen_var_498;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_498, 1);
    stream->write((uint64_t*)&cgen_var_498, 1 * 8);
    stream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
    stream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewport(stream, (VkViewport*)(local_pViewports + i));
    }
}

void VkEncoder::vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstScissor;
    uint32_t local_scissorCount;
    VkRect2D* local_pScissors;
    local_commandBuffer = commandBuffer;
    local_firstScissor = firstScissor;
    local_scissorCount = scissorCount;
    local_pScissors = nullptr;
    if (pScissors)
    {
        local_pScissors = (VkRect2D*)pool->alloc(((scissorCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            deepcopy_VkRect2D(pool, pScissors + i, (VkRect2D*)(local_pScissors + i));
        }
    }
    if (local_pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            transform_tohost_VkRect2D(mImpl->resources(), (VkRect2D*)(local_pScissors + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_499;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_499, 1);
        countingStream->write((uint64_t*)&cgen_var_499, 1 * 8);
        countingStream->write((uint32_t*)&local_firstScissor, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_scissorCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            marshal_VkRect2D(countingStream, (VkRect2D*)(local_pScissors + i));
        }
    }
    uint32_t packetSize_vkCmdSetScissor = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetScissor = OP_vkCmdSetScissor;
    stream->write(&opcode_vkCmdSetScissor, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetScissor, sizeof(uint32_t));
    uint64_t cgen_var_500;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_500, 1);
    stream->write((uint64_t*)&cgen_var_500, 1 * 8);
    stream->write((uint32_t*)&local_firstScissor, sizeof(uint32_t));
    stream->write((uint32_t*)&local_scissorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        marshal_VkRect2D(stream, (VkRect2D*)(local_pScissors + i));
    }
}

void VkEncoder::vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    float lineWidth)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_lineWidth;
    local_commandBuffer = commandBuffer;
    local_lineWidth = lineWidth;
    countingStream->rewind();
    {
        uint64_t cgen_var_501;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_501, 1);
        countingStream->write((uint64_t*)&cgen_var_501, 1 * 8);
        countingStream->write((float*)&local_lineWidth, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetLineWidth = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetLineWidth = OP_vkCmdSetLineWidth;
    stream->write(&opcode_vkCmdSetLineWidth, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetLineWidth, sizeof(uint32_t));
    uint64_t cgen_var_502;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_502, 1);
    stream->write((uint64_t*)&cgen_var_502, 1 * 8);
    stream->write((float*)&local_lineWidth, sizeof(float));
}

void VkEncoder::vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_depthBiasConstantFactor;
    float local_depthBiasClamp;
    float local_depthBiasSlopeFactor;
    local_commandBuffer = commandBuffer;
    local_depthBiasConstantFactor = depthBiasConstantFactor;
    local_depthBiasClamp = depthBiasClamp;
    local_depthBiasSlopeFactor = depthBiasSlopeFactor;
    countingStream->rewind();
    {
        uint64_t cgen_var_503;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_503, 1);
        countingStream->write((uint64_t*)&cgen_var_503, 1 * 8);
        countingStream->write((float*)&local_depthBiasConstantFactor, sizeof(float));
        countingStream->write((float*)&local_depthBiasClamp, sizeof(float));
        countingStream->write((float*)&local_depthBiasSlopeFactor, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetDepthBias = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDepthBias = OP_vkCmdSetDepthBias;
    stream->write(&opcode_vkCmdSetDepthBias, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDepthBias, sizeof(uint32_t));
    uint64_t cgen_var_504;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_504, 1);
    stream->write((uint64_t*)&cgen_var_504, 1 * 8);
    stream->write((float*)&local_depthBiasConstantFactor, sizeof(float));
    stream->write((float*)&local_depthBiasClamp, sizeof(float));
    stream->write((float*)&local_depthBiasSlopeFactor, sizeof(float));
}

void VkEncoder::vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    const float blendConstants)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_blendConstants[4];
    local_commandBuffer = commandBuffer;
    memcpy(&local_blendConstants, &blendConstants, 4 * sizeof(const float));
    countingStream->rewind();
    {
        uint64_t cgen_var_505;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_505, 1);
        countingStream->write((uint64_t*)&cgen_var_505, 1 * 8);
        countingStream->write((float*)&local_blendConstants, 4 * sizeof(float));
    }
    uint32_t packetSize_vkCmdSetBlendConstants = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetBlendConstants = OP_vkCmdSetBlendConstants;
    stream->write(&opcode_vkCmdSetBlendConstants, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetBlendConstants, sizeof(uint32_t));
    uint64_t cgen_var_506;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_506, 1);
    stream->write((uint64_t*)&cgen_var_506, 1 * 8);
    stream->write((float*)&local_blendConstants, 4 * sizeof(float));
}

void VkEncoder::vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    float local_minDepthBounds;
    float local_maxDepthBounds;
    local_commandBuffer = commandBuffer;
    local_minDepthBounds = minDepthBounds;
    local_maxDepthBounds = maxDepthBounds;
    countingStream->rewind();
    {
        uint64_t cgen_var_507;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_507, 1);
        countingStream->write((uint64_t*)&cgen_var_507, 1 * 8);
        countingStream->write((float*)&local_minDepthBounds, sizeof(float));
        countingStream->write((float*)&local_maxDepthBounds, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetDepthBounds = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDepthBounds = OP_vkCmdSetDepthBounds;
    stream->write(&opcode_vkCmdSetDepthBounds, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDepthBounds, sizeof(uint32_t));
    uint64_t cgen_var_508;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_508, 1);
    stream->write((uint64_t*)&cgen_var_508, 1 * 8);
    stream->write((float*)&local_minDepthBounds, sizeof(float));
    stream->write((float*)&local_maxDepthBounds, sizeof(float));
}

void VkEncoder::vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_compareMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_compareMask = compareMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_509;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_509, 1);
        countingStream->write((uint64_t*)&cgen_var_509, 1 * 8);
        countingStream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&local_compareMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilCompareMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilCompareMask = OP_vkCmdSetStencilCompareMask;
    stream->write(&opcode_vkCmdSetStencilCompareMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilCompareMask, sizeof(uint32_t));
    uint64_t cgen_var_510;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_510, 1);
    stream->write((uint64_t*)&cgen_var_510, 1 * 8);
    stream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&local_compareMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_writeMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_writeMask = writeMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_511;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_511, 1);
        countingStream->write((uint64_t*)&cgen_var_511, 1 * 8);
        countingStream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&local_writeMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilWriteMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilWriteMask = OP_vkCmdSetStencilWriteMask;
    stream->write(&opcode_vkCmdSetStencilWriteMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilWriteMask, sizeof(uint32_t));
    uint64_t cgen_var_512;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_512, 1);
    stream->write((uint64_t*)&cgen_var_512, 1 * 8);
    stream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&local_writeMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_reference;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_reference = reference;
    countingStream->rewind();
    {
        uint64_t cgen_var_513;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_513, 1);
        countingStream->write((uint64_t*)&cgen_var_513, 1 * 8);
        countingStream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&local_reference, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilReference = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilReference = OP_vkCmdSetStencilReference;
    stream->write(&opcode_vkCmdSetStencilReference, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilReference, sizeof(uint32_t));
    uint64_t cgen_var_514;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_514, 1);
    stream->write((uint64_t*)&cgen_var_514, 1 * 8);
    stream->write((VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&local_reference, sizeof(uint32_t));
}

void VkEncoder::vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_firstSet;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    uint32_t local_dynamicOffsetCount;
    uint32_t* local_pDynamicOffsets;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_firstSet = firstSet;
    local_descriptorSetCount = descriptorSetCount;
    local_pDescriptorSets = nullptr;
    if (pDescriptorSets)
    {
        local_pDescriptorSets = (VkDescriptorSet*)pool->dupArray(pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    local_dynamicOffsetCount = dynamicOffsetCount;
    local_pDynamicOffsets = nullptr;
    if (pDynamicOffsets)
    {
        local_pDynamicOffsets = (uint32_t*)pool->dupArray(pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_515;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_515, 1);
        countingStream->write((uint64_t*)&cgen_var_515, 1 * 8);
        countingStream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
        uint64_t cgen_var_516;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_516, 1);
        countingStream->write((uint64_t*)&cgen_var_516, 1 * 8);
        countingStream->write((uint32_t*)&local_firstSet, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
        if (((descriptorSetCount)))
        {
            uint64_t* cgen_var_517;
            countingStream->alloc((void**)&cgen_var_517, ((descriptorSetCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_517, ((descriptorSetCount)));
            countingStream->write((uint64_t*)cgen_var_517, ((descriptorSetCount)) * 8);
        }
        countingStream->write((uint32_t*)&local_dynamicOffsetCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)local_pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdBindDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindDescriptorSets = OP_vkCmdBindDescriptorSets;
    stream->write(&opcode_vkCmdBindDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindDescriptorSets, sizeof(uint32_t));
    uint64_t cgen_var_518;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_518, 1);
    stream->write((uint64_t*)&cgen_var_518, 1 * 8);
    stream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_519;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_519, 1);
    stream->write((uint64_t*)&cgen_var_519, 1 * 8);
    stream->write((uint32_t*)&local_firstSet, sizeof(uint32_t));
    stream->write((uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    if (((descriptorSetCount)))
    {
        uint64_t* cgen_var_520;
        stream->alloc((void**)&cgen_var_520, ((descriptorSetCount)) * 8);
        stream->handleMapping()->mapHandles_VkDescriptorSet_u64(local_pDescriptorSets, cgen_var_520, ((descriptorSetCount)));
        stream->write((uint64_t*)cgen_var_520, ((descriptorSetCount)) * 8);
    }
    stream->write((uint32_t*)&local_dynamicOffsetCount, sizeof(uint32_t));
    stream->write((uint32_t*)local_pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(uint32_t));
}

void VkEncoder::vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkIndexType local_indexType;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_indexType = indexType;
    countingStream->rewind();
    {
        uint64_t cgen_var_521;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_521, 1);
        countingStream->write((uint64_t*)&cgen_var_521, 1 * 8);
        uint64_t cgen_var_522;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_522, 1);
        countingStream->write((uint64_t*)&cgen_var_522, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        countingStream->write((VkIndexType*)&local_indexType, sizeof(VkIndexType));
    }
    uint32_t packetSize_vkCmdBindIndexBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindIndexBuffer = OP_vkCmdBindIndexBuffer;
    stream->write(&opcode_vkCmdBindIndexBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindIndexBuffer, sizeof(uint32_t));
    uint64_t cgen_var_523;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_523, 1);
    stream->write((uint64_t*)&cgen_var_523, 1 * 8);
    uint64_t cgen_var_524;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_524, 1);
    stream->write((uint64_t*)&cgen_var_524, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    stream->write((VkIndexType*)&local_indexType, sizeof(VkIndexType));
}

void VkEncoder::vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstBinding;
    uint32_t local_bindingCount;
    VkBuffer* local_pBuffers;
    VkDeviceSize* local_pOffsets;
    local_commandBuffer = commandBuffer;
    local_firstBinding = firstBinding;
    local_bindingCount = bindingCount;
    local_pBuffers = nullptr;
    if (pBuffers)
    {
        local_pBuffers = (VkBuffer*)pool->dupArray(pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
    }
    local_pOffsets = nullptr;
    if (pOffsets)
    {
        local_pOffsets = (VkDeviceSize*)pool->dupArray(pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_525;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_525, 1);
        countingStream->write((uint64_t*)&cgen_var_525, 1 * 8);
        countingStream->write((uint32_t*)&local_firstBinding, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_bindingCount, sizeof(uint32_t));
        if (((bindingCount)))
        {
            uint64_t* cgen_var_526;
            countingStream->alloc((void**)&cgen_var_526, ((bindingCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkBuffer_u64(local_pBuffers, cgen_var_526, ((bindingCount)));
            countingStream->write((uint64_t*)cgen_var_526, ((bindingCount)) * 8);
        }
        countingStream->write((VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkCmdBindVertexBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindVertexBuffers = OP_vkCmdBindVertexBuffers;
    stream->write(&opcode_vkCmdBindVertexBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindVertexBuffers, sizeof(uint32_t));
    uint64_t cgen_var_527;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_527, 1);
    stream->write((uint64_t*)&cgen_var_527, 1 * 8);
    stream->write((uint32_t*)&local_firstBinding, sizeof(uint32_t));
    stream->write((uint32_t*)&local_bindingCount, sizeof(uint32_t));
    if (((bindingCount)))
    {
        uint64_t* cgen_var_528;
        stream->alloc((void**)&cgen_var_528, ((bindingCount)) * 8);
        stream->handleMapping()->mapHandles_VkBuffer_u64(local_pBuffers, cgen_var_528, ((bindingCount)));
        stream->write((uint64_t*)cgen_var_528, ((bindingCount)) * 8);
    }
    stream->write((VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
}

void VkEncoder::vkCmdDraw(
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_vertexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstVertex;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_vertexCount = vertexCount;
    local_instanceCount = instanceCount;
    local_firstVertex = firstVertex;
    local_firstInstance = firstInstance;
    countingStream->rewind();
    {
        uint64_t cgen_var_529;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_529, 1);
        countingStream->write((uint64_t*)&cgen_var_529, 1 * 8);
        countingStream->write((uint32_t*)&local_vertexCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_firstVertex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDraw = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDraw = OP_vkCmdDraw;
    stream->write(&opcode_vkCmdDraw, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDraw, sizeof(uint32_t));
    uint64_t cgen_var_530;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_530, 1);
    stream->write((uint64_t*)&cgen_var_530, 1 * 8);
    stream->write((uint32_t*)&local_vertexCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_firstVertex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_indexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstIndex;
    int32_t local_vertexOffset;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_indexCount = indexCount;
    local_instanceCount = instanceCount;
    local_firstIndex = firstIndex;
    local_vertexOffset = vertexOffset;
    local_firstInstance = firstInstance;
    countingStream->rewind();
    {
        uint64_t cgen_var_531;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_531, 1);
        countingStream->write((uint64_t*)&cgen_var_531, 1 * 8);
        countingStream->write((uint32_t*)&local_indexCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_firstIndex, sizeof(uint32_t));
        countingStream->write((int32_t*)&local_vertexOffset, sizeof(int32_t));
        countingStream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexed = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexed = OP_vkCmdDrawIndexed;
    stream->write(&opcode_vkCmdDrawIndexed, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexed, sizeof(uint32_t));
    uint64_t cgen_var_532;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_532, 1);
    stream->write((uint64_t*)&cgen_var_532, 1 * 8);
    stream->write((uint32_t*)&local_indexCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_instanceCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_firstIndex, sizeof(uint32_t));
    stream->write((int32_t*)&local_vertexOffset, sizeof(int32_t));
    stream->write((uint32_t*)&local_firstInstance, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_533;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_533, 1);
        countingStream->write((uint64_t*)&cgen_var_533, 1 * 8);
        uint64_t cgen_var_534;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_534, 1);
        countingStream->write((uint64_t*)&cgen_var_534, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirect = OP_vkCmdDrawIndirect;
    stream->write(&opcode_vkCmdDrawIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirect, sizeof(uint32_t));
    uint64_t cgen_var_535;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_535, 1);
    stream->write((uint64_t*)&cgen_var_535, 1 * 8);
    uint64_t cgen_var_536;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_536, 1);
    stream->write((uint64_t*)&cgen_var_536, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_537;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_537, 1);
        countingStream->write((uint64_t*)&cgen_var_537, 1 * 8);
        uint64_t cgen_var_538;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_538, 1);
        countingStream->write((uint64_t*)&cgen_var_538, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirect = OP_vkCmdDrawIndexedIndirect;
    stream->write(&opcode_vkCmdDrawIndexedIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirect, sizeof(uint32_t));
    uint64_t cgen_var_539;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_539, 1);
    stream->write((uint64_t*)&cgen_var_539, 1 * 8);
    uint64_t cgen_var_540;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_540, 1);
    stream->write((uint64_t*)&cgen_var_540, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_drawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    countingStream->rewind();
    {
        uint64_t cgen_var_541;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_541, 1);
        countingStream->write((uint64_t*)&cgen_var_541, 1 * 8);
        countingStream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatch = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatch = OP_vkCmdDispatch;
    stream->write(&opcode_vkCmdDispatch, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatch, sizeof(uint32_t));
    uint64_t cgen_var_542;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_542, 1);
    stream->write((uint64_t*)&cgen_var_542, 1 * 8);
    stream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    countingStream->rewind();
    {
        uint64_t cgen_var_543;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_543, 1);
        countingStream->write((uint64_t*)&cgen_var_543, 1 * 8);
        uint64_t cgen_var_544;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_544, 1);
        countingStream->write((uint64_t*)&cgen_var_544, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkCmdDispatchIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchIndirect = OP_vkCmdDispatchIndirect;
    stream->write(&opcode_vkCmdDispatchIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchIndirect, sizeof(uint32_t));
    uint64_t cgen_var_545;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_545, 1);
    stream->write((uint64_t*)&cgen_var_545, 1 * 8);
    uint64_t cgen_var_546;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_546, 1);
    stream->write((uint64_t*)&cgen_var_546, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
}

void VkEncoder::vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferCopy(pool, pRegions + i, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferCopy(mImpl->resources(), (VkBufferCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_547;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_547, 1);
        countingStream->write((uint64_t*)&cgen_var_547, 1 * 8);
        uint64_t cgen_var_548;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_548, 1);
        countingStream->write((uint64_t*)&cgen_var_548, 1 * 8);
        uint64_t cgen_var_549;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_549, 1);
        countingStream->write((uint64_t*)&cgen_var_549, 1 * 8);
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferCopy(countingStream, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyBuffer = OP_vkCmdCopyBuffer;
    stream->write(&opcode_vkCmdCopyBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyBuffer, sizeof(uint32_t));
    uint64_t cgen_var_550;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_550, 1);
    stream->write((uint64_t*)&cgen_var_550, 1 * 8);
    uint64_t cgen_var_551;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_551, 1);
    stream->write((uint64_t*)&cgen_var_551, 1 * 8);
    uint64_t cgen_var_552;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_552, 1);
    stream->write((uint64_t*)&cgen_var_552, 1 * 8);
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferCopy(stream, (VkBufferCopy*)(local_pRegions + i));
    }
}

void VkEncoder::vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageCopy(pool, pRegions + i, (VkImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageCopy(mImpl->resources(), (VkImageCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_553;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_553, 1);
        countingStream->write((uint64_t*)&cgen_var_553, 1 * 8);
        uint64_t cgen_var_554;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_554, 1);
        countingStream->write((uint64_t*)&cgen_var_554, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_555;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_555, 1);
        countingStream->write((uint64_t*)&cgen_var_555, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageCopy(countingStream, (VkImageCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyImage = OP_vkCmdCopyImage;
    stream->write(&opcode_vkCmdCopyImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyImage, sizeof(uint32_t));
    uint64_t cgen_var_556;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_556, 1);
    stream->write((uint64_t*)&cgen_var_556, 1 * 8);
    uint64_t cgen_var_557;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_557, 1);
    stream->write((uint64_t*)&cgen_var_557, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_558;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_558, 1);
    stream->write((uint64_t*)&cgen_var_558, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageCopy(stream, (VkImageCopy*)(local_pRegions + i));
    }
}

void VkEncoder::vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageBlit* local_pRegions;
    VkFilter local_filter;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageBlit*)pool->alloc(((regionCount)) * sizeof(const VkImageBlit));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageBlit(pool, pRegions + i, (VkImageBlit*)(local_pRegions + i));
        }
    }
    local_filter = filter;
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageBlit(mImpl->resources(), (VkImageBlit*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_559;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_559, 1);
        countingStream->write((uint64_t*)&cgen_var_559, 1 * 8);
        uint64_t cgen_var_560;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_560, 1);
        countingStream->write((uint64_t*)&cgen_var_560, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_561;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_561, 1);
        countingStream->write((uint64_t*)&cgen_var_561, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageBlit(countingStream, (VkImageBlit*)(local_pRegions + i));
        }
        countingStream->write((VkFilter*)&local_filter, sizeof(VkFilter));
    }
    uint32_t packetSize_vkCmdBlitImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBlitImage = OP_vkCmdBlitImage;
    stream->write(&opcode_vkCmdBlitImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBlitImage, sizeof(uint32_t));
    uint64_t cgen_var_562;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_562, 1);
    stream->write((uint64_t*)&cgen_var_562, 1 * 8);
    uint64_t cgen_var_563;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_563, 1);
    stream->write((uint64_t*)&cgen_var_563, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_564;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_564, 1);
    stream->write((uint64_t*)&cgen_var_564, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageBlit(stream, (VkImageBlit*)(local_pRegions + i));
    }
    stream->write((VkFilter*)&local_filter, sizeof(VkFilter));
}

void VkEncoder::vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(mImpl->resources(), (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_565;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_565, 1);
        countingStream->write((uint64_t*)&cgen_var_565, 1 * 8);
        uint64_t cgen_var_566;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_566, 1);
        countingStream->write((uint64_t*)&cgen_var_566, 1 * 8);
        uint64_t cgen_var_567;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_567, 1);
        countingStream->write((uint64_t*)&cgen_var_567, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferImageCopy(countingStream, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyBufferToImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyBufferToImage = OP_vkCmdCopyBufferToImage;
    stream->write(&opcode_vkCmdCopyBufferToImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyBufferToImage, sizeof(uint32_t));
    uint64_t cgen_var_568;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_568, 1);
    stream->write((uint64_t*)&cgen_var_568, 1 * 8);
    uint64_t cgen_var_569;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_srcBuffer, &cgen_var_569, 1);
    stream->write((uint64_t*)&cgen_var_569, 1 * 8);
    uint64_t cgen_var_570;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_570, 1);
    stream->write((uint64_t*)&cgen_var_570, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(stream, (VkBufferImageCopy*)(local_pRegions + i));
    }
}

void VkEncoder::vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(mImpl->resources(), (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_571;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_571, 1);
        countingStream->write((uint64_t*)&cgen_var_571, 1 * 8);
        uint64_t cgen_var_572;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_572, 1);
        countingStream->write((uint64_t*)&cgen_var_572, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_573;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_573, 1);
        countingStream->write((uint64_t*)&cgen_var_573, 1 * 8);
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferImageCopy(countingStream, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyImageToBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyImageToBuffer = OP_vkCmdCopyImageToBuffer;
    stream->write(&opcode_vkCmdCopyImageToBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyImageToBuffer, sizeof(uint32_t));
    uint64_t cgen_var_574;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_574, 1);
    stream->write((uint64_t*)&cgen_var_574, 1 * 8);
    uint64_t cgen_var_575;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_575, 1);
    stream->write((uint64_t*)&cgen_var_575, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_576;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_576, 1);
    stream->write((uint64_t*)&cgen_var_576, 1 * 8);
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(stream, (VkBufferImageCopy*)(local_pRegions + i));
    }
}

void VkEncoder::vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_dataSize;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_dataSize = dataSize;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, ((dataSize)) * sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_577;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_577, 1);
        countingStream->write((uint64_t*)&cgen_var_577, 1 * 8);
        uint64_t cgen_var_578;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_578, 1);
        countingStream->write((uint64_t*)&cgen_var_578, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&local_dataSize, sizeof(VkDeviceSize));
        countingStream->write((void*)local_pData, ((dataSize)) * sizeof(uint8_t));
    }
    uint32_t packetSize_vkCmdUpdateBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdUpdateBuffer = OP_vkCmdUpdateBuffer;
    stream->write(&opcode_vkCmdUpdateBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdUpdateBuffer, sizeof(uint32_t));
    uint64_t cgen_var_579;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_579, 1);
    stream->write((uint64_t*)&cgen_var_579, 1 * 8);
    uint64_t cgen_var_580;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_580, 1);
    stream->write((uint64_t*)&cgen_var_580, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&local_dataSize, sizeof(VkDeviceSize));
    stream->write((void*)local_pData, ((dataSize)) * sizeof(uint8_t));
}

void VkEncoder::vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_size;
    uint32_t local_data;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_size = size;
    local_data = data;
    countingStream->rewind();
    {
        uint64_t cgen_var_581;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_581, 1);
        countingStream->write((uint64_t*)&cgen_var_581, 1 * 8);
        uint64_t cgen_var_582;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_582, 1);
        countingStream->write((uint64_t*)&cgen_var_582, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&local_size, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_data, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdFillBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdFillBuffer = OP_vkCmdFillBuffer;
    stream->write(&opcode_vkCmdFillBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdFillBuffer, sizeof(uint32_t));
    uint64_t cgen_var_583;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_583, 1);
    stream->write((uint64_t*)&cgen_var_583, 1 * 8);
    uint64_t cgen_var_584;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_584, 1);
    stream->write((uint64_t*)&cgen_var_584, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&local_size, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_data, sizeof(uint32_t));
}

void VkEncoder::vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearColorValue* local_pColor;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pColor = nullptr;
    if (pColor)
    {
        local_pColor = (VkClearColorValue*)pool->alloc(sizeof(const VkClearColorValue));
        deepcopy_VkClearColorValue(pool, pColor, (VkClearColorValue*)(local_pColor));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pColor)
    {
        transform_tohost_VkClearColorValue(mImpl->resources(), (VkClearColorValue*)(local_pColor));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(mImpl->resources(), (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_585;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_585, 1);
        countingStream->write((uint64_t*)&cgen_var_585, 1 * 8);
        uint64_t cgen_var_586;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_586, 1);
        countingStream->write((uint64_t*)&cgen_var_586, 1 * 8);
        countingStream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
        marshal_VkClearColorValue(countingStream, (VkClearColorValue*)(local_pColor));
        countingStream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            marshal_VkImageSubresourceRange(countingStream, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    uint32_t packetSize_vkCmdClearColorImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearColorImage = OP_vkCmdClearColorImage;
    stream->write(&opcode_vkCmdClearColorImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearColorImage, sizeof(uint32_t));
    uint64_t cgen_var_587;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_587, 1);
    stream->write((uint64_t*)&cgen_var_587, 1 * 8);
    uint64_t cgen_var_588;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_588, 1);
    stream->write((uint64_t*)&cgen_var_588, 1 * 8);
    stream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    marshal_VkClearColorValue(stream, (VkClearColorValue*)(local_pColor));
    stream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(stream, (VkImageSubresourceRange*)(local_pRanges + i));
    }
}

void VkEncoder::vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearDepthStencilValue* local_pDepthStencil;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pDepthStencil = nullptr;
    if (pDepthStencil)
    {
        local_pDepthStencil = (VkClearDepthStencilValue*)pool->alloc(sizeof(const VkClearDepthStencilValue));
        deepcopy_VkClearDepthStencilValue(pool, pDepthStencil, (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pDepthStencil)
    {
        transform_tohost_VkClearDepthStencilValue(mImpl->resources(), (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(mImpl->resources(), (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_589;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_589, 1);
        countingStream->write((uint64_t*)&cgen_var_589, 1 * 8);
        uint64_t cgen_var_590;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_590, 1);
        countingStream->write((uint64_t*)&cgen_var_590, 1 * 8);
        countingStream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
        marshal_VkClearDepthStencilValue(countingStream, (VkClearDepthStencilValue*)(local_pDepthStencil));
        countingStream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            marshal_VkImageSubresourceRange(countingStream, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    uint32_t packetSize_vkCmdClearDepthStencilImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearDepthStencilImage = OP_vkCmdClearDepthStencilImage;
    stream->write(&opcode_vkCmdClearDepthStencilImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearDepthStencilImage, sizeof(uint32_t));
    uint64_t cgen_var_591;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_591, 1);
    stream->write((uint64_t*)&cgen_var_591, 1 * 8);
    uint64_t cgen_var_592;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_592, 1);
    stream->write((uint64_t*)&cgen_var_592, 1 * 8);
    stream->write((VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    marshal_VkClearDepthStencilValue(stream, (VkClearDepthStencilValue*)(local_pDepthStencil));
    stream->write((uint32_t*)&local_rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(stream, (VkImageSubresourceRange*)(local_pRanges + i));
    }
}

void VkEncoder::vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_attachmentCount;
    VkClearAttachment* local_pAttachments;
    uint32_t local_rectCount;
    VkClearRect* local_pRects;
    local_commandBuffer = commandBuffer;
    local_attachmentCount = attachmentCount;
    local_pAttachments = nullptr;
    if (pAttachments)
    {
        local_pAttachments = (VkClearAttachment*)pool->alloc(((attachmentCount)) * sizeof(const VkClearAttachment));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            deepcopy_VkClearAttachment(pool, pAttachments + i, (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    local_rectCount = rectCount;
    local_pRects = nullptr;
    if (pRects)
    {
        local_pRects = (VkClearRect*)pool->alloc(((rectCount)) * sizeof(const VkClearRect));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            deepcopy_VkClearRect(pool, pRects + i, (VkClearRect*)(local_pRects + i));
        }
    }
    if (local_pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            transform_tohost_VkClearAttachment(mImpl->resources(), (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    if (local_pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            transform_tohost_VkClearRect(mImpl->resources(), (VkClearRect*)(local_pRects + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_593;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_593, 1);
        countingStream->write((uint64_t*)&cgen_var_593, 1 * 8);
        countingStream->write((uint32_t*)&local_attachmentCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            marshal_VkClearAttachment(countingStream, (VkClearAttachment*)(local_pAttachments + i));
        }
        countingStream->write((uint32_t*)&local_rectCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            marshal_VkClearRect(countingStream, (VkClearRect*)(local_pRects + i));
        }
    }
    uint32_t packetSize_vkCmdClearAttachments = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearAttachments = OP_vkCmdClearAttachments;
    stream->write(&opcode_vkCmdClearAttachments, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearAttachments, sizeof(uint32_t));
    uint64_t cgen_var_594;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_594, 1);
    stream->write((uint64_t*)&cgen_var_594, 1 * 8);
    stream->write((uint32_t*)&local_attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        marshal_VkClearAttachment(stream, (VkClearAttachment*)(local_pAttachments + i));
    }
    stream->write((uint32_t*)&local_rectCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        marshal_VkClearRect(stream, (VkClearRect*)(local_pRects + i));
    }
}

void VkEncoder::vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageResolve* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageResolve*)pool->alloc(((regionCount)) * sizeof(const VkImageResolve));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageResolve(pool, pRegions + i, (VkImageResolve*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageResolve(mImpl->resources(), (VkImageResolve*)(local_pRegions + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_595;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_595, 1);
        countingStream->write((uint64_t*)&cgen_var_595, 1 * 8);
        uint64_t cgen_var_596;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_596, 1);
        countingStream->write((uint64_t*)&cgen_var_596, 1 * 8);
        countingStream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
        uint64_t cgen_var_597;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_597, 1);
        countingStream->write((uint64_t*)&cgen_var_597, 1 * 8);
        countingStream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageResolve(countingStream, (VkImageResolve*)(local_pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdResolveImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResolveImage = OP_vkCmdResolveImage;
    stream->write(&opcode_vkCmdResolveImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResolveImage, sizeof(uint32_t));
    uint64_t cgen_var_598;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_598, 1);
    stream->write((uint64_t*)&cgen_var_598, 1 * 8);
    uint64_t cgen_var_599;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_srcImage, &cgen_var_599, 1);
    stream->write((uint64_t*)&cgen_var_599, 1 * 8);
    stream->write((VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    uint64_t cgen_var_600;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_dstImage, &cgen_var_600, 1);
    stream->write((uint64_t*)&cgen_var_600, 1 * 8);
    stream->write((VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&local_regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageResolve(stream, (VkImageResolve*)(local_pRegions + i));
    }
}

void VkEncoder::vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_601;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_601, 1);
        countingStream->write((uint64_t*)&cgen_var_601, 1 * 8);
        uint64_t cgen_var_602;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_602, 1);
        countingStream->write((uint64_t*)&cgen_var_602, 1 * 8);
        countingStream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    }
    uint32_t packetSize_vkCmdSetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetEvent = OP_vkCmdSetEvent;
    stream->write(&opcode_vkCmdSetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetEvent, sizeof(uint32_t));
    uint64_t cgen_var_603;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_603, 1);
    stream->write((uint64_t*)&cgen_var_603, 1 * 8);
    uint64_t cgen_var_604;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_604, 1);
    stream->write((uint64_t*)&cgen_var_604, 1 * 8);
    stream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
}

void VkEncoder::vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_605;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_605, 1);
        countingStream->write((uint64_t*)&cgen_var_605, 1 * 8);
        uint64_t cgen_var_606;
        countingStream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_606, 1);
        countingStream->write((uint64_t*)&cgen_var_606, 1 * 8);
        countingStream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    }
    uint32_t packetSize_vkCmdResetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResetEvent = OP_vkCmdResetEvent;
    stream->write(&opcode_vkCmdResetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResetEvent, sizeof(uint32_t));
    uint64_t cgen_var_607;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_607, 1);
    stream->write((uint64_t*)&cgen_var_607, 1 * 8);
    uint64_t cgen_var_608;
    stream->handleMapping()->mapHandles_VkEvent_u64(&local_event, &cgen_var_608, 1);
    stream->write((uint64_t*)&cgen_var_608, 1 * 8);
    stream->write((VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
}

void VkEncoder::vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_eventCount;
    VkEvent* local_pEvents;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_eventCount = eventCount;
    local_pEvents = nullptr;
    if (pEvents)
    {
        local_pEvents = (VkEvent*)pool->dupArray(pEvents, ((eventCount)) * sizeof(const VkEvent));
    }
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(mImpl->resources(), (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(mImpl->resources(), (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(mImpl->resources(), (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_609;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_609, 1);
        countingStream->write((uint64_t*)&cgen_var_609, 1 * 8);
        countingStream->write((uint32_t*)&local_eventCount, sizeof(uint32_t));
        if (((eventCount)))
        {
            uint64_t* cgen_var_610;
            countingStream->alloc((void**)&cgen_var_610, ((eventCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkEvent_u64(local_pEvents, cgen_var_610, ((eventCount)));
            countingStream->write((uint64_t*)cgen_var_610, ((eventCount)) * 8);
        }
        countingStream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            marshal_VkMemoryBarrier(countingStream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            marshal_VkBufferMemoryBarrier(countingStream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            marshal_VkImageMemoryBarrier(countingStream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    uint32_t packetSize_vkCmdWaitEvents = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWaitEvents = OP_vkCmdWaitEvents;
    stream->write(&opcode_vkCmdWaitEvents, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWaitEvents, sizeof(uint32_t));
    uint64_t cgen_var_611;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_611, 1);
    stream->write((uint64_t*)&cgen_var_611, 1 * 8);
    stream->write((uint32_t*)&local_eventCount, sizeof(uint32_t));
    if (((eventCount)))
    {
        uint64_t* cgen_var_612;
        stream->alloc((void**)&cgen_var_612, ((eventCount)) * 8);
        stream->handleMapping()->mapHandles_VkEvent_u64(local_pEvents, cgen_var_612, ((eventCount)));
        stream->write((uint64_t*)cgen_var_612, ((eventCount)) * 8);
    }
    stream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    stream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(stream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(stream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(stream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
    }
}

void VkEncoder::vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    VkDependencyFlags local_dependencyFlags;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_dependencyFlags = dependencyFlags;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(mImpl->resources(), (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(mImpl->resources(), (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(mImpl->resources(), (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_613;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_613, 1);
        countingStream->write((uint64_t*)&cgen_var_613, 1 * 8);
        countingStream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkDependencyFlags*)&local_dependencyFlags, sizeof(VkDependencyFlags));
        countingStream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            marshal_VkMemoryBarrier(countingStream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            marshal_VkBufferMemoryBarrier(countingStream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            marshal_VkImageMemoryBarrier(countingStream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    uint32_t packetSize_vkCmdPipelineBarrier = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPipelineBarrier = OP_vkCmdPipelineBarrier;
    stream->write(&opcode_vkCmdPipelineBarrier, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPipelineBarrier, sizeof(uint32_t));
    uint64_t cgen_var_614;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_614, 1);
    stream->write((uint64_t*)&cgen_var_614, 1 * 8);
    stream->write((VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkDependencyFlags*)&local_dependencyFlags, sizeof(VkDependencyFlags));
    stream->write((uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(stream, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(stream, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
    }
    stream->write((uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(stream, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
    }
}

void VkEncoder::vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    VkQueryControlFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_615;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_615, 1);
        countingStream->write((uint64_t*)&cgen_var_615, 1 * 8);
        uint64_t cgen_var_616;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_616, 1);
        countingStream->write((uint64_t*)&cgen_var_616, 1 * 8);
        countingStream->write((uint32_t*)&local_query, sizeof(uint32_t));
        countingStream->write((VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
    }
    uint32_t packetSize_vkCmdBeginQuery = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginQuery = OP_vkCmdBeginQuery;
    stream->write(&opcode_vkCmdBeginQuery, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginQuery, sizeof(uint32_t));
    uint64_t cgen_var_617;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_617, 1);
    stream->write((uint64_t*)&cgen_var_617, 1 * 8);
    uint64_t cgen_var_618;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_618, 1);
    stream->write((uint64_t*)&cgen_var_618, 1 * 8);
    stream->write((uint32_t*)&local_query, sizeof(uint32_t));
    stream->write((VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
}

void VkEncoder::vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    countingStream->rewind();
    {
        uint64_t cgen_var_619;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_619, 1);
        countingStream->write((uint64_t*)&cgen_var_619, 1 * 8);
        uint64_t cgen_var_620;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_620, 1);
        countingStream->write((uint64_t*)&cgen_var_620, 1 * 8);
        countingStream->write((uint32_t*)&local_query, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdEndQuery = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndQuery = OP_vkCmdEndQuery;
    stream->write(&opcode_vkCmdEndQuery, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndQuery, sizeof(uint32_t));
    uint64_t cgen_var_621;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_621, 1);
    stream->write((uint64_t*)&cgen_var_621, 1 * 8);
    uint64_t cgen_var_622;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_622, 1);
    stream->write((uint64_t*)&cgen_var_622, 1 * 8);
    stream->write((uint32_t*)&local_query, sizeof(uint32_t));
}

void VkEncoder::vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    countingStream->rewind();
    {
        uint64_t cgen_var_623;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_623, 1);
        countingStream->write((uint64_t*)&cgen_var_623, 1 * 8);
        uint64_t cgen_var_624;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_624, 1);
        countingStream->write((uint64_t*)&cgen_var_624, 1 * 8);
        countingStream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdResetQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResetQueryPool = OP_vkCmdResetQueryPool;
    stream->write(&opcode_vkCmdResetQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResetQueryPool, sizeof(uint32_t));
    uint64_t cgen_var_625;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_625, 1);
    stream->write((uint64_t*)&cgen_var_625, 1 * 8);
    uint64_t cgen_var_626;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_626, 1);
    stream->write((uint64_t*)&cgen_var_626, 1 * 8);
    stream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
}

void VkEncoder::vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_queryPool = queryPool;
    local_query = query;
    countingStream->rewind();
    {
        uint64_t cgen_var_627;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_627, 1);
        countingStream->write((uint64_t*)&cgen_var_627, 1 * 8);
        countingStream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
        uint64_t cgen_var_628;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_628, 1);
        countingStream->write((uint64_t*)&cgen_var_628, 1 * 8);
        countingStream->write((uint32_t*)&local_query, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdWriteTimestamp = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWriteTimestamp = OP_vkCmdWriteTimestamp;
    stream->write(&opcode_vkCmdWriteTimestamp, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWriteTimestamp, sizeof(uint32_t));
    uint64_t cgen_var_629;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_629, 1);
    stream->write((uint64_t*)&cgen_var_629, 1 * 8);
    stream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    uint64_t cgen_var_630;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_630, 1);
    stream->write((uint64_t*)&cgen_var_630, 1 * 8);
    stream->write((uint32_t*)&local_query, sizeof(uint32_t));
}

void VkEncoder::vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_stride = stride;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_631;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_631, 1);
        countingStream->write((uint64_t*)&cgen_var_631, 1 * 8);
        uint64_t cgen_var_632;
        countingStream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_632, 1);
        countingStream->write((uint64_t*)&cgen_var_632, 1 * 8);
        countingStream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
        uint64_t cgen_var_633;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_633, 1);
        countingStream->write((uint64_t*)&cgen_var_633, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
        countingStream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    }
    uint32_t packetSize_vkCmdCopyQueryPoolResults = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyQueryPoolResults = OP_vkCmdCopyQueryPoolResults;
    stream->write(&opcode_vkCmdCopyQueryPoolResults, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyQueryPoolResults, sizeof(uint32_t));
    uint64_t cgen_var_634;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_634, 1);
    stream->write((uint64_t*)&cgen_var_634, 1 * 8);
    uint64_t cgen_var_635;
    stream->handleMapping()->mapHandles_VkQueryPool_u64(&local_queryPool, &cgen_var_635, 1);
    stream->write((uint64_t*)&cgen_var_635, 1 * 8);
    stream->write((uint32_t*)&local_firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&local_queryCount, sizeof(uint32_t));
    uint64_t cgen_var_636;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_636, 1);
    stream->write((uint64_t*)&cgen_var_636, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    stream->write((VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
}

void VkEncoder::vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineLayout local_layout;
    VkShaderStageFlags local_stageFlags;
    uint32_t local_offset;
    uint32_t local_size;
    void* local_pValues;
    local_commandBuffer = commandBuffer;
    local_layout = layout;
    local_stageFlags = stageFlags;
    local_offset = offset;
    local_size = size;
    local_pValues = nullptr;
    if (pValues)
    {
        local_pValues = (void*)pool->dupArray(pValues, ((size)) * sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_637;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_637, 1);
        countingStream->write((uint64_t*)&cgen_var_637, 1 * 8);
        uint64_t cgen_var_638;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_638, 1);
        countingStream->write((uint64_t*)&cgen_var_638, 1 * 8);
        countingStream->write((VkShaderStageFlags*)&local_stageFlags, sizeof(VkShaderStageFlags));
        countingStream->write((uint32_t*)&local_offset, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_size, sizeof(uint32_t));
        countingStream->write((void*)local_pValues, ((size)) * sizeof(uint8_t));
    }
    uint32_t packetSize_vkCmdPushConstants = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushConstants = OP_vkCmdPushConstants;
    stream->write(&opcode_vkCmdPushConstants, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushConstants, sizeof(uint32_t));
    uint64_t cgen_var_639;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_639, 1);
    stream->write((uint64_t*)&cgen_var_639, 1 * 8);
    uint64_t cgen_var_640;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_640, 1);
    stream->write((uint64_t*)&cgen_var_640, 1 * 8);
    stream->write((VkShaderStageFlags*)&local_stageFlags, sizeof(VkShaderStageFlags));
    stream->write((uint32_t*)&local_offset, sizeof(uint32_t));
    stream->write((uint32_t*)&local_size, sizeof(uint32_t));
    stream->write((void*)local_pValues, ((size)) * sizeof(uint8_t));
}

void VkEncoder::vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_contents = contents;
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(mImpl->resources(), (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_641;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_641, 1);
        countingStream->write((uint64_t*)&cgen_var_641, 1 * 8);
        marshal_VkRenderPassBeginInfo(countingStream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
        countingStream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    }
    uint32_t packetSize_vkCmdBeginRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginRenderPass = OP_vkCmdBeginRenderPass;
    stream->write(&opcode_vkCmdBeginRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_642;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_642, 1);
    stream->write((uint64_t*)&cgen_var_642, 1 * 8);
    marshal_VkRenderPassBeginInfo(stream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    stream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
}

void VkEncoder::vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_contents = contents;
    countingStream->rewind();
    {
        uint64_t cgen_var_643;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_643, 1);
        countingStream->write((uint64_t*)&cgen_var_643, 1 * 8);
        countingStream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    }
    uint32_t packetSize_vkCmdNextSubpass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdNextSubpass = OP_vkCmdNextSubpass;
    stream->write(&opcode_vkCmdNextSubpass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdNextSubpass, sizeof(uint32_t));
    uint64_t cgen_var_644;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_644, 1);
    stream->write((uint64_t*)&cgen_var_644, 1 * 8);
    stream->write((VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
}

void VkEncoder::vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_645;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_645, 1);
        countingStream->write((uint64_t*)&cgen_var_645, 1 * 8);
    }
    uint32_t packetSize_vkCmdEndRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndRenderPass = OP_vkCmdEndRenderPass;
    stream->write(&opcode_vkCmdEndRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndRenderPass, sizeof(uint32_t));
    uint64_t cgen_var_646;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_646, 1);
    stream->write((uint64_t*)&cgen_var_646, 1 * 8);
}

void VkEncoder::vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_commandBuffer = commandBuffer;
    local_commandBufferCount = commandBufferCount;
    local_pCommandBuffers = nullptr;
    if (pCommandBuffers)
    {
        local_pCommandBuffers = (VkCommandBuffer*)pool->dupArray(pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_647;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_647, 1);
        countingStream->write((uint64_t*)&cgen_var_647, 1 * 8);
        countingStream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
        if (((commandBufferCount)))
        {
            uint64_t* cgen_var_648;
            countingStream->alloc((void**)&cgen_var_648, ((commandBufferCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_648, ((commandBufferCount)));
            countingStream->write((uint64_t*)cgen_var_648, ((commandBufferCount)) * 8);
        }
    }
    uint32_t packetSize_vkCmdExecuteCommands = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdExecuteCommands = OP_vkCmdExecuteCommands;
    stream->write(&opcode_vkCmdExecuteCommands, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdExecuteCommands, sizeof(uint32_t));
    uint64_t cgen_var_649;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_649, 1);
    stream->write((uint64_t*)&cgen_var_649, 1 * 8);
    stream->write((uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    if (((commandBufferCount)))
    {
        uint64_t* cgen_var_650;
        stream->alloc((void**)&cgen_var_650, ((commandBufferCount)) * 8);
        stream->handleMapping()->mapHandles_VkCommandBuffer_u64(local_pCommandBuffers, cgen_var_650, ((commandBufferCount)));
        stream->write((uint64_t*)cgen_var_650, ((commandBufferCount)) * 8);
    }
}

#endif
#ifdef VK_VERSION_1_1
VkResult VkEncoder::vkEnumerateInstanceVersion(
    uint32_t* pApiVersion)
{
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    vkEnumerateInstanceVersion_VkResult_return = mImpl->resources()->on_vkEnumerateInstanceVersion(this, VK_SUCCESS, pApiVersion);
    return vkEnumerateInstanceVersion_VkResult_return;
}

VkResult VkEncoder::vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(mImpl->resources(), (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_651;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_651, 1);
        countingStream->write((uint64_t*)&cgen_var_651, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindBufferMemoryInfo(countingStream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindBufferMemory2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory2 = OP_vkBindBufferMemory2;
    stream->write(&opcode_vkBindBufferMemory2, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory2, sizeof(uint32_t));
    uint64_t cgen_var_652;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_652, 1);
    stream->write((uint64_t*)&cgen_var_652, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(stream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
    }
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBindBufferMemory2_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(mImpl->resources(), (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_653;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_653, 1);
        countingStream->write((uint64_t*)&cgen_var_653, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindImageMemoryInfo(countingStream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindImageMemory2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory2 = OP_vkBindImageMemory2;
    stream->write(&opcode_vkBindImageMemory2, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory2, sizeof(uint32_t));
    uint64_t cgen_var_654;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_654, 1);
    stream->write((uint64_t*)&cgen_var_654, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(stream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
    }
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBindImageMemory2_VkResult_return;
}

void VkEncoder::vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_655;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_655, 1);
        countingStream->write((uint64_t*)&cgen_var_655, 1 * 8);
        countingStream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
        countingStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeatures = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeatures = OP_vkGetDeviceGroupPeerMemoryFeatures;
    stream->write(&opcode_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t));
    uint64_t cgen_var_656;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_656, 1);
    stream->write((uint64_t*)&cgen_var_656, 1 * 8);
    stream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    stream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void VkEncoder::vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_657;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_657, 1);
        countingStream->write((uint64_t*)&cgen_var_657, 1 * 8);
        countingStream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetDeviceMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDeviceMask = OP_vkCmdSetDeviceMask;
    stream->write(&opcode_vkCmdSetDeviceMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDeviceMask, sizeof(uint32_t));
    uint64_t cgen_var_658;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_658, 1);
    stream->write((uint64_t*)&cgen_var_658, 1 * 8);
    stream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    countingStream->rewind();
    {
        uint64_t cgen_var_659;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_659, 1);
        countingStream->write((uint64_t*)&cgen_var_659, 1 * 8);
        countingStream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatchBase = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchBase = OP_vkCmdDispatchBase;
    stream->write(&opcode_vkCmdDispatchBase, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchBase, sizeof(uint32_t));
    uint64_t cgen_var_660;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_660, 1);
    stream->write((uint64_t*)&cgen_var_660, 1 * 8);
    stream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
}

VkResult VkEncoder::vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    local_instance = instance;
    countingStream->rewind();
    {
        uint64_t cgen_var_661;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_661, 1);
        countingStream->write((uint64_t*)&cgen_var_661, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_662 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
        countingStream->putBe64(cgen_var_662);
        if (pPhysicalDeviceGroupCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_663 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
        countingStream->putBe64(cgen_var_663);
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                marshal_VkPhysicalDeviceGroupProperties(countingStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroups = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDeviceGroups = OP_vkEnumeratePhysicalDeviceGroups;
    stream->write(&opcode_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t));
    uint64_t cgen_var_664;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_664, 1);
    stream->write((uint64_t*)&cgen_var_664, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_665 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    stream->putBe64(cgen_var_665);
    if (pPhysicalDeviceGroupCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_666 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    stream->putBe64(cgen_var_666);
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            marshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            transform_fromhost_VkPhysicalDeviceGroupProperties(mImpl->resources(), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

void VkEncoder::vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(mImpl->resources(), (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_669;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_669, 1);
        countingStream->write((uint64_t*)&cgen_var_669, 1 * 8);
        marshal_VkImageMemoryRequirementsInfo2(countingStream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements2 = OP_vkGetImageMemoryRequirements2;
    stream->write(&opcode_vkGetImageMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements2, sizeof(uint32_t));
    uint64_t cgen_var_670;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_670, 1);
    stream->write((uint64_t*)&cgen_var_670, 1 * 8);
    marshal_VkImageMemoryRequirementsInfo2(stream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
}

void VkEncoder::vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(mImpl->resources(), (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_671;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_671, 1);
        countingStream->write((uint64_t*)&cgen_var_671, 1 * 8);
        marshal_VkBufferMemoryRequirementsInfo2(countingStream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements2 = OP_vkGetBufferMemoryRequirements2;
    stream->write(&opcode_vkGetBufferMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements2, sizeof(uint32_t));
    uint64_t cgen_var_672;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_672, 1);
    stream->write((uint64_t*)&cgen_var_672, 1 * 8);
    marshal_VkBufferMemoryRequirementsInfo2(stream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
}

void VkEncoder::vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(mImpl->resources(), (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_673;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_673, 1);
        countingStream->write((uint64_t*)&cgen_var_673, 1 * 8);
        marshal_VkImageSparseMemoryRequirementsInfo2(countingStream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_674 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
        countingStream->putBe64(cgen_var_674);
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_675 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
        countingStream->putBe64(cgen_var_675);
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements2(countingStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements2 = OP_vkGetImageSparseMemoryRequirements2;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t));
    uint64_t cgen_var_676;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_676, 1);
    stream->write((uint64_t*)&cgen_var_676, 1 * 8);
    marshal_VkImageSparseMemoryRequirementsInfo2(stream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_677 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    stream->putBe64(cgen_var_677);
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_678 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    stream->putBe64(cgen_var_678);
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements2(mImpl->resources(), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_681;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_681, 1);
        countingStream->write((uint64_t*)&cgen_var_681, 1 * 8);
        marshal_VkPhysicalDeviceFeatures2(countingStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures2 = OP_vkGetPhysicalDeviceFeatures2;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t));
    uint64_t cgen_var_682;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_682, 1);
    stream->write((uint64_t*)&cgen_var_682, 1 * 8);
    marshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(mImpl->resources(), (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
}

void VkEncoder::vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    mImpl->resources()->on_vkGetPhysicalDeviceProperties2(this, physicalDevice, pProperties);
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    countingStream->rewind();
    {
        uint64_t cgen_var_683;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_683, 1);
        countingStream->write((uint64_t*)&cgen_var_683, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        marshal_VkFormatProperties2(countingStream, (VkFormatProperties2*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2 = OP_vkGetPhysicalDeviceFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t));
    uint64_t cgen_var_684;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_684, 1);
    stream->write((uint64_t*)&cgen_var_684, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    marshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(mImpl->resources(), (VkFormatProperties2*)(pFormatProperties));
    }
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_685;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_685, 1);
        countingStream->write((uint64_t*)&cgen_var_685, 1 * 8);
        marshal_VkPhysicalDeviceImageFormatInfo2(countingStream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
        marshal_VkImageFormatProperties2(countingStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2 = OP_vkGetPhysicalDeviceImageFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t));
    uint64_t cgen_var_686;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_686, 1);
    stream->write((uint64_t*)&cgen_var_686, 1 * 8);
    marshal_VkPhysicalDeviceImageFormatInfo2(stream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    marshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(mImpl->resources(), (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_687;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_687, 1);
        countingStream->write((uint64_t*)&cgen_var_687, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_688 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
        countingStream->putBe64(cgen_var_688);
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_689 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
        countingStream->putBe64(cgen_var_689);
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties2(countingStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2 = OP_vkGetPhysicalDeviceQueueFamilyProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t));
    uint64_t cgen_var_690;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_690, 1);
    stream->write((uint64_t*)&cgen_var_690, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_691 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    stream->putBe64(cgen_var_691);
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_692 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    stream->putBe64(cgen_var_692);
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties2(mImpl->resources(), (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_695;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_695, 1);
        countingStream->write((uint64_t*)&cgen_var_695, 1 * 8);
        marshal_VkPhysicalDeviceMemoryProperties2(countingStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2 = OP_vkGetPhysicalDeviceMemoryProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t));
    uint64_t cgen_var_696;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_696, 1);
    stream->write((uint64_t*)&cgen_var_696, 1 * 8);
    marshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(mImpl->resources(), (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_697;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_697, 1);
        countingStream->write((uint64_t*)&cgen_var_697, 1 * 8);
        marshal_VkPhysicalDeviceSparseImageFormatInfo2(countingStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_698 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_698);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_699 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_699);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties2(countingStream, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2 = OP_vkGetPhysicalDeviceSparseImageFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t));
    uint64_t cgen_var_700;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_700, 1);
    stream->write((uint64_t*)&cgen_var_700, 1 * 8);
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_701 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_701);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_702 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_702);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties2(mImpl->resources(), (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
}

void VkEncoder::vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_705;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_705, 1);
        countingStream->write((uint64_t*)&cgen_var_705, 1 * 8);
        uint64_t cgen_var_706;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_706, 1);
        countingStream->write((uint64_t*)&cgen_var_706, 1 * 8);
        countingStream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    }
    uint32_t packetSize_vkTrimCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkTrimCommandPool = OP_vkTrimCommandPool;
    stream->write(&opcode_vkTrimCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkTrimCommandPool, sizeof(uint32_t));
    uint64_t cgen_var_707;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_707, 1);
    stream->write((uint64_t*)&cgen_var_707, 1 * 8);
    uint64_t cgen_var_708;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_708, 1);
    stream->write((uint64_t*)&cgen_var_708, 1 * 8);
    stream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
}

void VkEncoder::vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceQueueInfo2* local_pQueueInfo;
    local_device = device;
    local_pQueueInfo = nullptr;
    if (pQueueInfo)
    {
        local_pQueueInfo = (VkDeviceQueueInfo2*)pool->alloc(sizeof(const VkDeviceQueueInfo2));
        deepcopy_VkDeviceQueueInfo2(pool, pQueueInfo, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    if (local_pQueueInfo)
    {
        transform_tohost_VkDeviceQueueInfo2(mImpl->resources(), (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_709;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_709, 1);
        countingStream->write((uint64_t*)&cgen_var_709, 1 * 8);
        marshal_VkDeviceQueueInfo2(countingStream, (VkDeviceQueueInfo2*)(local_pQueueInfo));
        uint64_t cgen_var_710;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_710, 1);
        countingStream->write((uint64_t*)&cgen_var_710, 8);
    }
    uint32_t packetSize_vkGetDeviceQueue2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceQueue2 = OP_vkGetDeviceQueue2;
    stream->write(&opcode_vkGetDeviceQueue2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceQueue2, sizeof(uint32_t));
    uint64_t cgen_var_711;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_711, 1);
    stream->write((uint64_t*)&cgen_var_711, 1 * 8);
    marshal_VkDeviceQueueInfo2(stream, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_712;
    stream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_712, 1);
    stream->write((uint64_t*)&cgen_var_712, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_713;
    stream->read((uint64_t*)&cgen_var_713, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_713, (VkQueue*)pQueue, 1);
}

VkResult VkEncoder::vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(mImpl->resources(), (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_714;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_714, 1);
        countingStream->write((uint64_t*)&cgen_var_714, 1 * 8);
        marshal_VkSamplerYcbcrConversionCreateInfo(countingStream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_715 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_715);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_716;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_716, 1);
        countingStream->write((uint64_t*)&cgen_var_716, 8);
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSamplerYcbcrConversion = OP_vkCreateSamplerYcbcrConversion;
    stream->write(&opcode_vkCreateSamplerYcbcrConversion, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSamplerYcbcrConversion, sizeof(uint32_t));
    uint64_t cgen_var_717;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_717, 1);
    stream->write((uint64_t*)&cgen_var_717, 1 * 8);
    marshal_VkSamplerYcbcrConversionCreateInfo(stream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_718 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_718);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_719;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_719, 1);
    stream->write((uint64_t*)&cgen_var_719, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_720;
    stream->read((uint64_t*)&cgen_var_720, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_720, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_721;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_721, 1);
        countingStream->write((uint64_t*)&cgen_var_721, 1 * 8);
        uint64_t cgen_var_722;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_722, 1);
        countingStream->write((uint64_t*)&cgen_var_722, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_723 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_723);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySamplerYcbcrConversion = OP_vkDestroySamplerYcbcrConversion;
    stream->write(&opcode_vkDestroySamplerYcbcrConversion, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySamplerYcbcrConversion, sizeof(uint32_t));
    uint64_t cgen_var_724;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_724, 1);
    stream->write((uint64_t*)&cgen_var_724, 1 * 8);
    uint64_t cgen_var_725;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_725, 1);
    stream->write((uint64_t*)&cgen_var_725, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_726 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_726);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
}

VkResult VkEncoder::vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(mImpl->resources(), (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_727;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_727, 1);
        countingStream->write((uint64_t*)&cgen_var_727, 1 * 8);
        marshal_VkDescriptorUpdateTemplateCreateInfo(countingStream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_728 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_728);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_729;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_729, 1);
        countingStream->write((uint64_t*)&cgen_var_729, 8);
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorUpdateTemplate = OP_vkCreateDescriptorUpdateTemplate;
    stream->write(&opcode_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t));
    uint64_t cgen_var_730;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_730, 1);
    stream->write((uint64_t*)&cgen_var_730, 1 * 8);
    marshal_VkDescriptorUpdateTemplateCreateInfo(stream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_731 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_731);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_732;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_732, 1);
    stream->write((uint64_t*)&cgen_var_732, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_733;
    stream->read((uint64_t*)&cgen_var_733, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_733, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_734;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_734, 1);
        countingStream->write((uint64_t*)&cgen_var_734, 1 * 8);
        uint64_t cgen_var_735;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_735, 1);
        countingStream->write((uint64_t*)&cgen_var_735, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_736 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_736);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorUpdateTemplate = OP_vkDestroyDescriptorUpdateTemplate;
    stream->write(&opcode_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t));
    uint64_t cgen_var_737;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_737, 1);
    stream->write((uint64_t*)&cgen_var_737, 1 * 8);
    uint64_t cgen_var_738;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_738, 1);
    stream->write((uint64_t*)&cgen_var_738, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_739 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_739);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
}

void VkEncoder::vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_740;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_740, 1);
        countingStream->write((uint64_t*)&cgen_var_740, 1 * 8);
        uint64_t cgen_var_741;
        countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_741, 1);
        countingStream->write((uint64_t*)&cgen_var_741, 1 * 8);
        uint64_t cgen_var_742;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_742, 1);
        countingStream->write((uint64_t*)&cgen_var_742, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_743 = (uint64_t)(uintptr_t)local_pData;
        countingStream->putBe64(cgen_var_743);
        if (local_pData)
        {
            countingStream->write((void*)local_pData, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplate = OP_vkUpdateDescriptorSetWithTemplate;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t));
    uint64_t cgen_var_744;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_744, 1);
    stream->write((uint64_t*)&cgen_var_744, 1 * 8);
    uint64_t cgen_var_745;
    stream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_745, 1);
    stream->write((uint64_t*)&cgen_var_745, 1 * 8);
    uint64_t cgen_var_746;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_746, 1);
    stream->write((uint64_t*)&cgen_var_746, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_747 = (uint64_t)(uintptr_t)local_pData;
    stream->putBe64(cgen_var_747);
    if (local_pData)
    {
        stream->write((void*)local_pData, sizeof(uint8_t));
    }
}

void VkEncoder::vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(mImpl->resources(), (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_748;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_748, 1);
        countingStream->write((uint64_t*)&cgen_var_748, 1 * 8);
        marshal_VkPhysicalDeviceExternalBufferInfo(countingStream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
        marshal_VkExternalBufferProperties(countingStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferProperties = OP_vkGetPhysicalDeviceExternalBufferProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t));
    uint64_t cgen_var_749;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_749, 1);
    stream->write((uint64_t*)&cgen_var_749, 1 * 8);
    marshal_VkPhysicalDeviceExternalBufferInfo(stream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    marshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        transform_fromhost_VkExternalBufferProperties(mImpl->resources(), (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
}

void VkEncoder::vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(mImpl->resources(), (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_750;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_750, 1);
        countingStream->write((uint64_t*)&cgen_var_750, 1 * 8);
        marshal_VkPhysicalDeviceExternalFenceInfo(countingStream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
        marshal_VkExternalFenceProperties(countingStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFenceProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalFenceProperties = OP_vkGetPhysicalDeviceExternalFenceProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t));
    uint64_t cgen_var_751;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_751, 1);
    stream->write((uint64_t*)&cgen_var_751, 1 * 8);
    marshal_VkPhysicalDeviceExternalFenceInfo(stream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    marshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(mImpl->resources(), (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
}

void VkEncoder::vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(mImpl->resources(), (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_752;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_752, 1);
        countingStream->write((uint64_t*)&cgen_var_752, 1 * 8);
        marshal_VkPhysicalDeviceExternalSemaphoreInfo(countingStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
        marshal_VkExternalSemaphoreProperties(countingStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphoreProperties = OP_vkGetPhysicalDeviceExternalSemaphoreProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t));
    uint64_t cgen_var_753;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_753, 1);
    stream->write((uint64_t*)&cgen_var_753, 1 * 8);
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(mImpl->resources(), (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
}

void VkEncoder::vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(mImpl->resources(), (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_754;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_754, 1);
        countingStream->write((uint64_t*)&cgen_var_754, 1 * 8);
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
        marshal_VkDescriptorSetLayoutSupport(countingStream, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupport = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDescriptorSetLayoutSupport = OP_vkGetDescriptorSetLayoutSupport;
    stream->write(&opcode_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t));
    uint64_t cgen_var_755;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_755, 1);
    stream->write((uint64_t*)&cgen_var_755, 1 * 8);
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(mImpl->resources(), (VkDescriptorSetLayoutSupport*)(pSupport));
    }
}

#endif
#ifdef VK_KHR_surface
void VkEncoder::vkDestroySurfaceKHR(
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkSurfaceKHR local_surface;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_surface = surface;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_756;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_756, 1);
        countingStream->write((uint64_t*)&cgen_var_756, 1 * 8);
        uint64_t cgen_var_757;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_757, 1);
        countingStream->write((uint64_t*)&cgen_var_757, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_758 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_758);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySurfaceKHR = OP_vkDestroySurfaceKHR;
    stream->write(&opcode_vkDestroySurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_759;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_759, 1);
    stream->write((uint64_t*)&cgen_var_759, 1 * 8);
    uint64_t cgen_var_760;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_760, 1);
    stream->write((uint64_t*)&cgen_var_760, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_761 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_761);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&surface);
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_762;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_762, 1);
        countingStream->write((uint64_t*)&cgen_var_762, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        uint64_t cgen_var_763;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_763, 1);
        countingStream->write((uint64_t*)&cgen_var_763, 1 * 8);
        countingStream->write((VkBool32*)pSupported, sizeof(VkBool32));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceSupportKHR = OP_vkGetPhysicalDeviceSurfaceSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_764;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_764, 1);
    stream->write((uint64_t*)&cgen_var_764, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_765;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_765, 1);
    stream->write((uint64_t*)&cgen_var_765, 1 * 8);
    stream->write((VkBool32*)pSupported, sizeof(VkBool32));
    stream->read((VkBool32*)pSupported, sizeof(VkBool32));
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_766;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_766, 1);
        countingStream->write((uint64_t*)&cgen_var_766, 1 * 8);
        uint64_t cgen_var_767;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_767, 1);
        countingStream->write((uint64_t*)&cgen_var_767, 1 * 8);
        marshal_VkSurfaceCapabilitiesKHR(countingStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_768;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_768, 1);
    stream->write((uint64_t*)&cgen_var_768, 1 * 8);
    uint64_t cgen_var_769;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_769, 1);
    stream->write((uint64_t*)&cgen_var_769, 1 * 8);
    marshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    unmarshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilitiesKHR(mImpl->resources(), (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_770;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_770, 1);
        countingStream->write((uint64_t*)&cgen_var_770, 1 * 8);
        uint64_t cgen_var_771;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_771, 1);
        countingStream->write((uint64_t*)&cgen_var_771, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_772 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
        countingStream->putBe64(cgen_var_772);
        if (pSurfaceFormatCount)
        {
            countingStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_773 = (uint64_t)(uintptr_t)pSurfaceFormats;
        countingStream->putBe64(cgen_var_773);
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                marshal_VkSurfaceFormatKHR(countingStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormatsKHR = OP_vkGetPhysicalDeviceSurfaceFormatsKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t));
    uint64_t cgen_var_774;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_774, 1);
    stream->write((uint64_t*)&cgen_var_774, 1 * 8);
    uint64_t cgen_var_775;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_775, 1);
    stream->write((uint64_t*)&cgen_var_775, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_776 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    stream->putBe64(cgen_var_776);
    if (pSurfaceFormatCount)
    {
        stream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_777 = (uint64_t)(uintptr_t)pSurfaceFormats;
    stream->putBe64(cgen_var_777);
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            marshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormatKHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            transform_fromhost_VkSurfaceFormatKHR(mImpl->resources(), (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_780;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_780, 1);
        countingStream->write((uint64_t*)&cgen_var_780, 1 * 8);
        uint64_t cgen_var_781;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_781, 1);
        countingStream->write((uint64_t*)&cgen_var_781, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_782 = (uint64_t)(uintptr_t)pPresentModeCount;
        countingStream->putBe64(cgen_var_782);
        if (pPresentModeCount)
        {
            countingStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_783 = (uint64_t)(uintptr_t)pPresentModes;
        countingStream->putBe64(cgen_var_783);
        if (pPresentModes)
        {
            countingStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfacePresentModesKHR = OP_vkGetPhysicalDeviceSurfacePresentModesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t));
    uint64_t cgen_var_784;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_784, 1);
    stream->write((uint64_t*)&cgen_var_784, 1 * 8);
    uint64_t cgen_var_785;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_785, 1);
    stream->write((uint64_t*)&cgen_var_785, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_786 = (uint64_t)(uintptr_t)pPresentModeCount;
    stream->putBe64(cgen_var_786);
    if (pPresentModeCount)
    {
        stream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_787 = (uint64_t)(uintptr_t)pPresentModes;
    stream->putBe64(cgen_var_787);
    if (pPresentModes)
    {
        stream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentModeCount;
    check_pPresentModeCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentModeCount)
    {
        if (!(check_pPresentModeCount))
        {
            fprintf(stderr, "fatal: pPresentModeCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPresentModeKHR* check_pPresentModes;
    check_pPresentModes = (VkPresentModeKHR*)(uintptr_t)stream->getBe64();
    if (pPresentModes)
    {
        if (!(check_pPresentModes))
        {
            fprintf(stderr, "fatal: pPresentModes inconsistent between guest and host\n");
        }
        stream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_swapchain
VkResult VkEncoder::vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSwapchainCreateInfoKHR*)pool->alloc(sizeof(const VkSwapchainCreateInfoKHR));
        deepcopy_VkSwapchainCreateInfoKHR(pool, pCreateInfo, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSwapchainCreateInfoKHR(mImpl->resources(), (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_790;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_790, 1);
        countingStream->write((uint64_t*)&cgen_var_790, 1 * 8);
        marshal_VkSwapchainCreateInfoKHR(countingStream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_791 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_791);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_792;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchain, &cgen_var_792, 1);
        countingStream->write((uint64_t*)&cgen_var_792, 8);
    }
    uint32_t packetSize_vkCreateSwapchainKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSwapchainKHR = OP_vkCreateSwapchainKHR;
    stream->write(&opcode_vkCreateSwapchainKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSwapchainKHR, sizeof(uint32_t));
    uint64_t cgen_var_793;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_793, 1);
    stream->write((uint64_t*)&cgen_var_793, 1 * 8);
    marshal_VkSwapchainCreateInfoKHR(stream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_794 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_794);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_795;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchain, &cgen_var_795, 1);
    stream->write((uint64_t*)&cgen_var_795, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_796;
    stream->read((uint64_t*)&cgen_var_796, 8);
    stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_796, (VkSwapchainKHR*)pSwapchain, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateSwapchainKHR_VkResult_return;
}

void VkEncoder::vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchain = swapchain;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_797;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_797, 1);
        countingStream->write((uint64_t*)&cgen_var_797, 1 * 8);
        uint64_t cgen_var_798;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_798, 1);
        countingStream->write((uint64_t*)&cgen_var_798, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_799 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_799);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySwapchainKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySwapchainKHR = OP_vkDestroySwapchainKHR;
    stream->write(&opcode_vkDestroySwapchainKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySwapchainKHR, sizeof(uint32_t));
    uint64_t cgen_var_800;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_800, 1);
    stream->write((uint64_t*)&cgen_var_800, 1 * 8);
    uint64_t cgen_var_801;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_801, 1);
    stream->write((uint64_t*)&cgen_var_801, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_802 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_802);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&swapchain);
}

VkResult VkEncoder::vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_803;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_803, 1);
        countingStream->write((uint64_t*)&cgen_var_803, 1 * 8);
        uint64_t cgen_var_804;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_804, 1);
        countingStream->write((uint64_t*)&cgen_var_804, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_805 = (uint64_t)(uintptr_t)pSwapchainImageCount;
        countingStream->putBe64(cgen_var_805);
        if (pSwapchainImageCount)
        {
            countingStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_806 = (uint64_t)(uintptr_t)pSwapchainImages;
        countingStream->putBe64(cgen_var_806);
        if (pSwapchainImages)
        {
            if ((*(pSwapchainImageCount)))
            {
                uint64_t* cgen_var_807;
                countingStream->alloc((void**)&cgen_var_807, (*(pSwapchainImageCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_807, (*(pSwapchainImageCount)));
                countingStream->write((uint64_t*)cgen_var_807, (*(pSwapchainImageCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkGetSwapchainImagesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainImagesKHR = OP_vkGetSwapchainImagesKHR;
    stream->write(&opcode_vkGetSwapchainImagesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainImagesKHR, sizeof(uint32_t));
    uint64_t cgen_var_808;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_808, 1);
    stream->write((uint64_t*)&cgen_var_808, 1 * 8);
    uint64_t cgen_var_809;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_809, 1);
    stream->write((uint64_t*)&cgen_var_809, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_810 = (uint64_t)(uintptr_t)pSwapchainImageCount;
    stream->putBe64(cgen_var_810);
    if (pSwapchainImageCount)
    {
        stream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_811 = (uint64_t)(uintptr_t)pSwapchainImages;
    stream->putBe64(cgen_var_811);
    if (pSwapchainImages)
    {
        if ((*(pSwapchainImageCount)))
        {
            uint64_t* cgen_var_812;
            stream->alloc((void**)&cgen_var_812, (*(pSwapchainImageCount)) * 8);
            stream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_812, (*(pSwapchainImageCount)));
            stream->write((uint64_t*)cgen_var_812, (*(pSwapchainImageCount)) * 8);
        }
    }
    stream->setHandleMapping(resources->unwrapMapping());
    // WARNING PTR CHECK
    uint32_t* check_pSwapchainImageCount;
    check_pSwapchainImageCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSwapchainImageCount)
    {
        if (!(check_pSwapchainImageCount))
        {
            fprintf(stderr, "fatal: pSwapchainImageCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkImage* check_pSwapchainImages;
    check_pSwapchainImages = (VkImage*)(uintptr_t)stream->getBe64();
    if (pSwapchainImages)
    {
        if (!(check_pSwapchainImages))
        {
            fprintf(stderr, "fatal: pSwapchainImages inconsistent between guest and host\n");
        }
        if ((*(pSwapchainImageCount)))
        {
            uint64_t* cgen_var_815;
            stream->alloc((void**)&cgen_var_815, (*(pSwapchainImageCount)) * 8);
            stream->read((uint64_t*)cgen_var_815, (*(pSwapchainImageCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkImage(cgen_var_815, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
        }
    }
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    uint64_t local_timeout;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_swapchain = swapchain;
    local_timeout = timeout;
    local_semaphore = semaphore;
    local_fence = fence;
    countingStream->rewind();
    {
        uint64_t cgen_var_816;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_816, 1);
        countingStream->write((uint64_t*)&cgen_var_816, 1 * 8);
        uint64_t cgen_var_817;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_817, 1);
        countingStream->write((uint64_t*)&cgen_var_817, 1 * 8);
        countingStream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
        uint64_t cgen_var_818;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_818, 1);
        countingStream->write((uint64_t*)&cgen_var_818, 1 * 8);
        uint64_t cgen_var_819;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_819, 1);
        countingStream->write((uint64_t*)&cgen_var_819, 1 * 8);
        countingStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkAcquireNextImageKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireNextImageKHR = OP_vkAcquireNextImageKHR;
    stream->write(&opcode_vkAcquireNextImageKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireNextImageKHR, sizeof(uint32_t));
    uint64_t cgen_var_820;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_820, 1);
    stream->write((uint64_t*)&cgen_var_820, 1 * 8);
    uint64_t cgen_var_821;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_821, 1);
    stream->write((uint64_t*)&cgen_var_821, 1 * 8);
    stream->write((uint64_t*)&local_timeout, sizeof(uint64_t));
    uint64_t cgen_var_822;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_822, 1);
    stream->write((uint64_t*)&cgen_var_822, 1 * 8);
    uint64_t cgen_var_823;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_823, 1);
    stream->write((uint64_t*)&cgen_var_823, 1 * 8);
    stream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAcquireNextImageKHR_VkResult_return;
}

VkResult VkEncoder::vkQueuePresentKHR(
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    VkPresentInfoKHR* local_pPresentInfo;
    local_queue = queue;
    local_pPresentInfo = nullptr;
    if (pPresentInfo)
    {
        local_pPresentInfo = (VkPresentInfoKHR*)pool->alloc(sizeof(const VkPresentInfoKHR));
        deepcopy_VkPresentInfoKHR(pool, pPresentInfo, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    if (local_pPresentInfo)
    {
        transform_tohost_VkPresentInfoKHR(mImpl->resources(), (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_824;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_824, 1);
        countingStream->write((uint64_t*)&cgen_var_824, 1 * 8);
        marshal_VkPresentInfoKHR(countingStream, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    uint32_t packetSize_vkQueuePresentKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueuePresentKHR = OP_vkQueuePresentKHR;
    stream->write(&opcode_vkQueuePresentKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkQueuePresentKHR, sizeof(uint32_t));
    uint64_t cgen_var_825;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_825, 1);
    stream->write((uint64_t*)&cgen_var_825, 1 * 8);
    marshal_VkPresentInfoKHR(stream, (VkPresentInfoKHR*)(local_pPresentInfo));
    VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
    stream->read(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkQueuePresentKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    local_device = device;
    countingStream->rewind();
    {
        uint64_t cgen_var_826;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_826, 1);
        countingStream->write((uint64_t*)&cgen_var_826, 1 * 8);
        marshal_VkDeviceGroupPresentCapabilitiesKHR(countingStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    uint32_t packetSize_vkGetDeviceGroupPresentCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPresentCapabilitiesKHR = OP_vkGetDeviceGroupPresentCapabilitiesKHR;
    stream->write(&opcode_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_827;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_827, 1);
    stream->write((uint64_t*)&cgen_var_827, 1 * 8);
    marshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    unmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    if (pDeviceGroupPresentCapabilities)
    {
        transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(mImpl->resources(), (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSurfaceKHR local_surface;
    local_device = device;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_828;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_828, 1);
        countingStream->write((uint64_t*)&cgen_var_828, 1 * 8);
        uint64_t cgen_var_829;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_829, 1);
        countingStream->write((uint64_t*)&cgen_var_829, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_830 = (uint64_t)(uintptr_t)pModes;
        countingStream->putBe64(cgen_var_830);
        if (pModes)
        {
            countingStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
        }
    }
    uint32_t packetSize_vkGetDeviceGroupSurfacePresentModesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupSurfacePresentModesKHR = OP_vkGetDeviceGroupSurfacePresentModesKHR;
    stream->write(&opcode_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t));
    uint64_t cgen_var_831;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_831, 1);
    stream->write((uint64_t*)&cgen_var_831, 1 * 8);
    uint64_t cgen_var_832;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_832, 1);
    stream->write((uint64_t*)&cgen_var_832, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_833 = (uint64_t)(uintptr_t)pModes;
    stream->putBe64(cgen_var_833);
    if (pModes)
    {
        stream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    // WARNING PTR CHECK
    VkDeviceGroupPresentModeFlagsKHR* check_pModes;
    check_pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)stream->getBe64();
    if (pModes)
    {
        if (!(check_pModes))
        {
            fprintf(stderr, "fatal: pModes inconsistent between guest and host\n");
        }
        stream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_835;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_835, 1);
        countingStream->write((uint64_t*)&cgen_var_835, 1 * 8);
        uint64_t cgen_var_836;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_836, 1);
        countingStream->write((uint64_t*)&cgen_var_836, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_837 = (uint64_t)(uintptr_t)pRectCount;
        countingStream->putBe64(cgen_var_837);
        if (pRectCount)
        {
            countingStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_838 = (uint64_t)(uintptr_t)pRects;
        countingStream->putBe64(cgen_var_838);
        if (pRects)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
            {
                marshal_VkRect2D(countingStream, (VkRect2D*)(pRects + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDevicePresentRectanglesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDevicePresentRectanglesKHR = OP_vkGetPhysicalDevicePresentRectanglesKHR;
    stream->write(&opcode_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t));
    uint64_t cgen_var_839;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_839, 1);
    stream->write((uint64_t*)&cgen_var_839, 1 * 8);
    uint64_t cgen_var_840;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_840, 1);
    stream->write((uint64_t*)&cgen_var_840, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_841 = (uint64_t)(uintptr_t)pRectCount;
    stream->putBe64(cgen_var_841);
    if (pRectCount)
    {
        stream->write((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_842 = (uint64_t)(uintptr_t)pRects;
    stream->putBe64(cgen_var_842);
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            marshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pRectCount;
    check_pRectCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pRectCount)
    {
        if (!(check_pRectCount))
        {
            fprintf(stderr, "fatal: pRectCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkRect2D* check_pRects;
    check_pRects = (VkRect2D*)(uintptr_t)stream->getBe64();
    if (pRects)
    {
        if (!(check_pRects))
        {
            fprintf(stderr, "fatal: pRects inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            unmarshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            transform_fromhost_VkRect2D(mImpl->resources(), (VkRect2D*)(pRects + i));
        }
    }
    VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkAcquireNextImageInfoKHR* local_pAcquireInfo;
    local_device = device;
    local_pAcquireInfo = nullptr;
    if (pAcquireInfo)
    {
        local_pAcquireInfo = (VkAcquireNextImageInfoKHR*)pool->alloc(sizeof(const VkAcquireNextImageInfoKHR));
        deepcopy_VkAcquireNextImageInfoKHR(pool, pAcquireInfo, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    if (local_pAcquireInfo)
    {
        transform_tohost_VkAcquireNextImageInfoKHR(mImpl->resources(), (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_845;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_845, 1);
        countingStream->write((uint64_t*)&cgen_var_845, 1 * 8);
        marshal_VkAcquireNextImageInfoKHR(countingStream, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
        countingStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkAcquireNextImage2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireNextImage2KHR = OP_vkAcquireNextImage2KHR;
    stream->write(&opcode_vkAcquireNextImage2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireNextImage2KHR, sizeof(uint32_t));
    uint64_t cgen_var_846;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_846, 1);
    stream->write((uint64_t*)&cgen_var_846, 1 * 8);
    marshal_VkAcquireNextImageInfoKHR(stream, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    stream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAcquireNextImage2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display
VkResult VkEncoder::vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_847;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_847, 1);
        countingStream->write((uint64_t*)&cgen_var_847, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_848 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_848);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_849 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_849);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPropertiesKHR(countingStream, (VkDisplayPropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPropertiesKHR = OP_vkGetPhysicalDeviceDisplayPropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_850;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_850, 1);
    stream->write((uint64_t*)&cgen_var_850, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_851 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_851);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_852 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_852);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPropertiesKHR(mImpl->resources(), (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_855;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_855, 1);
        countingStream->write((uint64_t*)&cgen_var_855, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_856 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_856);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_857 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_857);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPlanePropertiesKHR(countingStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_858;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_858, 1);
    stream->write((uint64_t*)&cgen_var_858, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_859 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_859);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_860 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_860);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlanePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPlanePropertiesKHR(mImpl->resources(), (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_planeIndex = planeIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_863;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_863, 1);
        countingStream->write((uint64_t*)&cgen_var_863, 1 * 8);
        countingStream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_864 = (uint64_t)(uintptr_t)pDisplayCount;
        countingStream->putBe64(cgen_var_864);
        if (pDisplayCount)
        {
            countingStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_865 = (uint64_t)(uintptr_t)pDisplays;
        countingStream->putBe64(cgen_var_865);
        if (pDisplays)
        {
            if ((*(pDisplayCount)))
            {
                uint64_t* cgen_var_866;
                countingStream->alloc((void**)&cgen_var_866, (*(pDisplayCount)) * 8);
                countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_866, (*(pDisplayCount)));
                countingStream->write((uint64_t*)cgen_var_866, (*(pDisplayCount)) * 8);
            }
        }
    }
    uint32_t packetSize_vkGetDisplayPlaneSupportedDisplaysKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneSupportedDisplaysKHR = OP_vkGetDisplayPlaneSupportedDisplaysKHR;
    stream->write(&opcode_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t));
    uint64_t cgen_var_867;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_867, 1);
    stream->write((uint64_t*)&cgen_var_867, 1 * 8);
    stream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_868 = (uint64_t)(uintptr_t)pDisplayCount;
    stream->putBe64(cgen_var_868);
    if (pDisplayCount)
    {
        stream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_869 = (uint64_t)(uintptr_t)pDisplays;
    stream->putBe64(cgen_var_869);
    if (pDisplays)
    {
        if ((*(pDisplayCount)))
        {
            uint64_t* cgen_var_870;
            stream->alloc((void**)&cgen_var_870, (*(pDisplayCount)) * 8);
            stream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_870, (*(pDisplayCount)));
            stream->write((uint64_t*)cgen_var_870, (*(pDisplayCount)) * 8);
        }
    }
    stream->setHandleMapping(resources->unwrapMapping());
    // WARNING PTR CHECK
    uint32_t* check_pDisplayCount;
    check_pDisplayCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pDisplayCount)
    {
        if (!(check_pDisplayCount))
        {
            fprintf(stderr, "fatal: pDisplayCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayKHR* check_pDisplays;
    check_pDisplays = (VkDisplayKHR*)(uintptr_t)stream->getBe64();
    if (pDisplays)
    {
        if (!(check_pDisplays))
        {
            fprintf(stderr, "fatal: pDisplays inconsistent between guest and host\n");
        }
        if ((*(pDisplayCount)))
        {
            uint64_t* cgen_var_873;
            stream->alloc((void**)&cgen_var_873, (*(pDisplayCount)) * 8);
            stream->read((uint64_t*)cgen_var_873, (*(pDisplayCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_873, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
        }
    }
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_874;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_874, 1);
        countingStream->write((uint64_t*)&cgen_var_874, 1 * 8);
        uint64_t cgen_var_875;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_875, 1);
        countingStream->write((uint64_t*)&cgen_var_875, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_876 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_876);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_877 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_877);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayModePropertiesKHR(countingStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayModePropertiesKHR = OP_vkGetDisplayModePropertiesKHR;
    stream->write(&opcode_vkGetDisplayModePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayModePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_878;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_878, 1);
    stream->write((uint64_t*)&cgen_var_878, 1 * 8);
    uint64_t cgen_var_879;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_879, 1);
    stream->write((uint64_t*)&cgen_var_879, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_880 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_880);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_881 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_881);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayModePropertiesKHR(mImpl->resources(), (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    VkDisplayModeCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_display = display;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplayModeCreateInfoKHR*)pool->alloc(sizeof(const VkDisplayModeCreateInfoKHR));
        deepcopy_VkDisplayModeCreateInfoKHR(pool, pCreateInfo, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplayModeCreateInfoKHR(mImpl->resources(), (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_884;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_884, 1);
        countingStream->write((uint64_t*)&cgen_var_884, 1 * 8);
        uint64_t cgen_var_885;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_885, 1);
        countingStream->write((uint64_t*)&cgen_var_885, 1 * 8);
        marshal_VkDisplayModeCreateInfoKHR(countingStream, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_886 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_886);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_887;
        countingStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(pMode, &cgen_var_887, 1);
        countingStream->write((uint64_t*)&cgen_var_887, 8);
    }
    uint32_t packetSize_vkCreateDisplayModeKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDisplayModeKHR = OP_vkCreateDisplayModeKHR;
    stream->write(&opcode_vkCreateDisplayModeKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDisplayModeKHR, sizeof(uint32_t));
    uint64_t cgen_var_888;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_888, 1);
    stream->write((uint64_t*)&cgen_var_888, 1 * 8);
    uint64_t cgen_var_889;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_889, 1);
    stream->write((uint64_t*)&cgen_var_889, 1 * 8);
    marshal_VkDisplayModeCreateInfoKHR(stream, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_890 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_890);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_891;
    stream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(pMode, &cgen_var_891, 1);
    stream->write((uint64_t*)&cgen_var_891, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_892;
    stream->read((uint64_t*)&cgen_var_892, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_892, (VkDisplayModeKHR*)pMode, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDisplayModeKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayModeKHR local_mode;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_mode = mode;
    local_planeIndex = planeIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_893;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_893, 1);
        countingStream->write((uint64_t*)&cgen_var_893, 1 * 8);
        uint64_t cgen_var_894;
        countingStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&local_mode, &cgen_var_894, 1);
        countingStream->write((uint64_t*)&cgen_var_894, 1 * 8);
        countingStream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
        marshal_VkDisplayPlaneCapabilitiesKHR(countingStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneCapabilitiesKHR = OP_vkGetDisplayPlaneCapabilitiesKHR;
    stream->write(&opcode_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_895;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_895, 1);
    stream->write((uint64_t*)&cgen_var_895, 1 * 8);
    uint64_t cgen_var_896;
    stream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&local_mode, &cgen_var_896, 1);
    stream->write((uint64_t*)&cgen_var_896, 1 * 8);
    stream->write((uint32_t*)&local_planeIndex, sizeof(uint32_t));
    marshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    unmarshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilitiesKHR(mImpl->resources(), (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDisplaySurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplaySurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkDisplaySurfaceCreateInfoKHR));
        deepcopy_VkDisplaySurfaceCreateInfoKHR(pool, pCreateInfo, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplaySurfaceCreateInfoKHR(mImpl->resources(), (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_897;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_897, 1);
        countingStream->write((uint64_t*)&cgen_var_897, 1 * 8);
        marshal_VkDisplaySurfaceCreateInfoKHR(countingStream, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_898 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_898);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_899;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_899, 1);
        countingStream->write((uint64_t*)&cgen_var_899, 8);
    }
    uint32_t packetSize_vkCreateDisplayPlaneSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDisplayPlaneSurfaceKHR = OP_vkCreateDisplayPlaneSurfaceKHR;
    stream->write(&opcode_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_900;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_900, 1);
    stream->write((uint64_t*)&cgen_var_900, 1 * 8);
    marshal_VkDisplaySurfaceCreateInfoKHR(stream, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_901 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_901);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_902;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_902, 1);
    stream->write((uint64_t*)&cgen_var_902, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_903;
    stream->read((uint64_t*)&cgen_var_903, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_903, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display_swapchain
VkResult VkEncoder::vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainCreateInfoKHR* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchainCount = swapchainCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkSwapchainCreateInfoKHR*)pool->alloc(((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkSwapchainCreateInfoKHR(pool, pCreateInfos + i, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkSwapchainCreateInfoKHR(mImpl->resources(), (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_904;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_904, 1);
        countingStream->write((uint64_t*)&cgen_var_904, 1 * 8);
        countingStream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            marshal_VkSwapchainCreateInfoKHR(countingStream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_905 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_905);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        if (((swapchainCount)))
        {
            uint64_t* cgen_var_906;
            countingStream->alloc((void**)&cgen_var_906, ((swapchainCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_906, ((swapchainCount)));
            countingStream->write((uint64_t*)cgen_var_906, ((swapchainCount)) * 8);
        }
    }
    uint32_t packetSize_vkCreateSharedSwapchainsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSharedSwapchainsKHR = OP_vkCreateSharedSwapchainsKHR;
    stream->write(&opcode_vkCreateSharedSwapchainsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSharedSwapchainsKHR, sizeof(uint32_t));
    uint64_t cgen_var_907;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_907, 1);
    stream->write((uint64_t*)&cgen_var_907, 1 * 8);
    stream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkSwapchainCreateInfoKHR(stream, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_908 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_908);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_909;
        stream->alloc((void**)&cgen_var_909, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_909, ((swapchainCount)));
        stream->write((uint64_t*)cgen_var_909, ((swapchainCount)) * 8);
    }
    stream->setHandleMapping(resources->unwrapMapping());
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_910;
        stream->alloc((void**)&cgen_var_910, ((swapchainCount)) * 8);
        stream->read((uint64_t*)cgen_var_910, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_910, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
    }
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_xlib_surface
VkResult VkEncoder::vkCreateXlibSurfaceKHR(
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkXlibSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXlibSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXlibSurfaceCreateInfoKHR));
        deepcopy_VkXlibSurfaceCreateInfoKHR(pool, pCreateInfo, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXlibSurfaceCreateInfoKHR(mImpl->resources(), (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_911;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_911, 1);
        countingStream->write((uint64_t*)&cgen_var_911, 1 * 8);
        marshal_VkXlibSurfaceCreateInfoKHR(countingStream, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_912 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_912);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_913;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_913, 1);
        countingStream->write((uint64_t*)&cgen_var_913, 8);
    }
    uint32_t packetSize_vkCreateXlibSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateXlibSurfaceKHR = OP_vkCreateXlibSurfaceKHR;
    stream->write(&opcode_vkCreateXlibSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateXlibSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_914;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_914, 1);
    stream->write((uint64_t*)&cgen_var_914, 1 * 8);
    marshal_VkXlibSurfaceCreateInfoKHR(stream, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_915 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_915);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_916;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_916, 1);
    stream->write((uint64_t*)&cgen_var_916, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_917;
    stream->read((uint64_t*)&cgen_var_917, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_917, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateXlibSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VisualID local_visualID;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visualID = visualID;
    countingStream->rewind();
    {
        uint64_t cgen_var_918;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_918, 1);
        countingStream->write((uint64_t*)&cgen_var_918, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((VisualID*)&local_visualID, sizeof(VisualID));
    }
    uint32_t packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR = OP_vkGetPhysicalDeviceXlibPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_919;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_919, 1);
    stream->write((uint64_t*)&cgen_var_919, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((VisualID*)&local_visualID, sizeof(VisualID));
    stream->read((Display*)dpy, sizeof(Display));
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_xcb_surface
VkResult VkEncoder::vkCreateXcbSurfaceKHR(
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkXcbSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXcbSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXcbSurfaceCreateInfoKHR));
        deepcopy_VkXcbSurfaceCreateInfoKHR(pool, pCreateInfo, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXcbSurfaceCreateInfoKHR(mImpl->resources(), (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_920;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_920, 1);
        countingStream->write((uint64_t*)&cgen_var_920, 1 * 8);
        marshal_VkXcbSurfaceCreateInfoKHR(countingStream, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_921 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_921);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_922;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_922, 1);
        countingStream->write((uint64_t*)&cgen_var_922, 8);
    }
    uint32_t packetSize_vkCreateXcbSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateXcbSurfaceKHR = OP_vkCreateXcbSurfaceKHR;
    stream->write(&opcode_vkCreateXcbSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateXcbSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_923;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_923, 1);
    stream->write((uint64_t*)&cgen_var_923, 1 * 8);
    marshal_VkXcbSurfaceCreateInfoKHR(stream, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_924 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_924);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_925;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_925, 1);
    stream->write((uint64_t*)&cgen_var_925, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_926;
    stream->read((uint64_t*)&cgen_var_926, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_926, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateXcbSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    xcb_visualid_t local_visual_id;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visual_id = visual_id;
    countingStream->rewind();
    {
        uint64_t cgen_var_927;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_927, 1);
        countingStream->write((uint64_t*)&cgen_var_927, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
        countingStream->write((xcb_visualid_t*)&local_visual_id, sizeof(xcb_visualid_t));
    }
    uint32_t packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR = OP_vkGetPhysicalDeviceXcbPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_928;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_928, 1);
    stream->write((uint64_t*)&cgen_var_928, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    stream->write((xcb_visualid_t*)&local_visual_id, sizeof(xcb_visualid_t));
    stream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_wayland_surface
VkResult VkEncoder::vkCreateWaylandSurfaceKHR(
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkWaylandSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWaylandSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWaylandSurfaceCreateInfoKHR));
        deepcopy_VkWaylandSurfaceCreateInfoKHR(pool, pCreateInfo, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWaylandSurfaceCreateInfoKHR(mImpl->resources(), (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_929;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_929, 1);
        countingStream->write((uint64_t*)&cgen_var_929, 1 * 8);
        marshal_VkWaylandSurfaceCreateInfoKHR(countingStream, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_930 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_930);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_931;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_931, 1);
        countingStream->write((uint64_t*)&cgen_var_931, 8);
    }
    uint32_t packetSize_vkCreateWaylandSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateWaylandSurfaceKHR = OP_vkCreateWaylandSurfaceKHR;
    stream->write(&opcode_vkCreateWaylandSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateWaylandSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_932;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_932, 1);
    stream->write((uint64_t*)&cgen_var_932, 1 * 8);
    marshal_VkWaylandSurfaceCreateInfoKHR(stream, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_933 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_933);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_934;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_934, 1);
    stream->write((uint64_t*)&cgen_var_934, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_935;
    stream->read((uint64_t*)&cgen_var_935, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_935, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_936;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_936, 1);
        countingStream->write((uint64_t*)&cgen_var_936, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((wl_display*)display, sizeof(wl_display));
    }
    uint32_t packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR = OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_937;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_937, 1);
    stream->write((uint64_t*)&cgen_var_937, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((wl_display*)display, sizeof(wl_display));
    stream->read((wl_display*)display, sizeof(wl_display));
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_mir_surface
VkResult VkEncoder::vkCreateMirSurfaceKHR(
    VkInstance instance,
    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkMirSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMirSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkMirSurfaceCreateInfoKHR));
        deepcopy_VkMirSurfaceCreateInfoKHR(pool, pCreateInfo, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMirSurfaceCreateInfoKHR(mImpl->resources(), (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_938;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_938, 1);
        countingStream->write((uint64_t*)&cgen_var_938, 1 * 8);
        marshal_VkMirSurfaceCreateInfoKHR(countingStream, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_939 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_939);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_940;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_940, 1);
        countingStream->write((uint64_t*)&cgen_var_940, 8);
    }
    uint32_t packetSize_vkCreateMirSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateMirSurfaceKHR = OP_vkCreateMirSurfaceKHR;
    stream->write(&opcode_vkCreateMirSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateMirSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_941;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_941, 1);
    stream->write((uint64_t*)&cgen_var_941, 1 * 8);
    marshal_VkMirSurfaceCreateInfoKHR(stream, (VkMirSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_942 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_942);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_943;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_943, 1);
    stream->write((uint64_t*)&cgen_var_943, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_944;
    stream->read((uint64_t*)&cgen_var_944, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_944, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateMirSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    MirConnection* connection)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_945;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_945, 1);
        countingStream->write((uint64_t*)&cgen_var_945, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((MirConnection*)connection, sizeof(MirConnection));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMirPresentationSupportKHR = OP_vkGetPhysicalDeviceMirPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_946;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_946, 1);
    stream->write((uint64_t*)&cgen_var_946, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    stream->write((MirConnection*)connection, sizeof(MirConnection));
    stream->read((MirConnection*)connection, sizeof(MirConnection));
    VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_android_surface
VkResult VkEncoder::vkCreateAndroidSurfaceKHR(
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkAndroidSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkAndroidSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkAndroidSurfaceCreateInfoKHR));
        deepcopy_VkAndroidSurfaceCreateInfoKHR(pool, pCreateInfo, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkAndroidSurfaceCreateInfoKHR(mImpl->resources(), (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_947;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_947, 1);
        countingStream->write((uint64_t*)&cgen_var_947, 1 * 8);
        marshal_VkAndroidSurfaceCreateInfoKHR(countingStream, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_948 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_948);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_949;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_949, 1);
        countingStream->write((uint64_t*)&cgen_var_949, 8);
    }
    uint32_t packetSize_vkCreateAndroidSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateAndroidSurfaceKHR = OP_vkCreateAndroidSurfaceKHR;
    stream->write(&opcode_vkCreateAndroidSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateAndroidSurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_950;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_950, 1);
    stream->write((uint64_t*)&cgen_var_950, 1 * 8);
    marshal_VkAndroidSurfaceCreateInfoKHR(stream, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_951 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_951);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_952;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_952, 1);
    stream->write((uint64_t*)&cgen_var_952, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_953;
    stream->read((uint64_t*)&cgen_var_953, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_953, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_surface
VkResult VkEncoder::vkCreateWin32SurfaceKHR(
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkWin32SurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWin32SurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWin32SurfaceCreateInfoKHR));
        deepcopy_VkWin32SurfaceCreateInfoKHR(pool, pCreateInfo, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWin32SurfaceCreateInfoKHR(mImpl->resources(), (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_954;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_954, 1);
        countingStream->write((uint64_t*)&cgen_var_954, 1 * 8);
        marshal_VkWin32SurfaceCreateInfoKHR(countingStream, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_955 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_955);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_956;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_956, 1);
        countingStream->write((uint64_t*)&cgen_var_956, 8);
    }
    uint32_t packetSize_vkCreateWin32SurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateWin32SurfaceKHR = OP_vkCreateWin32SurfaceKHR;
    stream->write(&opcode_vkCreateWin32SurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateWin32SurfaceKHR, sizeof(uint32_t));
    uint64_t cgen_var_957;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_957, 1);
    stream->write((uint64_t*)&cgen_var_957, 1 * 8);
    marshal_VkWin32SurfaceCreateInfoKHR(stream, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_958 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_958);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_959;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_959, 1);
    stream->write((uint64_t*)&cgen_var_959, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_960;
    stream->read((uint64_t*)&cgen_var_960, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_960, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateWin32SurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_961;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_961, 1);
        countingStream->write((uint64_t*)&cgen_var_961, 1 * 8);
        countingStream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR = OP_vkGetPhysicalDeviceWin32PresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_962;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_962, 1);
    stream->write((uint64_t*)&cgen_var_962, 1 * 8);
    stream->write((uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkEncoder::vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_963;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_963, 1);
        countingStream->write((uint64_t*)&cgen_var_963, 1 * 8);
        marshal_VkPhysicalDeviceFeatures2(countingStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures2KHR = OP_vkGetPhysicalDeviceFeatures2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t));
    uint64_t cgen_var_964;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_964, 1);
    stream->write((uint64_t*)&cgen_var_964, 1 * 8);
    marshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(mImpl->resources(), (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
}

void VkEncoder::vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_965;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_965, 1);
        countingStream->write((uint64_t*)&cgen_var_965, 1 * 8);
        marshal_VkPhysicalDeviceProperties2(countingStream, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties2KHR = OP_vkGetPhysicalDeviceProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_966;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_966, 1);
    stream->write((uint64_t*)&cgen_var_966, 1 * 8);
    marshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(mImpl->resources(), (VkPhysicalDeviceProperties2*)(pProperties));
    }
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    countingStream->rewind();
    {
        uint64_t cgen_var_967;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_967, 1);
        countingStream->write((uint64_t*)&cgen_var_967, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        marshal_VkFormatProperties2(countingStream, (VkFormatProperties2*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2KHR = OP_vkGetPhysicalDeviceFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_968;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_968, 1);
    stream->write((uint64_t*)&cgen_var_968, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    marshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(mImpl->resources(), (VkFormatProperties2*)(pFormatProperties));
    }
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_969;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_969, 1);
        countingStream->write((uint64_t*)&cgen_var_969, 1 * 8);
        marshal_VkPhysicalDeviceImageFormatInfo2(countingStream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
        marshal_VkImageFormatProperties2(countingStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2KHR = OP_vkGetPhysicalDeviceImageFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_970;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_970, 1);
    stream->write((uint64_t*)&cgen_var_970, 1 * 8);
    marshal_VkPhysicalDeviceImageFormatInfo2(stream, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    marshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(mImpl->resources(), (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_971;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_971, 1);
        countingStream->write((uint64_t*)&cgen_var_971, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_972 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
        countingStream->putBe64(cgen_var_972);
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_973 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
        countingStream->putBe64(cgen_var_973);
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties2(countingStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR = OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_974;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_974, 1);
    stream->write((uint64_t*)&cgen_var_974, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_975 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    stream->putBe64(cgen_var_975);
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_976 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    stream->putBe64(cgen_var_976);
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            transform_fromhost_VkQueueFamilyProperties2(mImpl->resources(), (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_979;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_979, 1);
        countingStream->write((uint64_t*)&cgen_var_979, 1 * 8);
        marshal_VkPhysicalDeviceMemoryProperties2(countingStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2KHR = OP_vkGetPhysicalDeviceMemoryProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_980;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_980, 1);
    stream->write((uint64_t*)&cgen_var_980, 1 * 8);
    marshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(mImpl->resources(), (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(mImpl->resources(), (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_981;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_981, 1);
        countingStream->write((uint64_t*)&cgen_var_981, 1 * 8);
        marshal_VkPhysicalDeviceSparseImageFormatInfo2(countingStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_982 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_982);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_983 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_983);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties2(countingStream, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_984;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_984, 1);
    stream->write((uint64_t*)&cgen_var_984, 1 * 8);
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_985 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_985);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_986 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_986);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkSparseImageFormatProperties2(mImpl->resources(), (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
}

#endif
#ifdef VK_KHR_device_group
void VkEncoder::vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    countingStream->rewind();
    {
        uint64_t cgen_var_989;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_989, 1);
        countingStream->write((uint64_t*)&cgen_var_989, 1 * 8);
        countingStream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
        countingStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR = OP_vkGetDeviceGroupPeerMemoryFeaturesKHR;
    stream->write(&opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t));
    uint64_t cgen_var_990;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_990, 1);
    stream->write((uint64_t*)&cgen_var_990, 1 * 8);
    stream->write((uint32_t*)&local_heapIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    stream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void VkEncoder::vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    countingStream->rewind();
    {
        uint64_t cgen_var_991;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_991, 1);
        countingStream->write((uint64_t*)&cgen_var_991, 1 * 8);
        countingStream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetDeviceMaskKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDeviceMaskKHR = OP_vkCmdSetDeviceMaskKHR;
    stream->write(&opcode_vkCmdSetDeviceMaskKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDeviceMaskKHR, sizeof(uint32_t));
    uint64_t cgen_var_992;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_992, 1);
    stream->write((uint64_t*)&cgen_var_992, 1 * 8);
    stream->write((uint32_t*)&local_deviceMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    countingStream->rewind();
    {
        uint64_t cgen_var_993;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_993, 1);
        countingStream->write((uint64_t*)&cgen_var_993, 1 * 8);
        countingStream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatchBaseKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchBaseKHR = OP_vkCmdDispatchBaseKHR;
    stream->write(&opcode_vkCmdDispatchBaseKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchBaseKHR, sizeof(uint32_t));
    uint64_t cgen_var_994;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_994, 1);
    stream->write((uint64_t*)&cgen_var_994, 1 * 8);
    stream->write((uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&local_groupCountZ, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
void VkEncoder::vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    countingStream->rewind();
    {
        uint64_t cgen_var_995;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_995, 1);
        countingStream->write((uint64_t*)&cgen_var_995, 1 * 8);
        uint64_t cgen_var_996;
        countingStream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_996, 1);
        countingStream->write((uint64_t*)&cgen_var_996, 1 * 8);
        countingStream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    }
    uint32_t packetSize_vkTrimCommandPoolKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkTrimCommandPoolKHR = OP_vkTrimCommandPoolKHR;
    stream->write(&opcode_vkTrimCommandPoolKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkTrimCommandPoolKHR, sizeof(uint32_t));
    uint64_t cgen_var_997;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_997, 1);
    stream->write((uint64_t*)&cgen_var_997, 1 * 8);
    uint64_t cgen_var_998;
    stream->handleMapping()->mapHandles_VkCommandPool_u64(&local_commandPool, &cgen_var_998, 1);
    stream->write((uint64_t*)&cgen_var_998, 1 * 8);
    stream->write((VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
}

#endif
#ifdef VK_KHR_device_group_creation
VkResult VkEncoder::vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    local_instance = instance;
    countingStream->rewind();
    {
        uint64_t cgen_var_999;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_999, 1);
        countingStream->write((uint64_t*)&cgen_var_999, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1000 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
        countingStream->putBe64(cgen_var_1000);
        if (pPhysicalDeviceGroupCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1001 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
        countingStream->putBe64(cgen_var_1001);
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                marshal_VkPhysicalDeviceGroupProperties(countingStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroupsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDeviceGroupsKHR = OP_vkEnumeratePhysicalDeviceGroupsKHR;
    stream->write(&opcode_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t));
    uint64_t cgen_var_1002;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1002, 1);
    stream->write((uint64_t*)&cgen_var_1002, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1003 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    stream->putBe64(cgen_var_1003);
    if (pPhysicalDeviceGroupCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1004 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    stream->putBe64(cgen_var_1004);
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            marshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            transform_fromhost_VkPhysicalDeviceGroupProperties(mImpl->resources(), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(mImpl->resources(), (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1007;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1007, 1);
        countingStream->write((uint64_t*)&cgen_var_1007, 1 * 8);
        marshal_VkPhysicalDeviceExternalBufferInfo(countingStream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
        marshal_VkExternalBufferProperties(countingStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR = OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1008;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1008, 1);
    stream->write((uint64_t*)&cgen_var_1008, 1 * 8);
    marshal_VkPhysicalDeviceExternalBufferInfo(stream, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    marshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        transform_fromhost_VkExternalBufferProperties(mImpl->resources(), (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
}

#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkMemoryGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkMemoryGetWin32HandleInfoKHR));
        deepcopy_VkMemoryGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkMemoryGetWin32HandleInfoKHR(mImpl->resources(), (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1009;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1009, 1);
        countingStream->write((uint64_t*)&cgen_var_1009, 1 * 8);
        marshal_VkMemoryGetWin32HandleInfoKHR(countingStream, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetMemoryWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandleKHR = OP_vkGetMemoryWin32HandleKHR;
    stream->write(&opcode_vkGetMemoryWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1010;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1010, 1);
    stream->write((uint64_t*)&cgen_var_1010, 1 * 8);
    marshal_VkMemoryGetWin32HandleInfoKHR(stream, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    HANDLE local_handle;
    local_device = device;
    local_handleType = handleType;
    local_handle = handle;
    countingStream->rewind();
    {
        uint64_t cgen_var_1011;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1011, 1);
        countingStream->write((uint64_t*)&cgen_var_1011, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((HANDLE*)&local_handle, sizeof(HANDLE));
        marshal_VkMemoryWin32HandlePropertiesKHR(countingStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    uint32_t packetSize_vkGetMemoryWin32HandlePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandlePropertiesKHR = OP_vkGetMemoryWin32HandlePropertiesKHR;
    stream->write(&opcode_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1012;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1012, 1);
    stream->write((uint64_t*)&cgen_var_1012, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((HANDLE*)&local_handle, sizeof(HANDLE));
    marshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    unmarshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    if (pMemoryWin32HandleProperties)
    {
        transform_fromhost_VkMemoryWin32HandlePropertiesKHR(mImpl->resources(), (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_fd
VkResult VkEncoder::vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkMemoryGetFdInfoKHR*)pool->alloc(sizeof(const VkMemoryGetFdInfoKHR));
        deepcopy_VkMemoryGetFdInfoKHR(pool, pGetFdInfo, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkMemoryGetFdInfoKHR(mImpl->resources(), (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1013;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1013, 1);
        countingStream->write((uint64_t*)&cgen_var_1013, 1 * 8);
        marshal_VkMemoryGetFdInfoKHR(countingStream, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetMemoryFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryFdKHR = OP_vkGetMemoryFdKHR;
    stream->write(&opcode_vkGetMemoryFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1014;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1014, 1);
    stream->write((uint64_t*)&cgen_var_1014, 1 * 8);
    marshal_VkMemoryGetFdInfoKHR(stream, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    int local_fd;
    local_device = device;
    local_handleType = handleType;
    local_fd = fd;
    countingStream->rewind();
    {
        uint64_t cgen_var_1015;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1015, 1);
        countingStream->write((uint64_t*)&cgen_var_1015, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((int*)&local_fd, sizeof(int));
        marshal_VkMemoryFdPropertiesKHR(countingStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    uint32_t packetSize_vkGetMemoryFdPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryFdPropertiesKHR = OP_vkGetMemoryFdPropertiesKHR;
    stream->write(&opcode_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1016;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1016, 1);
    stream->write((uint64_t*)&cgen_var_1016, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((int*)&local_fd, sizeof(int));
    marshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    unmarshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    if (pMemoryFdProperties)
    {
        transform_fromhost_VkMemoryFdPropertiesKHR(mImpl->resources(), (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(mImpl->resources(), (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1017;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1017, 1);
        countingStream->write((uint64_t*)&cgen_var_1017, 1 * 8);
        marshal_VkPhysicalDeviceExternalSemaphoreInfo(countingStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
        marshal_VkExternalSemaphoreProperties(countingStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1018;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1018, 1);
    stream->write((uint64_t*)&cgen_var_1018, 1 * 8);
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(mImpl->resources(), (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
}

#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
VkResult VkEncoder::vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportSemaphoreWin32HandleInfoKHR* local_pImportSemaphoreWin32HandleInfo;
    local_device = device;
    local_pImportSemaphoreWin32HandleInfo = nullptr;
    if (pImportSemaphoreWin32HandleInfo)
    {
        local_pImportSemaphoreWin32HandleInfo = (VkImportSemaphoreWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
        deepcopy_VkImportSemaphoreWin32HandleInfoKHR(pool, pImportSemaphoreWin32HandleInfo, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    if (local_pImportSemaphoreWin32HandleInfo)
    {
        transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(mImpl->resources(), (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1019;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1019, 1);
        countingStream->write((uint64_t*)&cgen_var_1019, 1 * 8);
        marshal_VkImportSemaphoreWin32HandleInfoKHR(countingStream, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    uint32_t packetSize_vkImportSemaphoreWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportSemaphoreWin32HandleKHR = OP_vkImportSemaphoreWin32HandleKHR;
    stream->write(&opcode_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1020;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1020, 1);
    stream->write((uint64_t*)&cgen_var_1020, 1 * 8);
    marshal_VkImportSemaphoreWin32HandleInfoKHR(stream, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphoreGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkSemaphoreGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
        deepcopy_VkSemaphoreGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(mImpl->resources(), (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1021;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1021, 1);
        countingStream->write((uint64_t*)&cgen_var_1021, 1 * 8);
        marshal_VkSemaphoreGetWin32HandleInfoKHR(countingStream, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetSemaphoreWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSemaphoreWin32HandleKHR = OP_vkGetSemaphoreWin32HandleKHR;
    stream->write(&opcode_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1022;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1022, 1);
    stream->write((uint64_t*)&cgen_var_1022, 1 * 8);
    marshal_VkSemaphoreGetWin32HandleInfoKHR(stream, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
VkResult VkEncoder::vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportSemaphoreFdInfoKHR* local_pImportSemaphoreFdInfo;
    local_device = device;
    local_pImportSemaphoreFdInfo = nullptr;
    if (pImportSemaphoreFdInfo)
    {
        local_pImportSemaphoreFdInfo = (VkImportSemaphoreFdInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreFdInfoKHR));
        deepcopy_VkImportSemaphoreFdInfoKHR(pool, pImportSemaphoreFdInfo, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    if (local_pImportSemaphoreFdInfo)
    {
        transform_tohost_VkImportSemaphoreFdInfoKHR(mImpl->resources(), (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1023;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1023, 1);
        countingStream->write((uint64_t*)&cgen_var_1023, 1 * 8);
        marshal_VkImportSemaphoreFdInfoKHR(countingStream, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    uint32_t packetSize_vkImportSemaphoreFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportSemaphoreFdKHR = OP_vkImportSemaphoreFdKHR;
    stream->write(&opcode_vkImportSemaphoreFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportSemaphoreFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1024;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1024, 1);
    stream->write((uint64_t*)&cgen_var_1024, 1 * 8);
    marshal_VkImportSemaphoreFdInfoKHR(stream, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSemaphoreGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkSemaphoreGetFdInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetFdInfoKHR));
        deepcopy_VkSemaphoreGetFdInfoKHR(pool, pGetFdInfo, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkSemaphoreGetFdInfoKHR(mImpl->resources(), (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1025;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1025, 1);
        countingStream->write((uint64_t*)&cgen_var_1025, 1 * 8);
        marshal_VkSemaphoreGetFdInfoKHR(countingStream, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetSemaphoreFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSemaphoreFdKHR = OP_vkGetSemaphoreFdKHR;
    stream->write(&opcode_vkGetSemaphoreFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSemaphoreFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1026;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1026, 1);
    stream->write((uint64_t*)&cgen_var_1026, 1 * 8);
    marshal_VkSemaphoreGetFdInfoKHR(stream, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetSemaphoreFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_push_descriptor
void VkEncoder::vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_set = set;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(mImpl->resources(), (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1027;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1027, 1);
        countingStream->write((uint64_t*)&cgen_var_1027, 1 * 8);
        countingStream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
        uint64_t cgen_var_1028;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1028, 1);
        countingStream->write((uint64_t*)&cgen_var_1028, 1 * 8);
        countingStream->write((uint32_t*)&local_set, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            marshal_VkWriteDescriptorSet(countingStream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushDescriptorSetKHR = OP_vkCmdPushDescriptorSetKHR;
    stream->write(&opcode_vkCmdPushDescriptorSetKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushDescriptorSetKHR, sizeof(uint32_t));
    uint64_t cgen_var_1029;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1029, 1);
    stream->write((uint64_t*)&cgen_var_1029, 1 * 8);
    stream->write((VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_1030;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1030, 1);
    stream->write((uint64_t*)&cgen_var_1030, 1 * 8);
    stream->write((uint32_t*)&local_set, sizeof(uint32_t));
    stream->write((uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(stream, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
    }
}

void VkEncoder::vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_layout = layout;
    local_set = set;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1031;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1031, 1);
        countingStream->write((uint64_t*)&cgen_var_1031, 1 * 8);
        uint64_t cgen_var_1032;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1032, 1);
        countingStream->write((uint64_t*)&cgen_var_1032, 1 * 8);
        uint64_t cgen_var_1033;
        countingStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1033, 1);
        countingStream->write((uint64_t*)&cgen_var_1033, 1 * 8);
        countingStream->write((uint32_t*)&local_set, sizeof(uint32_t));
        // WARNING PTR CHECK
        uint64_t cgen_var_1034 = (uint64_t)(uintptr_t)local_pData;
        countingStream->putBe64(cgen_var_1034);
        if (local_pData)
        {
            countingStream->write((void*)local_pData, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetWithTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushDescriptorSetWithTemplateKHR = OP_vkCmdPushDescriptorSetWithTemplateKHR;
    stream->write(&opcode_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1035;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1035, 1);
    stream->write((uint64_t*)&cgen_var_1035, 1 * 8);
    uint64_t cgen_var_1036;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1036, 1);
    stream->write((uint64_t*)&cgen_var_1036, 1 * 8);
    uint64_t cgen_var_1037;
    stream->handleMapping()->mapHandles_VkPipelineLayout_u64(&local_layout, &cgen_var_1037, 1);
    stream->write((uint64_t*)&cgen_var_1037, 1 * 8);
    stream->write((uint32_t*)&local_set, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_1038 = (uint64_t)(uintptr_t)local_pData;
    stream->putBe64(cgen_var_1038);
    if (local_pData)
    {
        stream->write((void*)local_pData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
VkResult VkEncoder::vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(mImpl->resources(), (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1039;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1039, 1);
        countingStream->write((uint64_t*)&cgen_var_1039, 1 * 8);
        marshal_VkDescriptorUpdateTemplateCreateInfo(countingStream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1040 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1040);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1041;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_1041, 1);
        countingStream->write((uint64_t*)&cgen_var_1041, 8);
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorUpdateTemplateKHR = OP_vkCreateDescriptorUpdateTemplateKHR;
    stream->write(&opcode_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1042;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1042, 1);
    stream->write((uint64_t*)&cgen_var_1042, 1 * 8);
    marshal_VkDescriptorUpdateTemplateCreateInfo(stream, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1043 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1043);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1044;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(pDescriptorUpdateTemplate, &cgen_var_1044, 1);
    stream->write((uint64_t*)&cgen_var_1044, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1045;
    stream->read((uint64_t*)&cgen_var_1045, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_1045, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1046;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1046, 1);
        countingStream->write((uint64_t*)&cgen_var_1046, 1 * 8);
        uint64_t cgen_var_1047;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1047, 1);
        countingStream->write((uint64_t*)&cgen_var_1047, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1048 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1048);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorUpdateTemplateKHR = OP_vkDestroyDescriptorUpdateTemplateKHR;
    stream->write(&opcode_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1049;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1049, 1);
    stream->write((uint64_t*)&cgen_var_1049, 1 * 8);
    uint64_t cgen_var_1050;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1050, 1);
    stream->write((uint64_t*)&cgen_var_1050, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1051 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1051);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
}

void VkEncoder::vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pData = nullptr;
    if (pData)
    {
        local_pData = (void*)pool->dupArray(pData, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1052;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1052, 1);
        countingStream->write((uint64_t*)&cgen_var_1052, 1 * 8);
        uint64_t cgen_var_1053;
        countingStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_1053, 1);
        countingStream->write((uint64_t*)&cgen_var_1053, 1 * 8);
        uint64_t cgen_var_1054;
        countingStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1054, 1);
        countingStream->write((uint64_t*)&cgen_var_1054, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1055 = (uint64_t)(uintptr_t)local_pData;
        countingStream->putBe64(cgen_var_1055);
        if (local_pData)
        {
            countingStream->write((void*)local_pData, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateKHR = OP_vkUpdateDescriptorSetWithTemplateKHR;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    uint64_t cgen_var_1056;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1056, 1);
    stream->write((uint64_t*)&cgen_var_1056, 1 * 8);
    uint64_t cgen_var_1057;
    stream->handleMapping()->mapHandles_VkDescriptorSet_u64(&local_descriptorSet, &cgen_var_1057, 1);
    stream->write((uint64_t*)&cgen_var_1057, 1 * 8);
    uint64_t cgen_var_1058;
    stream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate_u64(&local_descriptorUpdateTemplate, &cgen_var_1058, 1);
    stream->write((uint64_t*)&cgen_var_1058, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1059 = (uint64_t)(uintptr_t)local_pData;
    stream->putBe64(cgen_var_1059);
    if (local_pData)
    {
        stream->write((void*)local_pData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_KHR_create_renderpass2
VkResult VkEncoder::vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2KHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkRenderPassCreateInfo2KHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo2KHR*)pool->alloc(sizeof(const VkRenderPassCreateInfo2KHR));
        deepcopy_VkRenderPassCreateInfo2KHR(pool, pCreateInfo, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo2KHR(mImpl->resources(), (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1060;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1060, 1);
        countingStream->write((uint64_t*)&cgen_var_1060, 1 * 8);
        marshal_VkRenderPassCreateInfo2KHR(countingStream, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1061 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1061);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1062;
        countingStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_1062, 1);
        countingStream->write((uint64_t*)&cgen_var_1062, 8);
    }
    uint32_t packetSize_vkCreateRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateRenderPass2KHR = OP_vkCreateRenderPass2KHR;
    stream->write(&opcode_vkCreateRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateRenderPass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1063;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1063, 1);
    stream->write((uint64_t*)&cgen_var_1063, 1 * 8);
    marshal_VkRenderPassCreateInfo2KHR(stream, (VkRenderPassCreateInfo2KHR*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1064 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1064);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1065;
    stream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_1065, 1);
    stream->write((uint64_t*)&cgen_var_1065, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1066;
    stream->read((uint64_t*)&cgen_var_1066, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_1066, (VkRenderPass*)pRenderPass, 1);
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateRenderPass2KHR_VkResult_return;
}

void VkEncoder::vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassBeginInfoKHR* local_pSubpassBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfoKHR*)pool->alloc(sizeof(const VkSubpassBeginInfoKHR));
        deepcopy_VkSubpassBeginInfoKHR(pool, pSubpassBeginInfo, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(mImpl->resources(), (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfoKHR(mImpl->resources(), (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1067;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1067, 1);
        countingStream->write((uint64_t*)&cgen_var_1067, 1 * 8);
        marshal_VkRenderPassBeginInfo(countingStream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
        marshal_VkSubpassBeginInfoKHR(countingStream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    uint32_t packetSize_vkCmdBeginRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginRenderPass2KHR = OP_vkCmdBeginRenderPass2KHR;
    stream->write(&opcode_vkCmdBeginRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginRenderPass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1068;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1068, 1);
    stream->write((uint64_t*)&cgen_var_1068, 1 * 8);
    marshal_VkRenderPassBeginInfo(stream, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    marshal_VkSubpassBeginInfoKHR(stream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
}

void VkEncoder::vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSubpassBeginInfoKHR* local_pSubpassBeginInfo;
    VkSubpassEndInfoKHR* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfoKHR*)pool->alloc(sizeof(const VkSubpassBeginInfoKHR));
        deepcopy_VkSubpassBeginInfoKHR(pool, pSubpassBeginInfo, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfoKHR*)pool->alloc(sizeof(const VkSubpassEndInfoKHR));
        deepcopy_VkSubpassEndInfoKHR(pool, pSubpassEndInfo, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfoKHR(mImpl->resources(), (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfoKHR(mImpl->resources(), (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1069;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1069, 1);
        countingStream->write((uint64_t*)&cgen_var_1069, 1 * 8);
        marshal_VkSubpassBeginInfoKHR(countingStream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
        marshal_VkSubpassEndInfoKHR(countingStream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    uint32_t packetSize_vkCmdNextSubpass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdNextSubpass2KHR = OP_vkCmdNextSubpass2KHR;
    stream->write(&opcode_vkCmdNextSubpass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdNextSubpass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1070;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1070, 1);
    stream->write((uint64_t*)&cgen_var_1070, 1 * 8);
    marshal_VkSubpassBeginInfoKHR(stream, (VkSubpassBeginInfoKHR*)(local_pSubpassBeginInfo));
    marshal_VkSubpassEndInfoKHR(stream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
}

void VkEncoder::vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSubpassEndInfoKHR* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfoKHR*)pool->alloc(sizeof(const VkSubpassEndInfoKHR));
        deepcopy_VkSubpassEndInfoKHR(pool, pSubpassEndInfo, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfoKHR(mImpl->resources(), (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1071;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1071, 1);
        countingStream->write((uint64_t*)&cgen_var_1071, 1 * 8);
        marshal_VkSubpassEndInfoKHR(countingStream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
    }
    uint32_t packetSize_vkCmdEndRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndRenderPass2KHR = OP_vkCmdEndRenderPass2KHR;
    stream->write(&opcode_vkCmdEndRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndRenderPass2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1072;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1072, 1);
    stream->write((uint64_t*)&cgen_var_1072, 1 * 8);
    marshal_VkSubpassEndInfoKHR(stream, (VkSubpassEndInfoKHR*)(local_pSubpassEndInfo));
}

#endif
#ifdef VK_KHR_shared_presentable_image
VkResult VkEncoder::vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_1073;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1073, 1);
        countingStream->write((uint64_t*)&cgen_var_1073, 1 * 8);
        uint64_t cgen_var_1074;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1074, 1);
        countingStream->write((uint64_t*)&cgen_var_1074, 1 * 8);
    }
    uint32_t packetSize_vkGetSwapchainStatusKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainStatusKHR = OP_vkGetSwapchainStatusKHR;
    stream->write(&opcode_vkGetSwapchainStatusKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainStatusKHR, sizeof(uint32_t));
    uint64_t cgen_var_1075;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1075, 1);
    stream->write((uint64_t*)&cgen_var_1075, 1 * 8);
    uint64_t cgen_var_1076;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1076, 1);
    stream->write((uint64_t*)&cgen_var_1076, 1 * 8);
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetSwapchainStatusKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(mImpl->resources(), (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1077;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1077, 1);
        countingStream->write((uint64_t*)&cgen_var_1077, 1 * 8);
        marshal_VkPhysicalDeviceExternalFenceInfo(countingStream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
        marshal_VkExternalFenceProperties(countingStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR = OP_vkGetPhysicalDeviceExternalFencePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t));
    uint64_t cgen_var_1078;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1078, 1);
    stream->write((uint64_t*)&cgen_var_1078, 1 * 8);
    marshal_VkPhysicalDeviceExternalFenceInfo(stream, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    marshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(mImpl->resources(), (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
}

#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
VkResult VkEncoder::vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportFenceWin32HandleInfoKHR* local_pImportFenceWin32HandleInfo;
    local_device = device;
    local_pImportFenceWin32HandleInfo = nullptr;
    if (pImportFenceWin32HandleInfo)
    {
        local_pImportFenceWin32HandleInfo = (VkImportFenceWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportFenceWin32HandleInfoKHR));
        deepcopy_VkImportFenceWin32HandleInfoKHR(pool, pImportFenceWin32HandleInfo, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    if (local_pImportFenceWin32HandleInfo)
    {
        transform_tohost_VkImportFenceWin32HandleInfoKHR(mImpl->resources(), (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1079;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1079, 1);
        countingStream->write((uint64_t*)&cgen_var_1079, 1 * 8);
        marshal_VkImportFenceWin32HandleInfoKHR(countingStream, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    uint32_t packetSize_vkImportFenceWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportFenceWin32HandleKHR = OP_vkImportFenceWin32HandleKHR;
    stream->write(&opcode_vkImportFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportFenceWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1080;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1080, 1);
    stream->write((uint64_t*)&cgen_var_1080, 1 * 8);
    marshal_VkImportFenceWin32HandleInfoKHR(stream, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFenceGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkFenceGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkFenceGetWin32HandleInfoKHR));
        deepcopy_VkFenceGetWin32HandleInfoKHR(pool, pGetWin32HandleInfo, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkFenceGetWin32HandleInfoKHR(mImpl->resources(), (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1081;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1081, 1);
        countingStream->write((uint64_t*)&cgen_var_1081, 1 * 8);
        marshal_VkFenceGetWin32HandleInfoKHR(countingStream, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetFenceWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceWin32HandleKHR = OP_vkGetFenceWin32HandleKHR;
    stream->write(&opcode_vkGetFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceWin32HandleKHR, sizeof(uint32_t));
    uint64_t cgen_var_1082;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1082, 1);
    stream->write((uint64_t*)&cgen_var_1082, 1 * 8);
    marshal_VkFenceGetWin32HandleInfoKHR(stream, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetFenceWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_fd
VkResult VkEncoder::vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImportFenceFdInfoKHR* local_pImportFenceFdInfo;
    local_device = device;
    local_pImportFenceFdInfo = nullptr;
    if (pImportFenceFdInfo)
    {
        local_pImportFenceFdInfo = (VkImportFenceFdInfoKHR*)pool->alloc(sizeof(const VkImportFenceFdInfoKHR));
        deepcopy_VkImportFenceFdInfoKHR(pool, pImportFenceFdInfo, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    if (local_pImportFenceFdInfo)
    {
        transform_tohost_VkImportFenceFdInfoKHR(mImpl->resources(), (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1083;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1083, 1);
        countingStream->write((uint64_t*)&cgen_var_1083, 1 * 8);
        marshal_VkImportFenceFdInfoKHR(countingStream, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    uint32_t packetSize_vkImportFenceFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportFenceFdKHR = OP_vkImportFenceFdKHR;
    stream->write(&opcode_vkImportFenceFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportFenceFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1084;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1084, 1);
    stream->write((uint64_t*)&cgen_var_1084, 1 * 8);
    marshal_VkImportFenceFdInfoKHR(stream, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkImportFenceFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFenceGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkFenceGetFdInfoKHR*)pool->alloc(sizeof(const VkFenceGetFdInfoKHR));
        deepcopy_VkFenceGetFdInfoKHR(pool, pGetFdInfo, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkFenceGetFdInfoKHR(mImpl->resources(), (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1085;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1085, 1);
        countingStream->write((uint64_t*)&cgen_var_1085, 1 * 8);
        marshal_VkFenceGetFdInfoKHR(countingStream, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetFenceFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceFdKHR = OP_vkGetFenceFdKHR;
    stream->write(&opcode_vkGetFenceFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceFdKHR, sizeof(uint32_t));
    uint64_t cgen_var_1086;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1086, 1);
    stream->write((uint64_t*)&cgen_var_1086, 1 * 8);
    marshal_VkFenceGetFdInfoKHR(stream, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetFenceFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(mImpl->resources(), (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1087;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1087, 1);
        countingStream->write((uint64_t*)&cgen_var_1087, 1 * 8);
        marshal_VkPhysicalDeviceSurfaceInfo2KHR(countingStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
        marshal_VkSurfaceCapabilities2KHR(countingStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR = OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1088;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1088, 1);
    stream->write((uint64_t*)&cgen_var_1088, 1 * 8);
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    marshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    unmarshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2KHR(mImpl->resources(), (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(mImpl->resources(), (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1089;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1089, 1);
        countingStream->write((uint64_t*)&cgen_var_1089, 1 * 8);
        marshal_VkPhysicalDeviceSurfaceInfo2KHR(countingStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1090 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
        countingStream->putBe64(cgen_var_1090);
        if (pSurfaceFormatCount)
        {
            countingStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1091 = (uint64_t)(uintptr_t)pSurfaceFormats;
        countingStream->putBe64(cgen_var_1091);
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                marshal_VkSurfaceFormat2KHR(countingStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormats2KHR = OP_vkGetPhysicalDeviceSurfaceFormats2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1092;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1092, 1);
    stream->write((uint64_t*)&cgen_var_1092, 1 * 8);
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1093 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    stream->putBe64(cgen_var_1093);
    if (pSurfaceFormatCount)
    {
        stream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1094 = (uint64_t)(uintptr_t)pSurfaceFormats;
    stream->putBe64(cgen_var_1094);
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            marshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormat2KHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            transform_fromhost_VkSurfaceFormat2KHR(mImpl->resources(), (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
VkResult VkEncoder::vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_1097;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1097, 1);
        countingStream->write((uint64_t*)&cgen_var_1097, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1098 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_1098);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1099 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_1099);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayProperties2KHR(countingStream, (VkDisplayProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayProperties2KHR = OP_vkGetPhysicalDeviceDisplayProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1100;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1100, 1);
    stream->write((uint64_t*)&cgen_var_1100, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1101 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_1101);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1102 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1102);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayProperties2KHR(mImpl->resources(), (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_1105;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1105, 1);
        countingStream->write((uint64_t*)&cgen_var_1105, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1106 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_1106);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1107 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_1107);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPlaneProperties2KHR(countingStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1108;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1108, 1);
    stream->write((uint64_t*)&cgen_var_1108, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1109 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_1109);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1110 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1110);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlaneProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayPlaneProperties2KHR(mImpl->resources(), (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_1113;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1113, 1);
        countingStream->write((uint64_t*)&cgen_var_1113, 1 * 8);
        uint64_t cgen_var_1114;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1114, 1);
        countingStream->write((uint64_t*)&cgen_var_1114, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1115 = (uint64_t)(uintptr_t)pPropertyCount;
        countingStream->putBe64(cgen_var_1115);
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1116 = (uint64_t)(uintptr_t)pProperties;
        countingStream->putBe64(cgen_var_1116);
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayModeProperties2KHR(countingStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModeProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayModeProperties2KHR = OP_vkGetDisplayModeProperties2KHR;
    stream->write(&opcode_vkGetDisplayModeProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayModeProperties2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1117;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1117, 1);
    stream->write((uint64_t*)&cgen_var_1117, 1 * 8);
    uint64_t cgen_var_1118;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1118, 1);
    stream->write((uint64_t*)&cgen_var_1118, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1119 = (uint64_t)(uintptr_t)pPropertyCount;
    stream->putBe64(cgen_var_1119);
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1120 = (uint64_t)(uintptr_t)pProperties;
    stream->putBe64(cgen_var_1120);
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModeProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            transform_fromhost_VkDisplayModeProperties2KHR(mImpl->resources(), (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayPlaneInfo2KHR* local_pDisplayPlaneInfo;
    local_physicalDevice = physicalDevice;
    local_pDisplayPlaneInfo = nullptr;
    if (pDisplayPlaneInfo)
    {
        local_pDisplayPlaneInfo = (VkDisplayPlaneInfo2KHR*)pool->alloc(sizeof(const VkDisplayPlaneInfo2KHR));
        deepcopy_VkDisplayPlaneInfo2KHR(pool, pDisplayPlaneInfo, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    if (local_pDisplayPlaneInfo)
    {
        transform_tohost_VkDisplayPlaneInfo2KHR(mImpl->resources(), (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1123;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1123, 1);
        countingStream->write((uint64_t*)&cgen_var_1123, 1 * 8);
        marshal_VkDisplayPlaneInfo2KHR(countingStream, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
        marshal_VkDisplayPlaneCapabilities2KHR(countingStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilities2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneCapabilities2KHR = OP_vkGetDisplayPlaneCapabilities2KHR;
    stream->write(&opcode_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1124;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1124, 1);
    stream->write((uint64_t*)&cgen_var_1124, 1 * 8);
    marshal_VkDisplayPlaneInfo2KHR(stream, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    marshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    unmarshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilities2KHR(mImpl->resources(), (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkEncoder::vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(mImpl->resources(), (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1125;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1125, 1);
        countingStream->write((uint64_t*)&cgen_var_1125, 1 * 8);
        marshal_VkImageMemoryRequirementsInfo2(countingStream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements2KHR = OP_vkGetImageMemoryRequirements2KHR;
    stream->write(&opcode_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1126;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1126, 1);
    stream->write((uint64_t*)&cgen_var_1126, 1 * 8);
    marshal_VkImageMemoryRequirementsInfo2(stream, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
}

void VkEncoder::vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(mImpl->resources(), (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1127;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1127, 1);
        countingStream->write((uint64_t*)&cgen_var_1127, 1 * 8);
        marshal_VkBufferMemoryRequirementsInfo2(countingStream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements2KHR = OP_vkGetBufferMemoryRequirements2KHR;
    stream->write(&opcode_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1128;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1128, 1);
    stream->write((uint64_t*)&cgen_var_1128, 1 * 8);
    marshal_VkBufferMemoryRequirementsInfo2(stream, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(mImpl->resources(), (VkMemoryRequirements2*)(pMemoryRequirements));
    }
}

void VkEncoder::vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(mImpl->resources(), (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1129;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1129, 1);
        countingStream->write((uint64_t*)&cgen_var_1129, 1 * 8);
        marshal_VkImageSparseMemoryRequirementsInfo2(countingStream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1130 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
        countingStream->putBe64(cgen_var_1130);
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1131 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
        countingStream->putBe64(cgen_var_1131);
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements2(countingStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements2KHR = OP_vkGetImageSparseMemoryRequirements2KHR;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1132;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1132, 1);
    stream->write((uint64_t*)&cgen_var_1132, 1 * 8);
    marshal_VkImageSparseMemoryRequirementsInfo2(stream, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1133 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    stream->putBe64(cgen_var_1133);
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1134 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    stream->putBe64(cgen_var_1134);
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            transform_fromhost_VkSparseImageMemoryRequirements2(mImpl->resources(), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
}

#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult VkEncoder::vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(mImpl->resources(), (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1137;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1137, 1);
        countingStream->write((uint64_t*)&cgen_var_1137, 1 * 8);
        marshal_VkSamplerYcbcrConversionCreateInfo(countingStream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1138 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1138);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1139;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_1139, 1);
        countingStream->write((uint64_t*)&cgen_var_1139, 8);
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversionKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSamplerYcbcrConversionKHR = OP_vkCreateSamplerYcbcrConversionKHR;
    stream->write(&opcode_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t));
    uint64_t cgen_var_1140;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1140, 1);
    stream->write((uint64_t*)&cgen_var_1140, 1 * 8);
    marshal_VkSamplerYcbcrConversionCreateInfo(stream, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1141 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1141);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1142;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(pYcbcrConversion, &cgen_var_1142, 1);
    stream->write((uint64_t*)&cgen_var_1142, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1143;
    stream->read((uint64_t*)&cgen_var_1143, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_1143, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1144;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1144, 1);
        countingStream->write((uint64_t*)&cgen_var_1144, 1 * 8);
        uint64_t cgen_var_1145;
        countingStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_1145, 1);
        countingStream->write((uint64_t*)&cgen_var_1145, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1146 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1146);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversionKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySamplerYcbcrConversionKHR = OP_vkDestroySamplerYcbcrConversionKHR;
    stream->write(&opcode_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t));
    uint64_t cgen_var_1147;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1147, 1);
    stream->write((uint64_t*)&cgen_var_1147, 1 * 8);
    uint64_t cgen_var_1148;
    stream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&local_ycbcrConversion, &cgen_var_1148, 1);
    stream->write((uint64_t*)&cgen_var_1148, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1149 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1149);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
}

#endif
#ifdef VK_KHR_bind_memory2
VkResult VkEncoder::vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(mImpl->resources(), (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1150;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1150, 1);
        countingStream->write((uint64_t*)&cgen_var_1150, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindBufferMemoryInfo(countingStream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindBufferMemory2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory2KHR = OP_vkBindBufferMemory2KHR;
    stream->write(&opcode_vkBindBufferMemory2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1151;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1151, 1);
    stream->write((uint64_t*)&cgen_var_1151, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(stream, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
    }
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBindBufferMemory2KHR_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(mImpl->resources(), (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1152;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1152, 1);
        countingStream->write((uint64_t*)&cgen_var_1152, 1 * 8);
        countingStream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindImageMemoryInfo(countingStream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindImageMemory2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory2KHR = OP_vkBindImageMemory2KHR;
    stream->write(&opcode_vkBindImageMemory2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory2KHR, sizeof(uint32_t));
    uint64_t cgen_var_1153;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1153, 1);
    stream->write((uint64_t*)&cgen_var_1153, 1 * 8);
    stream->write((uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(stream, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
    }
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkBindImageMemory2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance3
void VkEncoder::vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(mImpl->resources(), (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1154;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1154, 1);
        countingStream->write((uint64_t*)&cgen_var_1154, 1 * 8);
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
        marshal_VkDescriptorSetLayoutSupport(countingStream, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDescriptorSetLayoutSupportKHR = OP_vkGetDescriptorSetLayoutSupportKHR;
    stream->write(&opcode_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t));
    uint64_t cgen_var_1155;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1155, 1);
    stream->write((uint64_t*)&cgen_var_1155, 1 * 8);
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(mImpl->resources(), (VkDescriptorSetLayoutSupport*)(pSupport));
    }
}

#endif
#ifdef VK_KHR_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1156;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1156, 1);
        countingStream->write((uint64_t*)&cgen_var_1156, 1 * 8);
        uint64_t cgen_var_1157;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1157, 1);
        countingStream->write((uint64_t*)&cgen_var_1157, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1158;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1158, 1);
        countingStream->write((uint64_t*)&cgen_var_1158, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirectCountKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirectCountKHR = OP_vkCmdDrawIndirectCountKHR;
    stream->write(&opcode_vkCmdDrawIndirectCountKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirectCountKHR, sizeof(uint32_t));
    uint64_t cgen_var_1159;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1159, 1);
    stream->write((uint64_t*)&cgen_var_1159, 1 * 8);
    uint64_t cgen_var_1160;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1160, 1);
    stream->write((uint64_t*)&cgen_var_1160, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1161;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1161, 1);
    stream->write((uint64_t*)&cgen_var_1161, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1162;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1162, 1);
        countingStream->write((uint64_t*)&cgen_var_1162, 1 * 8);
        uint64_t cgen_var_1163;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1163, 1);
        countingStream->write((uint64_t*)&cgen_var_1163, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1164;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1164, 1);
        countingStream->write((uint64_t*)&cgen_var_1164, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirectCountKHR = OP_vkCmdDrawIndexedIndirectCountKHR;
    stream->write(&opcode_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t));
    uint64_t cgen_var_1165;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1165, 1);
    stream->write((uint64_t*)&cgen_var_1165, 1 * 8);
    uint64_t cgen_var_1166;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1166, 1);
    stream->write((uint64_t*)&cgen_var_1166, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1167;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1167, 1);
    stream->write((uint64_t*)&cgen_var_1167, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_ANDROID_native_buffer
VkResult VkEncoder::vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
    VkFormat format,
    VkImageUsageFlags imageUsage,
    int* grallocUsage)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkFormat local_format;
    VkImageUsageFlags local_imageUsage;
    local_device = device;
    local_format = format;
    local_imageUsage = imageUsage;
    countingStream->rewind();
    {
        uint64_t cgen_var_1168;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1168, 1);
        countingStream->write((uint64_t*)&cgen_var_1168, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageUsageFlags*)&local_imageUsage, sizeof(VkImageUsageFlags));
        countingStream->write((int*)grallocUsage, sizeof(int));
    }
    uint32_t packetSize_vkGetSwapchainGrallocUsageANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainGrallocUsageANDROID = OP_vkGetSwapchainGrallocUsageANDROID;
    stream->write(&opcode_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1169;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1169, 1);
    stream->write((uint64_t*)&cgen_var_1169, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageUsageFlags*)&local_imageUsage, sizeof(VkImageUsageFlags));
    stream->write((int*)grallocUsage, sizeof(int));
    stream->read((int*)grallocUsage, sizeof(int));
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}

VkResult VkEncoder::vkAcquireImageANDROID(
    VkDevice device,
    VkImage image,
    int nativeFenceFd,
    VkSemaphore semaphore,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkImage local_image;
    int local_nativeFenceFd;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_image = image;
    local_nativeFenceFd = nativeFenceFd;
    local_semaphore = semaphore;
    local_fence = fence;
    mImpl->resources()->unwrap_vkAcquireImageANDROID_nativeFenceFd(nativeFenceFd, &local_nativeFenceFd);
    countingStream->rewind();
    {
        uint64_t cgen_var_1170;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1170, 1);
        countingStream->write((uint64_t*)&cgen_var_1170, 1 * 8);
        uint64_t cgen_var_1171;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1171, 1);
        countingStream->write((uint64_t*)&cgen_var_1171, 1 * 8);
        countingStream->write((int*)&local_nativeFenceFd, sizeof(int));
        uint64_t cgen_var_1172;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_1172, 1);
        countingStream->write((uint64_t*)&cgen_var_1172, 1 * 8);
        uint64_t cgen_var_1173;
        countingStream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_1173, 1);
        countingStream->write((uint64_t*)&cgen_var_1173, 1 * 8);
    }
    uint32_t packetSize_vkAcquireImageANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireImageANDROID = OP_vkAcquireImageANDROID;
    stream->write(&opcode_vkAcquireImageANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireImageANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1174;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1174, 1);
    stream->write((uint64_t*)&cgen_var_1174, 1 * 8);
    uint64_t cgen_var_1175;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1175, 1);
    stream->write((uint64_t*)&cgen_var_1175, 1 * 8);
    stream->write((int*)&local_nativeFenceFd, sizeof(int));
    uint64_t cgen_var_1176;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(&local_semaphore, &cgen_var_1176, 1);
    stream->write((uint64_t*)&cgen_var_1176, 1 * 8);
    uint64_t cgen_var_1177;
    stream->handleMapping()->mapHandles_VkFence_u64(&local_fence, &cgen_var_1177, 1);
    stream->write((uint64_t*)&cgen_var_1177, 1 * 8);
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAcquireImageANDROID_VkResult_return;
}

VkResult VkEncoder::vkQueueSignalReleaseImageANDROID(
    VkQueue queue,
    uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores,
    VkImage image,
    int* pNativeFenceFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    uint32_t local_waitSemaphoreCount;
    VkSemaphore* local_pWaitSemaphores;
    VkImage local_image;
    local_queue = queue;
    local_waitSemaphoreCount = waitSemaphoreCount;
    local_pWaitSemaphores = nullptr;
    if (pWaitSemaphores)
    {
        local_pWaitSemaphores = (VkSemaphore*)pool->dupArray(pWaitSemaphores, sizeof(const VkSemaphore));
    }
    local_image = image;
    countingStream->rewind();
    {
        uint64_t cgen_var_1178;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1178, 1);
        countingStream->write((uint64_t*)&cgen_var_1178, 1 * 8);
        countingStream->write((uint32_t*)&local_waitSemaphoreCount, sizeof(uint32_t));
        uint64_t cgen_var_1179;
        countingStream->handleMapping()->mapHandles_VkSemaphore_u64(local_pWaitSemaphores, &cgen_var_1179, 1);
        countingStream->write((uint64_t*)&cgen_var_1179, 8);
        uint64_t cgen_var_1180;
        countingStream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1180, 1);
        countingStream->write((uint64_t*)&cgen_var_1180, 1 * 8);
        countingStream->write((int*)pNativeFenceFd, sizeof(int));
    }
    uint32_t packetSize_vkQueueSignalReleaseImageANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueSignalReleaseImageANDROID = OP_vkQueueSignalReleaseImageANDROID;
    stream->write(&opcode_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1181;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1181, 1);
    stream->write((uint64_t*)&cgen_var_1181, 1 * 8);
    stream->write((uint32_t*)&local_waitSemaphoreCount, sizeof(uint32_t));
    uint64_t cgen_var_1182;
    stream->handleMapping()->mapHandles_VkSemaphore_u64(local_pWaitSemaphores, &cgen_var_1182, 1);
    stream->write((uint64_t*)&cgen_var_1182, 8);
    uint64_t cgen_var_1183;
    stream->handleMapping()->mapHandles_VkImage_u64(&local_image, &cgen_var_1183, 1);
    stream->write((uint64_t*)&cgen_var_1183, 1 * 8);
    stream->write((int*)pNativeFenceFd, sizeof(int));
    stream->read((int*)pNativeFenceFd, sizeof(int));
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_debug_report
VkResult VkEncoder::vkCreateDebugReportCallbackEXT(
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugReportCallbackCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugReportCallbackCreateInfoEXT*)pool->alloc(sizeof(const VkDebugReportCallbackCreateInfoEXT));
        deepcopy_VkDebugReportCallbackCreateInfoEXT(pool, pCreateInfo, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugReportCallbackCreateInfoEXT(mImpl->resources(), (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1184;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1184, 1);
        countingStream->write((uint64_t*)&cgen_var_1184, 1 * 8);
        marshal_VkDebugReportCallbackCreateInfoEXT(countingStream, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1185 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1185);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1186;
        countingStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(pCallback, &cgen_var_1186, 1);
        countingStream->write((uint64_t*)&cgen_var_1186, 8);
    }
    uint32_t packetSize_vkCreateDebugReportCallbackEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDebugReportCallbackEXT = OP_vkCreateDebugReportCallbackEXT;
    stream->write(&opcode_vkCreateDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDebugReportCallbackEXT, sizeof(uint32_t));
    uint64_t cgen_var_1187;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1187, 1);
    stream->write((uint64_t*)&cgen_var_1187, 1 * 8);
    marshal_VkDebugReportCallbackCreateInfoEXT(stream, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1188 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1188);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1189;
    stream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(pCallback, &cgen_var_1189, 1);
    stream->write((uint64_t*)&cgen_var_1189, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1190;
    stream->read((uint64_t*)&cgen_var_1190, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_1190, (VkDebugReportCallbackEXT*)pCallback, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDebugReportCallbackEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugReportCallbackEXT local_callback;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_callback = callback;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1191;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1191, 1);
        countingStream->write((uint64_t*)&cgen_var_1191, 1 * 8);
        uint64_t cgen_var_1192;
        countingStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(&local_callback, &cgen_var_1192, 1);
        countingStream->write((uint64_t*)&cgen_var_1192, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1193 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1193);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDebugReportCallbackEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDebugReportCallbackEXT = OP_vkDestroyDebugReportCallbackEXT;
    stream->write(&opcode_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t));
    uint64_t cgen_var_1194;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1194, 1);
    stream->write((uint64_t*)&cgen_var_1194, 1 * 8);
    uint64_t cgen_var_1195;
    stream->handleMapping()->mapHandles_VkDebugReportCallbackEXT_u64(&local_callback, &cgen_var_1195, 1);
    stream->write((uint64_t*)&cgen_var_1195, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1196 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1196);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)&callback);
}

void VkEncoder::vkDebugReportMessageEXT(
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugReportFlagsEXT local_flags;
    VkDebugReportObjectTypeEXT local_objectType;
    uint64_t local_object;
    size_t local_location;
    int32_t local_messageCode;
    char* local_pLayerPrefix;
    char* local_pMessage;
    local_instance = instance;
    local_flags = flags;
    local_objectType = objectType;
    local_object = object;
    local_location = location;
    local_messageCode = messageCode;
    local_pLayerPrefix = nullptr;
    if (pLayerPrefix)
    {
        local_pLayerPrefix = pool->strDup(pLayerPrefix);
    }
    local_pMessage = nullptr;
    if (pMessage)
    {
        local_pMessage = pool->strDup(pMessage);
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1197;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1197, 1);
        countingStream->write((uint64_t*)&cgen_var_1197, 1 * 8);
        countingStream->write((VkDebugReportFlagsEXT*)&local_flags, sizeof(VkDebugReportFlagsEXT));
        countingStream->write((VkDebugReportObjectTypeEXT*)&local_objectType, sizeof(VkDebugReportObjectTypeEXT));
        countingStream->write((uint64_t*)&local_object, sizeof(uint64_t));
        uint64_t cgen_var_1198 = (uint64_t)local_location;
        countingStream->putBe64(cgen_var_1198);
        countingStream->write((int32_t*)&local_messageCode, sizeof(int32_t));
        countingStream->putString(local_pLayerPrefix);
        countingStream->putString(local_pMessage);
    }
    uint32_t packetSize_vkDebugReportMessageEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugReportMessageEXT = OP_vkDebugReportMessageEXT;
    stream->write(&opcode_vkDebugReportMessageEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugReportMessageEXT, sizeof(uint32_t));
    uint64_t cgen_var_1199;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1199, 1);
    stream->write((uint64_t*)&cgen_var_1199, 1 * 8);
    stream->write((VkDebugReportFlagsEXT*)&local_flags, sizeof(VkDebugReportFlagsEXT));
    stream->write((VkDebugReportObjectTypeEXT*)&local_objectType, sizeof(VkDebugReportObjectTypeEXT));
    stream->write((uint64_t*)&local_object, sizeof(uint64_t));
    uint64_t cgen_var_1200 = (uint64_t)local_location;
    stream->putBe64(cgen_var_1200);
    stream->write((int32_t*)&local_messageCode, sizeof(int32_t));
    stream->putString(local_pLayerPrefix);
    stream->putString(local_pMessage);
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
VkResult VkEncoder::vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugMarkerObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugMarkerObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectTagInfoEXT));
        deepcopy_VkDebugMarkerObjectTagInfoEXT(pool, pTagInfo, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugMarkerObjectTagInfoEXT(mImpl->resources(), (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1201;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1201, 1);
        countingStream->write((uint64_t*)&cgen_var_1201, 1 * 8);
        marshal_VkDebugMarkerObjectTagInfoEXT(countingStream, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    uint32_t packetSize_vkDebugMarkerSetObjectTagEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugMarkerSetObjectTagEXT = OP_vkDebugMarkerSetObjectTagEXT;
    stream->write(&opcode_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t));
    uint64_t cgen_var_1202;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1202, 1);
    stream->write((uint64_t*)&cgen_var_1202, 1 * 8);
    marshal_VkDebugMarkerObjectTagInfoEXT(stream, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult VkEncoder::vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugMarkerObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugMarkerObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectNameInfoEXT));
        deepcopy_VkDebugMarkerObjectNameInfoEXT(pool, pNameInfo, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugMarkerObjectNameInfoEXT(mImpl->resources(), (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1203;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1203, 1);
        countingStream->write((uint64_t*)&cgen_var_1203, 1 * 8);
        marshal_VkDebugMarkerObjectNameInfoEXT(countingStream, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    uint32_t packetSize_vkDebugMarkerSetObjectNameEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugMarkerSetObjectNameEXT = OP_vkDebugMarkerSetObjectNameEXT;
    stream->write(&opcode_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t));
    uint64_t cgen_var_1204;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1204, 1);
    stream->write((uint64_t*)&cgen_var_1204, 1 * 8);
    marshal_VkDebugMarkerObjectNameInfoEXT(stream, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

void VkEncoder::vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(mImpl->resources(), (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1205;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1205, 1);
        countingStream->write((uint64_t*)&cgen_var_1205, 1 * 8);
        marshal_VkDebugMarkerMarkerInfoEXT(countingStream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    uint32_t packetSize_vkCmdDebugMarkerBeginEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerBeginEXT = OP_vkCmdDebugMarkerBeginEXT;
    stream->write(&opcode_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t));
    uint64_t cgen_var_1206;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1206, 1);
    stream->write((uint64_t*)&cgen_var_1206, 1 * 8);
    marshal_VkDebugMarkerMarkerInfoEXT(stream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
}

void VkEncoder::vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1207;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1207, 1);
        countingStream->write((uint64_t*)&cgen_var_1207, 1 * 8);
    }
    uint32_t packetSize_vkCmdDebugMarkerEndEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerEndEXT = OP_vkCmdDebugMarkerEndEXT;
    stream->write(&opcode_vkCmdDebugMarkerEndEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerEndEXT, sizeof(uint32_t));
    uint64_t cgen_var_1208;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1208, 1);
    stream->write((uint64_t*)&cgen_var_1208, 1 * 8);
}

void VkEncoder::vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(mImpl->resources(), (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1209;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1209, 1);
        countingStream->write((uint64_t*)&cgen_var_1209, 1 * 8);
        marshal_VkDebugMarkerMarkerInfoEXT(countingStream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    uint32_t packetSize_vkCmdDebugMarkerInsertEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerInsertEXT = OP_vkCmdDebugMarkerInsertEXT;
    stream->write(&opcode_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t));
    uint64_t cgen_var_1210;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1210, 1);
    stream->write((uint64_t*)&cgen_var_1210, 1 * 8);
    marshal_VkDebugMarkerMarkerInfoEXT(stream, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1211;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1211, 1);
        countingStream->write((uint64_t*)&cgen_var_1211, 1 * 8);
        uint64_t cgen_var_1212;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1212, 1);
        countingStream->write((uint64_t*)&cgen_var_1212, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1213;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1213, 1);
        countingStream->write((uint64_t*)&cgen_var_1213, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirectCountAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirectCountAMD = OP_vkCmdDrawIndirectCountAMD;
    stream->write(&opcode_vkCmdDrawIndirectCountAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirectCountAMD, sizeof(uint32_t));
    uint64_t cgen_var_1214;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1214, 1);
    stream->write((uint64_t*)&cgen_var_1214, 1 * 8);
    uint64_t cgen_var_1215;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1215, 1);
    stream->write((uint64_t*)&cgen_var_1215, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1216;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1216, 1);
    stream->write((uint64_t*)&cgen_var_1216, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    countingStream->rewind();
    {
        uint64_t cgen_var_1217;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1217, 1);
        countingStream->write((uint64_t*)&cgen_var_1217, 1 * 8);
        uint64_t cgen_var_1218;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1218, 1);
        countingStream->write((uint64_t*)&cgen_var_1218, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
        uint64_t cgen_var_1219;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1219, 1);
        countingStream->write((uint64_t*)&cgen_var_1219, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirectCountAMD = OP_vkCmdDrawIndexedIndirectCountAMD;
    stream->write(&opcode_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t));
    uint64_t cgen_var_1220;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1220, 1);
    stream->write((uint64_t*)&cgen_var_1220, 1 * 8);
    uint64_t cgen_var_1221;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_buffer, &cgen_var_1221, 1);
    stream->write((uint64_t*)&cgen_var_1221, 1 * 8);
    stream->write((VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    uint64_t cgen_var_1222;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_countBuffer, &cgen_var_1222, 1);
    stream->write((uint64_t*)&cgen_var_1222, 1 * 8);
    stream->write((VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&local_stride, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
VkResult VkEncoder::vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkShaderStageFlagBits local_shaderStage;
    VkShaderInfoTypeAMD local_infoType;
    local_device = device;
    local_pipeline = pipeline;
    local_shaderStage = shaderStage;
    local_infoType = infoType;
    countingStream->rewind();
    {
        uint64_t cgen_var_1223;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1223, 1);
        countingStream->write((uint64_t*)&cgen_var_1223, 1 * 8);
        uint64_t cgen_var_1224;
        countingStream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_1224, 1);
        countingStream->write((uint64_t*)&cgen_var_1224, 1 * 8);
        countingStream->write((VkShaderStageFlagBits*)&local_shaderStage, sizeof(VkShaderStageFlagBits));
        countingStream->write((VkShaderInfoTypeAMD*)&local_infoType, sizeof(VkShaderInfoTypeAMD));
        // WARNING PTR CHECK
        uint64_t cgen_var_1225 = (uint64_t)(uintptr_t)pInfoSize;
        countingStream->putBe64(cgen_var_1225);
        if (pInfoSize)
        {
            uint64_t cgen_var_1226 = (uint64_t)(*pInfoSize);
            countingStream->putBe64(cgen_var_1226);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1227 = (uint64_t)(uintptr_t)pInfo;
        countingStream->putBe64(cgen_var_1227);
        if (pInfo)
        {
            countingStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetShaderInfoAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetShaderInfoAMD = OP_vkGetShaderInfoAMD;
    stream->write(&opcode_vkGetShaderInfoAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkGetShaderInfoAMD, sizeof(uint32_t));
    uint64_t cgen_var_1228;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1228, 1);
    stream->write((uint64_t*)&cgen_var_1228, 1 * 8);
    uint64_t cgen_var_1229;
    stream->handleMapping()->mapHandles_VkPipeline_u64(&local_pipeline, &cgen_var_1229, 1);
    stream->write((uint64_t*)&cgen_var_1229, 1 * 8);
    stream->write((VkShaderStageFlagBits*)&local_shaderStage, sizeof(VkShaderStageFlagBits));
    stream->write((VkShaderInfoTypeAMD*)&local_infoType, sizeof(VkShaderInfoTypeAMD));
    // WARNING PTR CHECK
    uint64_t cgen_var_1230 = (uint64_t)(uintptr_t)pInfoSize;
    stream->putBe64(cgen_var_1230);
    if (pInfoSize)
    {
        uint64_t cgen_var_1231 = (uint64_t)(*pInfoSize);
        stream->putBe64(cgen_var_1231);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1232 = (uint64_t)(uintptr_t)pInfo;
    stream->putBe64(cgen_var_1232);
    if (pInfo)
    {
        stream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    // WARNING PTR CHECK
    size_t* check_pInfoSize;
    check_pInfoSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pInfoSize)
    {
        if (!(check_pInfoSize))
        {
            fprintf(stderr, "fatal: pInfoSize inconsistent between guest and host\n");
        }
        (*pInfoSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pInfo;
    check_pInfo = (void*)(uintptr_t)stream->getBe64();
    if (pInfo)
    {
        if (!(check_pInfo))
        {
            fprintf(stderr, "fatal: pInfo inconsistent between guest and host\n");
        }
        stream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    stream->read(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetShaderInfoAMD_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
VkResult VkEncoder::vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    VkExternalMemoryHandleTypeFlagsNV local_externalHandleType;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    local_externalHandleType = externalHandleType;
    countingStream->rewind();
    {
        uint64_t cgen_var_1236;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1236, 1);
        countingStream->write((uint64_t*)&cgen_var_1236, 1 * 8);
        countingStream->write((VkFormat*)&local_format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&local_type, sizeof(VkImageType));
        countingStream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
        countingStream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
        countingStream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
        marshal_VkExternalImageFormatPropertiesNV(countingStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    stream->write(&opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t));
    uint64_t cgen_var_1237;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1237, 1);
    stream->write((uint64_t*)&cgen_var_1237, 1 * 8);
    stream->write((VkFormat*)&local_format, sizeof(VkFormat));
    stream->write((VkImageType*)&local_type, sizeof(VkImageType));
    stream->write((VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    stream->write((VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    stream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    marshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    unmarshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    if (pExternalImageFormatProperties)
    {
        transform_fromhost_VkExternalImageFormatPropertiesNV(mImpl->resources(), (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkExternalMemoryHandleTypeFlagsNV local_handleType;
    local_device = device;
    local_memory = memory;
    local_handleType = handleType;
    mImpl->resources()->deviceMemoryTransform_tohost(&local_memory, 1, nullptr, 0, nullptr, 0, nullptr, 0, nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_1238;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1238, 1);
        countingStream->write((uint64_t*)&cgen_var_1238, 1 * 8);
        uint64_t cgen_var_1239;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1239, 1);
        countingStream->write((uint64_t*)&cgen_var_1239, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetMemoryWin32HandleNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandleNV = OP_vkGetMemoryWin32HandleNV;
    stream->write(&opcode_vkGetMemoryWin32HandleNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandleNV, sizeof(uint32_t));
    uint64_t cgen_var_1240;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1240, 1);
    stream->write((uint64_t*)&cgen_var_1240, 1 * 8);
    uint64_t cgen_var_1241;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1241, 1);
    stream->write((uint64_t*)&cgen_var_1241, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagsNV*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryWin32HandleNV_VkResult_return;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
VkResult VkEncoder::vkCreateViSurfaceNN(
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkViSurfaceCreateInfoNN* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkViSurfaceCreateInfoNN*)pool->alloc(sizeof(const VkViSurfaceCreateInfoNN));
        deepcopy_VkViSurfaceCreateInfoNN(pool, pCreateInfo, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkViSurfaceCreateInfoNN(mImpl->resources(), (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1242;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1242, 1);
        countingStream->write((uint64_t*)&cgen_var_1242, 1 * 8);
        marshal_VkViSurfaceCreateInfoNN(countingStream, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1243 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1243);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1244;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1244, 1);
        countingStream->write((uint64_t*)&cgen_var_1244, 8);
    }
    uint32_t packetSize_vkCreateViSurfaceNN = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateViSurfaceNN = OP_vkCreateViSurfaceNN;
    stream->write(&opcode_vkCreateViSurfaceNN, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateViSurfaceNN, sizeof(uint32_t));
    uint64_t cgen_var_1245;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1245, 1);
    stream->write((uint64_t*)&cgen_var_1245, 1 * 8);
    marshal_VkViSurfaceCreateInfoNN(stream, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1246 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1246);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1247;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1247, 1);
    stream->write((uint64_t*)&cgen_var_1247, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1248;
    stream->read((uint64_t*)&cgen_var_1248, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1248, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
    stream->read(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateViSurfaceNN_VkResult_return;
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void VkEncoder::vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkConditionalRenderingBeginInfoEXT* local_pConditionalRenderingBegin;
    local_commandBuffer = commandBuffer;
    local_pConditionalRenderingBegin = nullptr;
    if (pConditionalRenderingBegin)
    {
        local_pConditionalRenderingBegin = (VkConditionalRenderingBeginInfoEXT*)pool->alloc(sizeof(const VkConditionalRenderingBeginInfoEXT));
        deepcopy_VkConditionalRenderingBeginInfoEXT(pool, pConditionalRenderingBegin, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    if (local_pConditionalRenderingBegin)
    {
        transform_tohost_VkConditionalRenderingBeginInfoEXT(mImpl->resources(), (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1249;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1249, 1);
        countingStream->write((uint64_t*)&cgen_var_1249, 1 * 8);
        marshal_VkConditionalRenderingBeginInfoEXT(countingStream, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    uint32_t packetSize_vkCmdBeginConditionalRenderingEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginConditionalRenderingEXT = OP_vkCmdBeginConditionalRenderingEXT;
    stream->write(&opcode_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t));
    uint64_t cgen_var_1250;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1250, 1);
    stream->write((uint64_t*)&cgen_var_1250, 1 * 8);
    marshal_VkConditionalRenderingBeginInfoEXT(stream, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
}

void VkEncoder::vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1251;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1251, 1);
        countingStream->write((uint64_t*)&cgen_var_1251, 1 * 8);
    }
    uint32_t packetSize_vkCmdEndConditionalRenderingEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndConditionalRenderingEXT = OP_vkCmdEndConditionalRenderingEXT;
    stream->write(&opcode_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t));
    uint64_t cgen_var_1252;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1252, 1);
    stream->write((uint64_t*)&cgen_var_1252, 1 * 8);
}

#endif
#ifdef VK_NVX_device_generated_commands
void VkEncoder::vkCmdProcessCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCmdProcessCommandsInfoNVX* local_pProcessCommandsInfo;
    local_commandBuffer = commandBuffer;
    local_pProcessCommandsInfo = nullptr;
    if (pProcessCommandsInfo)
    {
        local_pProcessCommandsInfo = (VkCmdProcessCommandsInfoNVX*)pool->alloc(sizeof(const VkCmdProcessCommandsInfoNVX));
        deepcopy_VkCmdProcessCommandsInfoNVX(pool, pProcessCommandsInfo, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    if (local_pProcessCommandsInfo)
    {
        transform_tohost_VkCmdProcessCommandsInfoNVX(mImpl->resources(), (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1253;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1253, 1);
        countingStream->write((uint64_t*)&cgen_var_1253, 1 * 8);
        marshal_VkCmdProcessCommandsInfoNVX(countingStream, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
    }
    uint32_t packetSize_vkCmdProcessCommandsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdProcessCommandsNVX = OP_vkCmdProcessCommandsNVX;
    stream->write(&opcode_vkCmdProcessCommandsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdProcessCommandsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1254;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1254, 1);
    stream->write((uint64_t*)&cgen_var_1254, 1 * 8);
    marshal_VkCmdProcessCommandsInfoNVX(stream, (VkCmdProcessCommandsInfoNVX*)(local_pProcessCommandsInfo));
}

void VkEncoder::vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkCmdReserveSpaceForCommandsInfoNVX* local_pReserveSpaceInfo;
    local_commandBuffer = commandBuffer;
    local_pReserveSpaceInfo = nullptr;
    if (pReserveSpaceInfo)
    {
        local_pReserveSpaceInfo = (VkCmdReserveSpaceForCommandsInfoNVX*)pool->alloc(sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
        deepcopy_VkCmdReserveSpaceForCommandsInfoNVX(pool, pReserveSpaceInfo, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    if (local_pReserveSpaceInfo)
    {
        transform_tohost_VkCmdReserveSpaceForCommandsInfoNVX(mImpl->resources(), (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1255;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1255, 1);
        countingStream->write((uint64_t*)&cgen_var_1255, 1 * 8);
        marshal_VkCmdReserveSpaceForCommandsInfoNVX(countingStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
    }
    uint32_t packetSize_vkCmdReserveSpaceForCommandsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdReserveSpaceForCommandsNVX = OP_vkCmdReserveSpaceForCommandsNVX;
    stream->write(&opcode_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1256;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1256, 1);
    stream->write((uint64_t*)&cgen_var_1256, 1 * 8);
    marshal_VkCmdReserveSpaceForCommandsInfoNVX(stream, (VkCmdReserveSpaceForCommandsInfoNVX*)(local_pReserveSpaceInfo));
}

VkResult VkEncoder::vkCreateIndirectCommandsLayoutNVX(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkIndirectCommandsLayoutCreateInfoNVX* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIndirectCommandsLayoutCreateInfoNVX*)pool->alloc(sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
        deepcopy_VkIndirectCommandsLayoutCreateInfoNVX(pool, pCreateInfo, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIndirectCommandsLayoutCreateInfoNVX(mImpl->resources(), (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1257;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1257, 1);
        countingStream->write((uint64_t*)&cgen_var_1257, 1 * 8);
        marshal_VkIndirectCommandsLayoutCreateInfoNVX(countingStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1258 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1258);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1259;
        countingStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(pIndirectCommandsLayout, &cgen_var_1259, 1);
        countingStream->write((uint64_t*)&cgen_var_1259, 8);
    }
    uint32_t packetSize_vkCreateIndirectCommandsLayoutNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateIndirectCommandsLayoutNVX = OP_vkCreateIndirectCommandsLayoutNVX;
    stream->write(&opcode_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t));
    uint64_t cgen_var_1260;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1260, 1);
    stream->write((uint64_t*)&cgen_var_1260, 1 * 8);
    marshal_VkIndirectCommandsLayoutCreateInfoNVX(stream, (VkIndirectCommandsLayoutCreateInfoNVX*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1261 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1261);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1262;
    stream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(pIndirectCommandsLayout, &cgen_var_1262, 1);
    stream->write((uint64_t*)&cgen_var_1262, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1263;
    stream->read((uint64_t*)&cgen_var_1263, 8);
    stream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_1263, (VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateIndirectCommandsLayoutNVX_VkResult_return;
}

void VkEncoder::vkDestroyIndirectCommandsLayoutNVX(
    VkDevice device,
    VkIndirectCommandsLayoutNVX indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkIndirectCommandsLayoutNVX local_indirectCommandsLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_indirectCommandsLayout = indirectCommandsLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1264;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1264, 1);
        countingStream->write((uint64_t*)&cgen_var_1264, 1 * 8);
        uint64_t cgen_var_1265;
        countingStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(&local_indirectCommandsLayout, &cgen_var_1265, 1);
        countingStream->write((uint64_t*)&cgen_var_1265, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1266 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1266);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyIndirectCommandsLayoutNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyIndirectCommandsLayoutNVX = OP_vkDestroyIndirectCommandsLayoutNVX;
    stream->write(&opcode_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t));
    uint64_t cgen_var_1267;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1267, 1);
    stream->write((uint64_t*)&cgen_var_1267, 1 * 8);
    uint64_t cgen_var_1268;
    stream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(&local_indirectCommandsLayout, &cgen_var_1268, 1);
    stream->write((uint64_t*)&cgen_var_1268, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1269 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1269);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout);
}

VkResult VkEncoder::vkCreateObjectTableNVX(
    VkDevice device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableCreateInfoNVX* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkObjectTableCreateInfoNVX*)pool->alloc(sizeof(const VkObjectTableCreateInfoNVX));
        deepcopy_VkObjectTableCreateInfoNVX(pool, pCreateInfo, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkObjectTableCreateInfoNVX(mImpl->resources(), (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1270;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1270, 1);
        countingStream->write((uint64_t*)&cgen_var_1270, 1 * 8);
        marshal_VkObjectTableCreateInfoNVX(countingStream, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1271 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1271);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1272;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(pObjectTable, &cgen_var_1272, 1);
        countingStream->write((uint64_t*)&cgen_var_1272, 8);
    }
    uint32_t packetSize_vkCreateObjectTableNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateObjectTableNVX = OP_vkCreateObjectTableNVX;
    stream->write(&opcode_vkCreateObjectTableNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateObjectTableNVX, sizeof(uint32_t));
    uint64_t cgen_var_1273;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1273, 1);
    stream->write((uint64_t*)&cgen_var_1273, 1 * 8);
    marshal_VkObjectTableCreateInfoNVX(stream, (VkObjectTableCreateInfoNVX*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1274 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1274);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1275;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(pObjectTable, &cgen_var_1275, 1);
    stream->write((uint64_t*)&cgen_var_1275, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1276;
    stream->read((uint64_t*)&cgen_var_1276, 8);
    stream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_1276, (VkObjectTableNVX*)pObjectTable, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateObjectTableNVX_VkResult_return;
}

void VkEncoder::vkDestroyObjectTableNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_objectTable = objectTable;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1277;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1277, 1);
        countingStream->write((uint64_t*)&cgen_var_1277, 1 * 8);
        uint64_t cgen_var_1278;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1278, 1);
        countingStream->write((uint64_t*)&cgen_var_1278, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1279 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1279);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyObjectTableNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyObjectTableNVX = OP_vkDestroyObjectTableNVX;
    stream->write(&opcode_vkDestroyObjectTableNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyObjectTableNVX, sizeof(uint32_t));
    uint64_t cgen_var_1280;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1280, 1);
    stream->write((uint64_t*)&cgen_var_1280, 1 * 8);
    uint64_t cgen_var_1281;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1281, 1);
    stream->write((uint64_t*)&cgen_var_1281, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1282 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1282);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkObjectTableNVX((VkObjectTableNVX*)&objectTable);
}

VkResult VkEncoder::vkRegisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    uint32_t local_objectCount;
    VkObjectTableEntryNVX** local_ppObjectTableEntries;
    uint32_t* local_pObjectIndices;
    local_device = device;
    local_objectTable = objectTable;
    local_objectCount = objectCount;
    (void)ppObjectTableEntries;
    local_pObjectIndices = nullptr;
    if (pObjectIndices)
    {
        local_pObjectIndices = (uint32_t*)pool->dupArray(pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    }
    (void)local_ppObjectTableEntries;
    countingStream->rewind();
    {
        uint64_t cgen_var_1283;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1283, 1);
        countingStream->write((uint64_t*)&cgen_var_1283, 1 * 8);
        uint64_t cgen_var_1284;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1284, 1);
        countingStream->write((uint64_t*)&cgen_var_1284, 1 * 8);
        countingStream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
        (void)local_ppObjectTableEntries;
        countingStream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    }
    uint32_t packetSize_vkRegisterObjectsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterObjectsNVX = OP_vkRegisterObjectsNVX;
    stream->write(&opcode_vkRegisterObjectsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterObjectsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1285;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1285, 1);
    stream->write((uint64_t*)&cgen_var_1285, 1 * 8);
    uint64_t cgen_var_1286;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1286, 1);
    stream->write((uint64_t*)&cgen_var_1286, 1 * 8);
    stream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
    (void)local_ppObjectTableEntries;
    stream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkRegisterObjectsNVX_VkResult_return;
}

VkResult VkEncoder::vkUnregisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkObjectTableNVX local_objectTable;
    uint32_t local_objectCount;
    VkObjectEntryTypeNVX* local_pObjectEntryTypes;
    uint32_t* local_pObjectIndices;
    local_device = device;
    local_objectTable = objectTable;
    local_objectCount = objectCount;
    local_pObjectEntryTypes = nullptr;
    if (pObjectEntryTypes)
    {
        local_pObjectEntryTypes = (VkObjectEntryTypeNVX*)pool->dupArray(pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
    }
    local_pObjectIndices = nullptr;
    if (pObjectIndices)
    {
        local_pObjectIndices = (uint32_t*)pool->dupArray(pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1287;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1287, 1);
        countingStream->write((uint64_t*)&cgen_var_1287, 1 * 8);
        uint64_t cgen_var_1288;
        countingStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1288, 1);
        countingStream->write((uint64_t*)&cgen_var_1288, 1 * 8);
        countingStream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
        countingStream->write((VkObjectEntryTypeNVX*)local_pObjectEntryTypes, ((objectCount)) * sizeof(VkObjectEntryTypeNVX));
        countingStream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    }
    uint32_t packetSize_vkUnregisterObjectsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUnregisterObjectsNVX = OP_vkUnregisterObjectsNVX;
    stream->write(&opcode_vkUnregisterObjectsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkUnregisterObjectsNVX, sizeof(uint32_t));
    uint64_t cgen_var_1289;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1289, 1);
    stream->write((uint64_t*)&cgen_var_1289, 1 * 8);
    uint64_t cgen_var_1290;
    stream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&local_objectTable, &cgen_var_1290, 1);
    stream->write((uint64_t*)&cgen_var_1290, 1 * 8);
    stream->write((uint32_t*)&local_objectCount, sizeof(uint32_t));
    stream->write((VkObjectEntryTypeNVX*)local_pObjectEntryTypes, ((objectCount)) * sizeof(VkObjectEntryTypeNVX));
    stream->write((uint32_t*)local_pObjectIndices, ((objectCount)) * sizeof(uint32_t));
    VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkUnregisterObjectsNVX_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    countingStream->rewind();
    {
        uint64_t cgen_var_1291;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1291, 1);
        countingStream->write((uint64_t*)&cgen_var_1291, 1 * 8);
        marshal_VkDeviceGeneratedCommandsFeaturesNVX(countingStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
        marshal_VkDeviceGeneratedCommandsLimitsNVX(countingStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    }
    uint32_t packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX;
    stream->write(&opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t));
    uint64_t cgen_var_1292;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1292, 1);
    stream->write((uint64_t*)&cgen_var_1292, 1 * 8);
    marshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    marshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkDeviceGeneratedCommandsFeaturesNVX(mImpl->resources(), (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    }
    unmarshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    if (pLimits)
    {
        transform_fromhost_VkDeviceGeneratedCommandsLimitsNVX(mImpl->resources(), (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    }
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void VkEncoder::vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewportWScalingNV* local_pViewportWScalings;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewportWScalings = nullptr;
    if (pViewportWScalings)
    {
        local_pViewportWScalings = (VkViewportWScalingNV*)pool->alloc(((viewportCount)) * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewportWScalingNV(pool, pViewportWScalings + i, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    if (local_pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewportWScalingNV(mImpl->resources(), (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1293;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1293, 1);
        countingStream->write((uint64_t*)&cgen_var_1293, 1 * 8);
        countingStream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            marshal_VkViewportWScalingNV(countingStream, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    uint32_t packetSize_vkCmdSetViewportWScalingNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetViewportWScalingNV = OP_vkCmdSetViewportWScalingNV;
    stream->write(&opcode_vkCmdSetViewportWScalingNV, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetViewportWScalingNV, sizeof(uint32_t));
    uint64_t cgen_var_1294;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1294, 1);
    stream->write((uint64_t*)&cgen_var_1294, 1 * 8);
    stream->write((uint32_t*)&local_firstViewport, sizeof(uint32_t));
    stream->write((uint32_t*)&local_viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewportWScalingNV(stream, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
VkResult VkEncoder::vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_1295;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1295, 1);
        countingStream->write((uint64_t*)&cgen_var_1295, 1 * 8);
        uint64_t cgen_var_1296;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1296, 1);
        countingStream->write((uint64_t*)&cgen_var_1296, 1 * 8);
    }
    uint32_t packetSize_vkReleaseDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkReleaseDisplayEXT = OP_vkReleaseDisplayEXT;
    stream->write(&opcode_vkReleaseDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkReleaseDisplayEXT, sizeof(uint32_t));
    uint64_t cgen_var_1297;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1297, 1);
    stream->write((uint64_t*)&cgen_var_1297, 1 * 8);
    uint64_t cgen_var_1298;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1298, 1);
    stream->write((uint64_t*)&cgen_var_1298, 1 * 8);
    VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkReleaseDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_acquire_xlib_display
VkResult VkEncoder::vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    countingStream->rewind();
    {
        uint64_t cgen_var_1299;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1299, 1);
        countingStream->write((uint64_t*)&cgen_var_1299, 1 * 8);
        countingStream->write((Display*)dpy, sizeof(Display));
        uint64_t cgen_var_1300;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1300, 1);
        countingStream->write((uint64_t*)&cgen_var_1300, 1 * 8);
    }
    uint32_t packetSize_vkAcquireXlibDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireXlibDisplayEXT = OP_vkAcquireXlibDisplayEXT;
    stream->write(&opcode_vkAcquireXlibDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireXlibDisplayEXT, sizeof(uint32_t));
    uint64_t cgen_var_1301;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1301, 1);
    stream->write((uint64_t*)&cgen_var_1301, 1 * 8);
    stream->write((Display*)dpy, sizeof(Display));
    uint64_t cgen_var_1302;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1302, 1);
    stream->write((uint64_t*)&cgen_var_1302, 1 * 8);
    stream->read((Display*)dpy, sizeof(Display));
    VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult VkEncoder::vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    RROutput local_rrOutput;
    local_physicalDevice = physicalDevice;
    local_rrOutput = rrOutput;
    countingStream->rewind();
    {
        uint64_t cgen_var_1303;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1303, 1);
        countingStream->write((uint64_t*)&cgen_var_1303, 1 * 8);
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((RROutput*)&local_rrOutput, sizeof(RROutput));
        uint64_t cgen_var_1304;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_1304, 1);
        countingStream->write((uint64_t*)&cgen_var_1304, 8);
    }
    uint32_t packetSize_vkGetRandROutputDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRandROutputDisplayEXT = OP_vkGetRandROutputDisplayEXT;
    stream->write(&opcode_vkGetRandROutputDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRandROutputDisplayEXT, sizeof(uint32_t));
    uint64_t cgen_var_1305;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1305, 1);
    stream->write((uint64_t*)&cgen_var_1305, 1 * 8);
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((RROutput*)&local_rrOutput, sizeof(RROutput));
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1306;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_1306, 1);
    stream->write((uint64_t*)&cgen_var_1306, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->read((Display*)dpy, sizeof(Display));
    uint64_t cgen_var_1307;
    stream->read((uint64_t*)&cgen_var_1307, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_1307, (VkDisplayKHR*)pDisplay, 1);
    VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetRandROutputDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_surface_counter
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    countingStream->rewind();
    {
        uint64_t cgen_var_1308;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1308, 1);
        countingStream->write((uint64_t*)&cgen_var_1308, 1 * 8);
        uint64_t cgen_var_1309;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_1309, 1);
        countingStream->write((uint64_t*)&cgen_var_1309, 1 * 8);
        marshal_VkSurfaceCapabilities2EXT(countingStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT = OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t));
    uint64_t cgen_var_1310;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1310, 1);
    stream->write((uint64_t*)&cgen_var_1310, 1 * 8);
    uint64_t cgen_var_1311;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&local_surface, &cgen_var_1311, 1);
    stream->write((uint64_t*)&cgen_var_1311, 1 * 8);
    marshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    unmarshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2EXT(mImpl->resources(), (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_control
VkResult VkEncoder::vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayPowerInfoEXT* local_pDisplayPowerInfo;
    local_device = device;
    local_display = display;
    local_pDisplayPowerInfo = nullptr;
    if (pDisplayPowerInfo)
    {
        local_pDisplayPowerInfo = (VkDisplayPowerInfoEXT*)pool->alloc(sizeof(const VkDisplayPowerInfoEXT));
        deepcopy_VkDisplayPowerInfoEXT(pool, pDisplayPowerInfo, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    if (local_pDisplayPowerInfo)
    {
        transform_tohost_VkDisplayPowerInfoEXT(mImpl->resources(), (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1312;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1312, 1);
        countingStream->write((uint64_t*)&cgen_var_1312, 1 * 8);
        uint64_t cgen_var_1313;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1313, 1);
        countingStream->write((uint64_t*)&cgen_var_1313, 1 * 8);
        marshal_VkDisplayPowerInfoEXT(countingStream, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    uint32_t packetSize_vkDisplayPowerControlEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDisplayPowerControlEXT = OP_vkDisplayPowerControlEXT;
    stream->write(&opcode_vkDisplayPowerControlEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDisplayPowerControlEXT, sizeof(uint32_t));
    uint64_t cgen_var_1314;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1314, 1);
    stream->write((uint64_t*)&cgen_var_1314, 1 * 8);
    uint64_t cgen_var_1315;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1315, 1);
    stream->write((uint64_t*)&cgen_var_1315, 1 * 8);
    marshal_VkDisplayPowerInfoEXT(stream, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkDisplayPowerControlEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceEventInfoEXT* local_pDeviceEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pDeviceEventInfo = nullptr;
    if (pDeviceEventInfo)
    {
        local_pDeviceEventInfo = (VkDeviceEventInfoEXT*)pool->alloc(sizeof(const VkDeviceEventInfoEXT));
        deepcopy_VkDeviceEventInfoEXT(pool, pDeviceEventInfo, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDeviceEventInfo)
    {
        transform_tohost_VkDeviceEventInfoEXT(mImpl->resources(), (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1316;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1316, 1);
        countingStream->write((uint64_t*)&cgen_var_1316, 1 * 8);
        marshal_VkDeviceEventInfoEXT(countingStream, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1317 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1317);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1318;
        countingStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1318, 1);
        countingStream->write((uint64_t*)&cgen_var_1318, 8);
    }
    uint32_t packetSize_vkRegisterDeviceEventEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterDeviceEventEXT = OP_vkRegisterDeviceEventEXT;
    stream->write(&opcode_vkRegisterDeviceEventEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterDeviceEventEXT, sizeof(uint32_t));
    uint64_t cgen_var_1319;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1319, 1);
    stream->write((uint64_t*)&cgen_var_1319, 1 * 8);
    marshal_VkDeviceEventInfoEXT(stream, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1320 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1320);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1321;
    stream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1321, 1);
    stream->write((uint64_t*)&cgen_var_1321, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1322;
    stream->read((uint64_t*)&cgen_var_1322, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_1322, (VkFence*)pFence, 1);
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayEventInfoEXT* local_pDisplayEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_display = display;
    local_pDisplayEventInfo = nullptr;
    if (pDisplayEventInfo)
    {
        local_pDisplayEventInfo = (VkDisplayEventInfoEXT*)pool->alloc(sizeof(const VkDisplayEventInfoEXT));
        deepcopy_VkDisplayEventInfoEXT(pool, pDisplayEventInfo, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDisplayEventInfo)
    {
        transform_tohost_VkDisplayEventInfoEXT(mImpl->resources(), (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1323;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1323, 1);
        countingStream->write((uint64_t*)&cgen_var_1323, 1 * 8);
        uint64_t cgen_var_1324;
        countingStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1324, 1);
        countingStream->write((uint64_t*)&cgen_var_1324, 1 * 8);
        marshal_VkDisplayEventInfoEXT(countingStream, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1325 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1325);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1326;
        countingStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1326, 1);
        countingStream->write((uint64_t*)&cgen_var_1326, 8);
    }
    uint32_t packetSize_vkRegisterDisplayEventEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterDisplayEventEXT = OP_vkRegisterDisplayEventEXT;
    stream->write(&opcode_vkRegisterDisplayEventEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterDisplayEventEXT, sizeof(uint32_t));
    uint64_t cgen_var_1327;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1327, 1);
    stream->write((uint64_t*)&cgen_var_1327, 1 * 8);
    uint64_t cgen_var_1328;
    stream->handleMapping()->mapHandles_VkDisplayKHR_u64(&local_display, &cgen_var_1328, 1);
    stream->write((uint64_t*)&cgen_var_1328, 1 * 8);
    marshal_VkDisplayEventInfoEXT(stream, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1329 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1329);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1330;
    stream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_1330, 1);
    stream->write((uint64_t*)&cgen_var_1330, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1331;
    stream->read((uint64_t*)&cgen_var_1331, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_1331, (VkFence*)pFence, 1);
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult VkEncoder::vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkSurfaceCounterFlagBitsEXT local_counter;
    local_device = device;
    local_swapchain = swapchain;
    local_counter = counter;
    countingStream->rewind();
    {
        uint64_t cgen_var_1332;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1332, 1);
        countingStream->write((uint64_t*)&cgen_var_1332, 1 * 8);
        uint64_t cgen_var_1333;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1333, 1);
        countingStream->write((uint64_t*)&cgen_var_1333, 1 * 8);
        countingStream->write((VkSurfaceCounterFlagBitsEXT*)&local_counter, sizeof(VkSurfaceCounterFlagBitsEXT));
        countingStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    }
    uint32_t packetSize_vkGetSwapchainCounterEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainCounterEXT = OP_vkGetSwapchainCounterEXT;
    stream->write(&opcode_vkGetSwapchainCounterEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainCounterEXT, sizeof(uint32_t));
    uint64_t cgen_var_1334;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1334, 1);
    stream->write((uint64_t*)&cgen_var_1334, 1 * 8);
    uint64_t cgen_var_1335;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1335, 1);
    stream->write((uint64_t*)&cgen_var_1335, 1 * 8);
    stream->write((VkSurfaceCounterFlagBitsEXT*)&local_counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    stream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    stream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetSwapchainCounterEXT_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_display_timing
VkResult VkEncoder::vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_1336;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1336, 1);
        countingStream->write((uint64_t*)&cgen_var_1336, 1 * 8);
        uint64_t cgen_var_1337;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1337, 1);
        countingStream->write((uint64_t*)&cgen_var_1337, 1 * 8);
        marshal_VkRefreshCycleDurationGOOGLE(countingStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    uint32_t packetSize_vkGetRefreshCycleDurationGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRefreshCycleDurationGOOGLE = OP_vkGetRefreshCycleDurationGOOGLE;
    stream->write(&opcode_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1338;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1338, 1);
    stream->write((uint64_t*)&cgen_var_1338, 1 * 8);
    uint64_t cgen_var_1339;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1339, 1);
    stream->write((uint64_t*)&cgen_var_1339, 1 * 8);
    marshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    unmarshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    if (pDisplayTimingProperties)
    {
        transform_fromhost_VkRefreshCycleDurationGOOGLE(mImpl->resources(), (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    countingStream->rewind();
    {
        uint64_t cgen_var_1340;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1340, 1);
        countingStream->write((uint64_t*)&cgen_var_1340, 1 * 8);
        uint64_t cgen_var_1341;
        countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1341, 1);
        countingStream->write((uint64_t*)&cgen_var_1341, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1342 = (uint64_t)(uintptr_t)pPresentationTimingCount;
        countingStream->putBe64(cgen_var_1342);
        if (pPresentationTimingCount)
        {
            countingStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1343 = (uint64_t)(uintptr_t)pPresentationTimings;
        countingStream->putBe64(cgen_var_1343);
        if (pPresentationTimings)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
            {
                marshal_VkPastPresentationTimingGOOGLE(countingStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
            }
        }
    }
    uint32_t packetSize_vkGetPastPresentationTimingGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPastPresentationTimingGOOGLE = OP_vkGetPastPresentationTimingGOOGLE;
    stream->write(&opcode_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1344;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1344, 1);
    stream->write((uint64_t*)&cgen_var_1344, 1 * 8);
    uint64_t cgen_var_1345;
    stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&local_swapchain, &cgen_var_1345, 1);
    stream->write((uint64_t*)&cgen_var_1345, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1346 = (uint64_t)(uintptr_t)pPresentationTimingCount;
    stream->putBe64(cgen_var_1346);
    if (pPresentationTimingCount)
    {
        stream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1347 = (uint64_t)(uintptr_t)pPresentationTimings;
    stream->putBe64(cgen_var_1347);
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            marshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentationTimingCount;
    check_pPresentationTimingCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentationTimingCount)
    {
        if (!(check_pPresentationTimingCount))
        {
            fprintf(stderr, "fatal: pPresentationTimingCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPastPresentationTimingGOOGLE* check_pPresentationTimings;
    check_pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)stream->getBe64();
    if (pPresentationTimings)
    {
        if (!(check_pPresentationTimings))
        {
            fprintf(stderr, "fatal: pPresentationTimings inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            unmarshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            transform_fromhost_VkPastPresentationTimingGOOGLE(mImpl->resources(), (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
void VkEncoder::vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstDiscardRectangle;
    uint32_t local_discardRectangleCount;
    VkRect2D* local_pDiscardRectangles;
    local_commandBuffer = commandBuffer;
    local_firstDiscardRectangle = firstDiscardRectangle;
    local_discardRectangleCount = discardRectangleCount;
    local_pDiscardRectangles = nullptr;
    if (pDiscardRectangles)
    {
        local_pDiscardRectangles = (VkRect2D*)pool->alloc(((discardRectangleCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            deepcopy_VkRect2D(pool, pDiscardRectangles + i, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    if (local_pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            transform_tohost_VkRect2D(mImpl->resources(), (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1350;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1350, 1);
        countingStream->write((uint64_t*)&cgen_var_1350, 1 * 8);
        countingStream->write((uint32_t*)&local_firstDiscardRectangle, sizeof(uint32_t));
        countingStream->write((uint32_t*)&local_discardRectangleCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            marshal_VkRect2D(countingStream, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    uint32_t packetSize_vkCmdSetDiscardRectangleEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDiscardRectangleEXT = OP_vkCmdSetDiscardRectangleEXT;
    stream->write(&opcode_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t));
    uint64_t cgen_var_1351;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1351, 1);
    stream->write((uint64_t*)&cgen_var_1351, 1 * 8);
    stream->write((uint32_t*)&local_firstDiscardRectangle, sizeof(uint32_t));
    stream->write((uint32_t*)&local_discardRectangleCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        marshal_VkRect2D(stream, (VkRect2D*)(local_pDiscardRectangles + i));
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void VkEncoder::vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainKHR* local_pSwapchains;
    VkHdrMetadataEXT* local_pMetadata;
    local_device = device;
    local_swapchainCount = swapchainCount;
    local_pSwapchains = nullptr;
    if (pSwapchains)
    {
        local_pSwapchains = (VkSwapchainKHR*)pool->dupArray(pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
    }
    local_pMetadata = nullptr;
    if (pMetadata)
    {
        local_pMetadata = (VkHdrMetadataEXT*)pool->alloc(((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkHdrMetadataEXT(pool, pMetadata + i, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    if (local_pMetadata)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkHdrMetadataEXT(mImpl->resources(), (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1352;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1352, 1);
        countingStream->write((uint64_t*)&cgen_var_1352, 1 * 8);
        countingStream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
        if (((swapchainCount)))
        {
            uint64_t* cgen_var_1353;
            countingStream->alloc((void**)&cgen_var_1353, ((swapchainCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(local_pSwapchains, cgen_var_1353, ((swapchainCount)));
            countingStream->write((uint64_t*)cgen_var_1353, ((swapchainCount)) * 8);
        }
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            marshal_VkHdrMetadataEXT(countingStream, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    uint32_t packetSize_vkSetHdrMetadataEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetHdrMetadataEXT = OP_vkSetHdrMetadataEXT;
    stream->write(&opcode_vkSetHdrMetadataEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetHdrMetadataEXT, sizeof(uint32_t));
    uint64_t cgen_var_1354;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1354, 1);
    stream->write((uint64_t*)&cgen_var_1354, 1 * 8);
    stream->write((uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_1355;
        stream->alloc((void**)&cgen_var_1355, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_VkSwapchainKHR_u64(local_pSwapchains, cgen_var_1355, ((swapchainCount)));
        stream->write((uint64_t*)cgen_var_1355, ((swapchainCount)) * 8);
    }
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkHdrMetadataEXT(stream, (VkHdrMetadataEXT*)(local_pMetadata + i));
    }
}

#endif
#ifdef VK_MVK_ios_surface
VkResult VkEncoder::vkCreateIOSSurfaceMVK(
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkIOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkIOSSurfaceCreateInfoMVK));
        deepcopy_VkIOSSurfaceCreateInfoMVK(pool, pCreateInfo, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIOSSurfaceCreateInfoMVK(mImpl->resources(), (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1356;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1356, 1);
        countingStream->write((uint64_t*)&cgen_var_1356, 1 * 8);
        marshal_VkIOSSurfaceCreateInfoMVK(countingStream, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1357 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1357);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1358;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1358, 1);
        countingStream->write((uint64_t*)&cgen_var_1358, 8);
    }
    uint32_t packetSize_vkCreateIOSSurfaceMVK = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateIOSSurfaceMVK = OP_vkCreateIOSSurfaceMVK;
    stream->write(&opcode_vkCreateIOSSurfaceMVK, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateIOSSurfaceMVK, sizeof(uint32_t));
    uint64_t cgen_var_1359;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1359, 1);
    stream->write((uint64_t*)&cgen_var_1359, 1 * 8);
    marshal_VkIOSSurfaceCreateInfoMVK(stream, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1360 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1360);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1361;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1361, 1);
    stream->write((uint64_t*)&cgen_var_1361, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1362;
    stream->read((uint64_t*)&cgen_var_1362, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1362, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateIOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_macos_surface
VkResult VkEncoder::vkCreateMacOSSurfaceMVK(
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkMacOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMacOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkMacOSSurfaceCreateInfoMVK));
        deepcopy_VkMacOSSurfaceCreateInfoMVK(pool, pCreateInfo, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMacOSSurfaceCreateInfoMVK(mImpl->resources(), (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1363;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1363, 1);
        countingStream->write((uint64_t*)&cgen_var_1363, 1 * 8);
        marshal_VkMacOSSurfaceCreateInfoMVK(countingStream, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1364 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1364);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1365;
        countingStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1365, 1);
        countingStream->write((uint64_t*)&cgen_var_1365, 8);
    }
    uint32_t packetSize_vkCreateMacOSSurfaceMVK = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateMacOSSurfaceMVK = OP_vkCreateMacOSSurfaceMVK;
    stream->write(&opcode_vkCreateMacOSSurfaceMVK, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateMacOSSurfaceMVK, sizeof(uint32_t));
    uint64_t cgen_var_1366;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1366, 1);
    stream->write((uint64_t*)&cgen_var_1366, 1 * 8);
    marshal_VkMacOSSurfaceCreateInfoMVK(stream, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1367 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1367);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1368;
    stream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_1368, 1);
    stream->write((uint64_t*)&cgen_var_1368, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    uint64_t cgen_var_1369;
    stream->read((uint64_t*)&cgen_var_1369, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_1369, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateMacOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
VkResult VkEncoder::vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugUtilsObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugUtilsObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectNameInfoEXT));
        deepcopy_VkDebugUtilsObjectNameInfoEXT(pool, pNameInfo, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugUtilsObjectNameInfoEXT(mImpl->resources(), (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1370;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1370, 1);
        countingStream->write((uint64_t*)&cgen_var_1370, 1 * 8);
        marshal_VkDebugUtilsObjectNameInfoEXT(countingStream, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    uint32_t packetSize_vkSetDebugUtilsObjectNameEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetDebugUtilsObjectNameEXT = OP_vkSetDebugUtilsObjectNameEXT;
    stream->write(&opcode_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t));
    uint64_t cgen_var_1371;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1371, 1);
    stream->write((uint64_t*)&cgen_var_1371, 1 * 8);
    marshal_VkDebugUtilsObjectNameInfoEXT(stream, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult VkEncoder::vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDebugUtilsObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugUtilsObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectTagInfoEXT));
        deepcopy_VkDebugUtilsObjectTagInfoEXT(pool, pTagInfo, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugUtilsObjectTagInfoEXT(mImpl->resources(), (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1372;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1372, 1);
        countingStream->write((uint64_t*)&cgen_var_1372, 1 * 8);
        marshal_VkDebugUtilsObjectTagInfoEXT(countingStream, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    uint32_t packetSize_vkSetDebugUtilsObjectTagEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetDebugUtilsObjectTagEXT = OP_vkSetDebugUtilsObjectTagEXT;
    stream->write(&opcode_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t));
    uint64_t cgen_var_1373;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1373, 1);
    stream->write((uint64_t*)&cgen_var_1373, 1 * 8);
    marshal_VkDebugUtilsObjectTagInfoEXT(stream, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

void VkEncoder::vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1374;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1374, 1);
        countingStream->write((uint64_t*)&cgen_var_1374, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkQueueBeginDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueBeginDebugUtilsLabelEXT = OP_vkQueueBeginDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1375;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1375, 1);
    stream->write((uint64_t*)&cgen_var_1375, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
}

void VkEncoder::vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    local_queue = queue;
    countingStream->rewind();
    {
        uint64_t cgen_var_1376;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1376, 1);
        countingStream->write((uint64_t*)&cgen_var_1376, 1 * 8);
    }
    uint32_t packetSize_vkQueueEndDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueEndDebugUtilsLabelEXT = OP_vkQueueEndDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1377;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1377, 1);
    stream->write((uint64_t*)&cgen_var_1377, 1 * 8);
}

void VkEncoder::vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1378;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1378, 1);
        countingStream->write((uint64_t*)&cgen_var_1378, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkQueueInsertDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueInsertDebugUtilsLabelEXT = OP_vkQueueInsertDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1379;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1379, 1);
    stream->write((uint64_t*)&cgen_var_1379, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
}

void VkEncoder::vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1380;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1380, 1);
        countingStream->write((uint64_t*)&cgen_var_1380, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkCmdBeginDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginDebugUtilsLabelEXT = OP_vkCmdBeginDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1381;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1381, 1);
    stream->write((uint64_t*)&cgen_var_1381, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
}

void VkEncoder::vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    countingStream->rewind();
    {
        uint64_t cgen_var_1382;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1382, 1);
        countingStream->write((uint64_t*)&cgen_var_1382, 1 * 8);
    }
    uint32_t packetSize_vkCmdEndDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndDebugUtilsLabelEXT = OP_vkCmdEndDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1383;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1383, 1);
    stream->write((uint64_t*)&cgen_var_1383, 1 * 8);
}

void VkEncoder::vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(mImpl->resources(), (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1384;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1384, 1);
        countingStream->write((uint64_t*)&cgen_var_1384, 1 * 8);
        marshal_VkDebugUtilsLabelEXT(countingStream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    uint32_t packetSize_vkCmdInsertDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdInsertDebugUtilsLabelEXT = OP_vkCmdInsertDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    uint64_t cgen_var_1385;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1385, 1);
    stream->write((uint64_t*)&cgen_var_1385, 1 * 8);
    marshal_VkDebugUtilsLabelEXT(stream, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
}

VkResult VkEncoder::vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugUtilsMessengerCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugUtilsMessengerCreateInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
        deepcopy_VkDebugUtilsMessengerCreateInfoEXT(pool, pCreateInfo, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(mImpl->resources(), (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1386;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1386, 1);
        countingStream->write((uint64_t*)&cgen_var_1386, 1 * 8);
        marshal_VkDebugUtilsMessengerCreateInfoEXT(countingStream, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1387 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1387);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1388;
        countingStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(pMessenger, &cgen_var_1388, 1);
        countingStream->write((uint64_t*)&cgen_var_1388, 8);
    }
    uint32_t packetSize_vkCreateDebugUtilsMessengerEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDebugUtilsMessengerEXT = OP_vkCreateDebugUtilsMessengerEXT;
    stream->write(&opcode_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t));
    uint64_t cgen_var_1389;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1389, 1);
    stream->write((uint64_t*)&cgen_var_1389, 1 * 8);
    marshal_VkDebugUtilsMessengerCreateInfoEXT(stream, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1390 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1390);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1391;
    stream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(pMessenger, &cgen_var_1391, 1);
    stream->write((uint64_t*)&cgen_var_1391, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1392;
    stream->read((uint64_t*)&cgen_var_1392, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_1392, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugUtilsMessengerEXT local_messenger;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_messenger = messenger;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1393;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1393, 1);
        countingStream->write((uint64_t*)&cgen_var_1393, 1 * 8);
        uint64_t cgen_var_1394;
        countingStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(&local_messenger, &cgen_var_1394, 1);
        countingStream->write((uint64_t*)&cgen_var_1394, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1395 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1395);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDebugUtilsMessengerEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDebugUtilsMessengerEXT = OP_vkDestroyDebugUtilsMessengerEXT;
    stream->write(&opcode_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t));
    uint64_t cgen_var_1396;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1396, 1);
    stream->write((uint64_t*)&cgen_var_1396, 1 * 8);
    uint64_t cgen_var_1397;
    stream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT_u64(&local_messenger, &cgen_var_1397, 1);
    stream->write((uint64_t*)&cgen_var_1397, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1398 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1398);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)&messenger);
}

void VkEncoder::vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkInstance local_instance;
    VkDebugUtilsMessageSeverityFlagBitsEXT local_messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT local_messageTypes;
    VkDebugUtilsMessengerCallbackDataEXT* local_pCallbackData;
    local_instance = instance;
    local_messageSeverity = messageSeverity;
    local_messageTypes = messageTypes;
    local_pCallbackData = nullptr;
    if (pCallbackData)
    {
        local_pCallbackData = (VkDebugUtilsMessengerCallbackDataEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
        deepcopy_VkDebugUtilsMessengerCallbackDataEXT(pool, pCallbackData, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    if (local_pCallbackData)
    {
        transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(mImpl->resources(), (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1399;
        countingStream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1399, 1);
        countingStream->write((uint64_t*)&cgen_var_1399, 1 * 8);
        countingStream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&local_messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
        countingStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&local_messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
        marshal_VkDebugUtilsMessengerCallbackDataEXT(countingStream, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    uint32_t packetSize_vkSubmitDebugUtilsMessageEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSubmitDebugUtilsMessageEXT = OP_vkSubmitDebugUtilsMessageEXT;
    stream->write(&opcode_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t));
    uint64_t cgen_var_1400;
    stream->handleMapping()->mapHandles_VkInstance_u64(&local_instance, &cgen_var_1400, 1);
    stream->write((uint64_t*)&cgen_var_1400, 1 * 8);
    stream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&local_messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    stream->write((VkDebugUtilsMessageTypeFlagsEXT*)&local_messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    marshal_VkDebugUtilsMessengerCallbackDataEXT(stream, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
VkResult VkEncoder::vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    AHardwareBuffer* local_buffer;
    local_device = device;
    local_buffer = nullptr;
    if (buffer)
    {
        local_buffer = (AHardwareBuffer*)pool->dupArray(buffer, sizeof(const AHardwareBuffer));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1401;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1401, 1);
        countingStream->write((uint64_t*)&cgen_var_1401, 1 * 8);
        countingStream->write((AHardwareBuffer*)local_buffer, sizeof(AHardwareBuffer));
        marshal_VkAndroidHardwareBufferPropertiesANDROID(countingStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    uint32_t packetSize_vkGetAndroidHardwareBufferPropertiesANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetAndroidHardwareBufferPropertiesANDROID = OP_vkGetAndroidHardwareBufferPropertiesANDROID;
    stream->write(&opcode_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1402;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1402, 1);
    stream->write((uint64_t*)&cgen_var_1402, 1 * 8);
    stream->write((AHardwareBuffer*)local_buffer, sizeof(AHardwareBuffer));
    marshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    unmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(mImpl->resources(), (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkMemoryGetAndroidHardwareBufferInfoANDROID* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkMemoryGetAndroidHardwareBufferInfoANDROID*)pool->alloc(sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
        deepcopy_VkMemoryGetAndroidHardwareBufferInfoANDROID(pool, pInfo, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(mImpl->resources(), (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1403;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1403, 1);
        countingStream->write((uint64_t*)&cgen_var_1403, 1 * 8);
        marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(countingStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
        countingStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    }
    uint32_t packetSize_vkGetMemoryAndroidHardwareBufferANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryAndroidHardwareBufferANDROID = OP_vkGetMemoryAndroidHardwareBufferANDROID;
    stream->write(&opcode_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t));
    uint64_t cgen_var_1404;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1404, 1);
    stream->write((uint64_t*)&cgen_var_1404, 1 * 8);
    marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(stream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    stream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    stream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void VkEncoder::vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkSampleLocationsInfoEXT* local_pSampleLocationsInfo;
    local_commandBuffer = commandBuffer;
    local_pSampleLocationsInfo = nullptr;
    if (pSampleLocationsInfo)
    {
        local_pSampleLocationsInfo = (VkSampleLocationsInfoEXT*)pool->alloc(sizeof(const VkSampleLocationsInfoEXT));
        deepcopy_VkSampleLocationsInfoEXT(pool, pSampleLocationsInfo, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    if (local_pSampleLocationsInfo)
    {
        transform_tohost_VkSampleLocationsInfoEXT(mImpl->resources(), (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1405;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1405, 1);
        countingStream->write((uint64_t*)&cgen_var_1405, 1 * 8);
        marshal_VkSampleLocationsInfoEXT(countingStream, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    uint32_t packetSize_vkCmdSetSampleLocationsEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetSampleLocationsEXT = OP_vkCmdSetSampleLocationsEXT;
    stream->write(&opcode_vkCmdSetSampleLocationsEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetSampleLocationsEXT, sizeof(uint32_t));
    uint64_t cgen_var_1406;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1406, 1);
    stream->write((uint64_t*)&cgen_var_1406, 1 * 8);
    marshal_VkSampleLocationsInfoEXT(stream, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
}

void VkEncoder::vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkPhysicalDevice local_physicalDevice;
    VkSampleCountFlagBits local_samples;
    local_physicalDevice = physicalDevice;
    local_samples = samples;
    countingStream->rewind();
    {
        uint64_t cgen_var_1407;
        countingStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1407, 1);
        countingStream->write((uint64_t*)&cgen_var_1407, 1 * 8);
        countingStream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
        marshal_VkMultisamplePropertiesEXT(countingStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT = OP_vkGetPhysicalDeviceMultisamplePropertiesEXT;
    stream->write(&opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t));
    uint64_t cgen_var_1408;
    stream->handleMapping()->mapHandles_VkPhysicalDevice_u64(&local_physicalDevice, &cgen_var_1408, 1);
    stream->write((uint64_t*)&cgen_var_1408, 1 * 8);
    stream->write((VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    marshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    unmarshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    if (pMultisampleProperties)
    {
        transform_fromhost_VkMultisamplePropertiesEXT(mImpl->resources(), (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
}

#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
VkResult VkEncoder::vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkValidationCacheCreateInfoEXT*)pool->alloc(sizeof(const VkValidationCacheCreateInfoEXT));
        deepcopy_VkValidationCacheCreateInfoEXT(pool, pCreateInfo, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkValidationCacheCreateInfoEXT(mImpl->resources(), (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1409;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1409, 1);
        countingStream->write((uint64_t*)&cgen_var_1409, 1 * 8);
        marshal_VkValidationCacheCreateInfoEXT(countingStream, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
        // WARNING PTR CHECK
        uint64_t cgen_var_1410 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1410);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
        uint64_t cgen_var_1411;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(pValidationCache, &cgen_var_1411, 1);
        countingStream->write((uint64_t*)&cgen_var_1411, 8);
    }
    uint32_t packetSize_vkCreateValidationCacheEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateValidationCacheEXT = OP_vkCreateValidationCacheEXT;
    stream->write(&opcode_vkCreateValidationCacheEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateValidationCacheEXT, sizeof(uint32_t));
    uint64_t cgen_var_1412;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1412, 1);
    stream->write((uint64_t*)&cgen_var_1412, 1 * 8);
    marshal_VkValidationCacheCreateInfoEXT(stream, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    // WARNING PTR CHECK
    uint64_t cgen_var_1413 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1413);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    stream->unsetHandleMapping() /* emit_marshal, is handle, possibly out */;
    uint64_t cgen_var_1414;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(pValidationCache, &cgen_var_1414, 1);
    stream->write((uint64_t*)&cgen_var_1414, 8);
    stream->setHandleMapping(resources->unwrapMapping());
    stream->setHandleMapping(resources->createMapping());
    uint64_t cgen_var_1415;
    stream->read((uint64_t*)&cgen_var_1415, 8);
    stream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_1415, (VkValidationCacheEXT*)pValidationCache, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkCreateValidationCacheEXT_VkResult_return;
}

void VkEncoder::vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_validationCache = validationCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(mImpl->resources(), (VkAllocationCallbacks*)(local_pAllocator));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1416;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1416, 1);
        countingStream->write((uint64_t*)&cgen_var_1416, 1 * 8);
        uint64_t cgen_var_1417;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1417, 1);
        countingStream->write((uint64_t*)&cgen_var_1417, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1418 = (uint64_t)(uintptr_t)local_pAllocator;
        countingStream->putBe64(cgen_var_1418);
        if (local_pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (VkAllocationCallbacks*)(local_pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyValidationCacheEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyValidationCacheEXT = OP_vkDestroyValidationCacheEXT;
    stream->write(&opcode_vkDestroyValidationCacheEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyValidationCacheEXT, sizeof(uint32_t));
    uint64_t cgen_var_1419;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1419, 1);
    stream->write((uint64_t*)&cgen_var_1419, 1 * 8);
    uint64_t cgen_var_1420;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1420, 1);
    stream->write((uint64_t*)&cgen_var_1420, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1421 = (uint64_t)(uintptr_t)local_pAllocator;
    stream->putBe64(cgen_var_1421);
    if (local_pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (VkAllocationCallbacks*)(local_pAllocator));
    }
    resources->destroyMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)&validationCache);
}

VkResult VkEncoder::vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheEXT local_dstCache;
    uint32_t local_srcCacheCount;
    VkValidationCacheEXT* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    local_pSrcCaches = nullptr;
    if (pSrcCaches)
    {
        local_pSrcCaches = (VkValidationCacheEXT*)pool->dupArray(pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1422;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1422, 1);
        countingStream->write((uint64_t*)&cgen_var_1422, 1 * 8);
        uint64_t cgen_var_1423;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_dstCache, &cgen_var_1423, 1);
        countingStream->write((uint64_t*)&cgen_var_1423, 1 * 8);
        countingStream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
        if (((srcCacheCount)))
        {
            uint64_t* cgen_var_1424;
            countingStream->alloc((void**)&cgen_var_1424, ((srcCacheCount)) * 8);
            countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(local_pSrcCaches, cgen_var_1424, ((srcCacheCount)));
            countingStream->write((uint64_t*)cgen_var_1424, ((srcCacheCount)) * 8);
        }
    }
    uint32_t packetSize_vkMergeValidationCachesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMergeValidationCachesEXT = OP_vkMergeValidationCachesEXT;
    stream->write(&opcode_vkMergeValidationCachesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkMergeValidationCachesEXT, sizeof(uint32_t));
    uint64_t cgen_var_1425;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1425, 1);
    stream->write((uint64_t*)&cgen_var_1425, 1 * 8);
    uint64_t cgen_var_1426;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_dstCache, &cgen_var_1426, 1);
    stream->write((uint64_t*)&cgen_var_1426, 1 * 8);
    stream->write((uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    if (((srcCacheCount)))
    {
        uint64_t* cgen_var_1427;
        stream->alloc((void**)&cgen_var_1427, ((srcCacheCount)) * 8);
        stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(local_pSrcCaches, cgen_var_1427, ((srcCacheCount)));
        stream->write((uint64_t*)cgen_var_1427, ((srcCacheCount)) * 8);
    }
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkMergeValidationCachesEXT_VkResult_return;
}

VkResult VkEncoder::vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    local_device = device;
    local_validationCache = validationCache;
    countingStream->rewind();
    {
        uint64_t cgen_var_1428;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1428, 1);
        countingStream->write((uint64_t*)&cgen_var_1428, 1 * 8);
        uint64_t cgen_var_1429;
        countingStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1429, 1);
        countingStream->write((uint64_t*)&cgen_var_1429, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1430 = (uint64_t)(uintptr_t)pDataSize;
        countingStream->putBe64(cgen_var_1430);
        if (pDataSize)
        {
            uint64_t cgen_var_1431 = (uint64_t)(*pDataSize);
            countingStream->putBe64(cgen_var_1431);
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1432 = (uint64_t)(uintptr_t)pData;
        countingStream->putBe64(cgen_var_1432);
        if (pData)
        {
            countingStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetValidationCacheDataEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetValidationCacheDataEXT = OP_vkGetValidationCacheDataEXT;
    stream->write(&opcode_vkGetValidationCacheDataEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetValidationCacheDataEXT, sizeof(uint32_t));
    uint64_t cgen_var_1433;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1433, 1);
    stream->write((uint64_t*)&cgen_var_1433, 1 * 8);
    uint64_t cgen_var_1434;
    stream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&local_validationCache, &cgen_var_1434, 1);
    stream->write((uint64_t*)&cgen_var_1434, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1435 = (uint64_t)(uintptr_t)pDataSize;
    stream->putBe64(cgen_var_1435);
    if (pDataSize)
    {
        uint64_t cgen_var_1436 = (uint64_t)(*pDataSize);
        stream->putBe64(cgen_var_1436);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1437 = (uint64_t)(uintptr_t)pData;
    stream->putBe64(cgen_var_1437);
    if (pData)
    {
        stream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetValidationCacheDataEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
VkResult VkEncoder::vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    void* local_pHostPointer;
    local_device = device;
    local_handleType = handleType;
    local_pHostPointer = nullptr;
    if (pHostPointer)
    {
        local_pHostPointer = (void*)pool->dupArray(pHostPointer, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1441;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1441, 1);
        countingStream->write((uint64_t*)&cgen_var_1441, 1 * 8);
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        // WARNING PTR CHECK
        uint64_t cgen_var_1442 = (uint64_t)(uintptr_t)local_pHostPointer;
        countingStream->putBe64(cgen_var_1442);
        if (local_pHostPointer)
        {
            countingStream->write((void*)local_pHostPointer, sizeof(uint8_t));
        }
        marshal_VkMemoryHostPointerPropertiesEXT(countingStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    uint32_t packetSize_vkGetMemoryHostPointerPropertiesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryHostPointerPropertiesEXT = OP_vkGetMemoryHostPointerPropertiesEXT;
    stream->write(&opcode_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t));
    uint64_t cgen_var_1443;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1443, 1);
    stream->write((uint64_t*)&cgen_var_1443, 1 * 8);
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_1444 = (uint64_t)(uintptr_t)local_pHostPointer;
    stream->putBe64(cgen_var_1444);
    if (local_pHostPointer)
    {
        stream->write((void*)local_pHostPointer, sizeof(uint8_t));
    }
    marshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    unmarshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    if (pMemoryHostPointerProperties)
    {
        transform_fromhost_VkMemoryHostPointerPropertiesEXT(mImpl->resources(), (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_buffer_marker
void VkEncoder::vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    uint32_t local_marker;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_marker = marker;
    countingStream->rewind();
    {
        uint64_t cgen_var_1445;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1445, 1);
        countingStream->write((uint64_t*)&cgen_var_1445, 1 * 8);
        countingStream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
        uint64_t cgen_var_1446;
        countingStream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_1446, 1);
        countingStream->write((uint64_t*)&cgen_var_1446, 1 * 8);
        countingStream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&local_marker, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdWriteBufferMarkerAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWriteBufferMarkerAMD = OP_vkCmdWriteBufferMarkerAMD;
    stream->write(&opcode_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t));
    uint64_t cgen_var_1447;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1447, 1);
    stream->write((uint64_t*)&cgen_var_1447, 1 * 8);
    stream->write((VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    uint64_t cgen_var_1448;
    stream->handleMapping()->mapHandles_VkBuffer_u64(&local_dstBuffer, &cgen_var_1448, 1);
    stream->write((uint64_t*)&cgen_var_1448, 1 * 8);
    stream->write((VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&local_marker, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void VkEncoder::vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkCommandBuffer local_commandBuffer;
    void* local_pCheckpointMarker;
    local_commandBuffer = commandBuffer;
    local_pCheckpointMarker = nullptr;
    if (pCheckpointMarker)
    {
        local_pCheckpointMarker = (void*)pool->dupArray(pCheckpointMarker, sizeof(const uint8_t));
    }
    countingStream->rewind();
    {
        uint64_t cgen_var_1449;
        countingStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1449, 1);
        countingStream->write((uint64_t*)&cgen_var_1449, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1450 = (uint64_t)(uintptr_t)local_pCheckpointMarker;
        countingStream->putBe64(cgen_var_1450);
        if (local_pCheckpointMarker)
        {
            countingStream->write((void*)local_pCheckpointMarker, sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkCmdSetCheckpointNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetCheckpointNV = OP_vkCmdSetCheckpointNV;
    stream->write(&opcode_vkCmdSetCheckpointNV, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetCheckpointNV, sizeof(uint32_t));
    uint64_t cgen_var_1451;
    stream->handleMapping()->mapHandles_VkCommandBuffer_u64(&local_commandBuffer, &cgen_var_1451, 1);
    stream->write((uint64_t*)&cgen_var_1451, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1452 = (uint64_t)(uintptr_t)local_pCheckpointMarker;
    stream->putBe64(cgen_var_1452);
    if (local_pCheckpointMarker)
    {
        stream->write((void*)local_pCheckpointMarker, sizeof(uint8_t));
    }
}

void VkEncoder::vkGetQueueCheckpointDataNV(
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkQueue local_queue;
    local_queue = queue;
    countingStream->rewind();
    {
        uint64_t cgen_var_1453;
        countingStream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1453, 1);
        countingStream->write((uint64_t*)&cgen_var_1453, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1454 = (uint64_t)(uintptr_t)pCheckpointDataCount;
        countingStream->putBe64(cgen_var_1454);
        if (pCheckpointDataCount)
        {
            countingStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
        }
        // WARNING PTR CHECK
        uint64_t cgen_var_1455 = (uint64_t)(uintptr_t)pCheckpointData;
        countingStream->putBe64(cgen_var_1455);
        if (pCheckpointData)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
            {
                marshal_VkCheckpointDataNV(countingStream, (VkCheckpointDataNV*)(pCheckpointData + i));
            }
        }
    }
    uint32_t packetSize_vkGetQueueCheckpointDataNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetQueueCheckpointDataNV = OP_vkGetQueueCheckpointDataNV;
    stream->write(&opcode_vkGetQueueCheckpointDataNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetQueueCheckpointDataNV, sizeof(uint32_t));
    uint64_t cgen_var_1456;
    stream->handleMapping()->mapHandles_VkQueue_u64(&local_queue, &cgen_var_1456, 1);
    stream->write((uint64_t*)&cgen_var_1456, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1457 = (uint64_t)(uintptr_t)pCheckpointDataCount;
    stream->putBe64(cgen_var_1457);
    if (pCheckpointDataCount)
    {
        stream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1458 = (uint64_t)(uintptr_t)pCheckpointData;
    stream->putBe64(cgen_var_1458);
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            marshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pCheckpointDataCount;
    check_pCheckpointDataCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pCheckpointDataCount)
    {
        if (!(check_pCheckpointDataCount))
        {
            fprintf(stderr, "fatal: pCheckpointDataCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkCheckpointDataNV* check_pCheckpointData;
    check_pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)stream->getBe64();
    if (pCheckpointData)
    {
        if (!(check_pCheckpointData))
        {
            fprintf(stderr, "fatal: pCheckpointData inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            unmarshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            transform_fromhost_VkCheckpointDataNV(mImpl->resources(), (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
}

#endif
#ifdef VK_GOOGLE_address_space
VkResult VkEncoder::vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress)
{
    mImpl->resources()->on_vkMapMemoryIntoAddressSpaceGOOGLE_pre(this, VK_SUCCESS, device, memory, pAddress);
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    auto resources = mImpl->resources();
    auto pool = mImpl->pool();
    stream->setHandleMapping(resources->unwrapMapping());
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    mImpl->resources()->deviceMemoryTransform_tohost(&local_memory, 1, nullptr, 0, nullptr, 0, nullptr, 0, nullptr, 0);
    countingStream->rewind();
    {
        uint64_t cgen_var_1461;
        countingStream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1461, 1);
        countingStream->write((uint64_t*)&cgen_var_1461, 1 * 8);
        uint64_t cgen_var_1462;
        countingStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1462, 1);
        countingStream->write((uint64_t*)&cgen_var_1462, 1 * 8);
        // WARNING PTR CHECK
        uint64_t cgen_var_1463 = (uint64_t)(uintptr_t)pAddress;
        countingStream->putBe64(cgen_var_1463);
        if (pAddress)
        {
            countingStream->write((uint64_t*)pAddress, sizeof(uint64_t));
        }
    }
    uint32_t packetSize_vkMapMemoryIntoAddressSpaceGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMapMemoryIntoAddressSpaceGOOGLE = OP_vkMapMemoryIntoAddressSpaceGOOGLE;
    stream->write(&opcode_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t));
    uint64_t cgen_var_1464;
    stream->handleMapping()->mapHandles_VkDevice_u64(&local_device, &cgen_var_1464, 1);
    stream->write((uint64_t*)&cgen_var_1464, 1 * 8);
    uint64_t cgen_var_1465;
    stream->handleMapping()->mapHandles_VkDeviceMemory_u64(&local_memory, &cgen_var_1465, 1);
    stream->write((uint64_t*)&cgen_var_1465, 1 * 8);
    // WARNING PTR CHECK
    uint64_t cgen_var_1466 = (uint64_t)(uintptr_t)pAddress;
    stream->putBe64(cgen_var_1466);
    if (pAddress)
    {
        stream->write((uint64_t*)pAddress, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
    countingStream->clearPool();
    stream->clearPool();
    pool->freeAll();
    mImpl->resources()->on_vkMapMemoryIntoAddressSpaceGOOGLE(this, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}

#endif

} // namespace goldfish_vk
