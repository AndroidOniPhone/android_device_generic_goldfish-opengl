// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkEncoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkEncoder.h"


#include "IOStream.h"
#include "VulkanStream.h"

#include "goldfish_vk_marshaling_guest.h"






using goldfish_vk::VulkanCountingStream;
using goldfish_vk::VulkanStream;

class VkEncoder::Impl {
public:
    Impl(IOStream* stream) : m_stream(stream) { }
    VulkanCountingStream* countingStream() { return &m_countingStream; }
    VulkanStream* stream() { return &m_stream; }
private:
    VulkanCountingStream m_countingStream;
    VulkanStream m_stream;
};

VkEncoder::VkEncoder(IOStream *stream) :
    mImpl(new VkEncoder::Impl(stream)) { }
#ifdef VK_VERSION_1_0
VkResult VkEncoder::vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        marshal_VkInstanceCreateInfo(countingStream, (const VkInstanceCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkInstance*)pInstance, sizeof(VkInstance));
    }
    uint32_t packetSize_vkCreateInstance = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateInstance = OP_vkCreateInstance;
    stream->write(&opcode_vkCreateInstance, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateInstance, sizeof(uint32_t));
    marshal_VkInstanceCreateInfo(stream, (const VkInstanceCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkInstance*)pInstance, sizeof(VkInstance));
    stream->read((VkInstance*)pInstance, sizeof(VkInstance));
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    stream->read(&vkCreateInstance_VkResult_return, sizeof(VkResult));
    return vkCreateInstance_VkResult_return;
}

void VkEncoder::vkDestroyInstance(
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyInstance = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyInstance = OP_vkDestroyInstance;
    stream->write(&opcode_vkDestroyInstance, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyInstance, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkEnumeratePhysicalDevices(
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((uint32_t**)&pPhysicalDeviceCount, sizeof(uint32_t*));
        if (pPhysicalDeviceCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
        }
        countingStream->write((VkPhysicalDevice**)&pPhysicalDevices, sizeof(VkPhysicalDevice*));
        if (pPhysicalDevices)
        {
            countingStream->write((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDevices = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDevices = OP_vkEnumeratePhysicalDevices;
    stream->write(&opcode_vkEnumeratePhysicalDevices, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDevices, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((uint32_t**)&pPhysicalDeviceCount, sizeof(uint32_t*));
    if (pPhysicalDeviceCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->write((VkPhysicalDevice**)&pPhysicalDevices, sizeof(VkPhysicalDevice*));
    if (pPhysicalDevices)
    {
        stream->write((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
    }
    uint32_t* check_pPhysicalDeviceCount;
    stream->read((uint32_t**)&check_pPhysicalDeviceCount, sizeof(uint32_t*));
    if (pPhysicalDeviceCount)
    {
        if (!(check_pPhysicalDeviceCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    VkPhysicalDevice* check_pPhysicalDevices;
    stream->read((VkPhysicalDevice**)&check_pPhysicalDevices, sizeof(VkPhysicalDevice*));
    if (pPhysicalDevices)
    {
        if (!(check_pPhysicalDevices))
        {
            fprintf(stderr, "fatal: pPhysicalDevices inconsistent between guest and host\n");
        }
        stream->read((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
    }
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    return vkEnumeratePhysicalDevices_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceFeatures(countingStream, (VkPhysicalDeviceFeatures*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures = OP_vkGetPhysicalDeviceFeatures;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
    unmarshal_VkPhysicalDeviceFeatures(stream, (VkPhysicalDeviceFeatures*)(pFeatures));
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkFormat*)&format, sizeof(VkFormat));
        marshal_VkFormatProperties(countingStream, (VkFormatProperties*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties = OP_vkGetPhysicalDeviceFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkFormat*)&format, sizeof(VkFormat));
    marshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
    unmarshal_VkFormatProperties(stream, (VkFormatProperties*)(pFormatProperties));
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkFormat*)&format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&type, sizeof(VkImageType));
        countingStream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
        countingStream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
        marshal_VkImageFormatProperties(countingStream, (VkImageFormatProperties*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties = OP_vkGetPhysicalDeviceImageFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkFormat*)&format, sizeof(VkFormat));
    stream->write((VkImageType*)&type, sizeof(VkImageType));
    stream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    stream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
    marshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    unmarshal_VkImageFormatProperties(stream, (VkImageFormatProperties*)(pImageFormatProperties));
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceProperties(countingStream, (VkPhysicalDeviceProperties*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties = OP_vkGetPhysicalDeviceProperties;
    stream->write(&opcode_vkGetPhysicalDeviceProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
    unmarshal_VkPhysicalDeviceProperties(stream, (VkPhysicalDeviceProperties*)(pProperties));
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkQueueFamilyProperties**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties*));
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties(countingStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties = OP_vkGetPhysicalDeviceQueueFamilyProperties;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkQueueFamilyProperties**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties*));
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
    uint32_t* check_pQueueFamilyPropertyCount;
    stream->read((uint32_t**)&check_pQueueFamilyPropertyCount, sizeof(uint32_t*));
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    VkQueueFamilyProperties* check_pQueueFamilyProperties;
    stream->read((VkQueueFamilyProperties**)&check_pQueueFamilyProperties, sizeof(VkQueueFamilyProperties*));
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties(stream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceMemoryProperties(countingStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties = OP_vkGetPhysicalDeviceMemoryProperties;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    unmarshal_VkPhysicalDeviceMemoryProperties(stream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
}

PFN_vkVoidFunction VkEncoder::vkGetInstanceProcAddr(
    VkInstance instance,
    const char* pName)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->putString(pName);
    }
    uint32_t packetSize_vkGetInstanceProcAddr = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetInstanceProcAddr = OP_vkGetInstanceProcAddr;
    stream->write(&opcode_vkGetInstanceProcAddr, sizeof(uint32_t));
    stream->write(&packetSize_vkGetInstanceProcAddr, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->putString(pName);
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction VkEncoder::vkGetDeviceProcAddr(
    VkDevice device,
    const char* pName)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->putString(pName);
    }
    uint32_t packetSize_vkGetDeviceProcAddr = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceProcAddr = OP_vkGetDeviceProcAddr;
    stream->write(&opcode_vkGetDeviceProcAddr, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceProcAddr, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->putString(pName);
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

VkResult VkEncoder::vkCreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkDeviceCreateInfo(countingStream, (const VkDeviceCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDevice*)pDevice, sizeof(VkDevice));
    }
    uint32_t packetSize_vkCreateDevice = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDevice = OP_vkCreateDevice;
    stream->write(&opcode_vkCreateDevice, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDevice, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkDeviceCreateInfo(stream, (const VkDeviceCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDevice*)pDevice, sizeof(VkDevice));
    stream->read((VkDevice*)pDevice, sizeof(VkDevice));
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDevice_VkResult_return, sizeof(VkResult));
    return vkCreateDevice_VkResult_return;
}

void VkEncoder::vkDestroyDevice(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDevice = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDevice = OP_vkDestroyDevice;
    stream->write(&opcode_vkDestroyDevice, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDevice, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->putString(pLayerName);
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkExtensionProperties(countingStream, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceExtensionProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceExtensionProperties = OP_vkEnumerateInstanceExtensionProperties;
    stream->write(&opcode_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t));
    stream->putString(pLayerName);
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkExtensionProperties* check_pProperties;
    stream->read((VkExtensionProperties**)&check_pProperties, sizeof(VkExtensionProperties*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->putString(pLayerName);
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkExtensionProperties(countingStream, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceExtensionProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateDeviceExtensionProperties = OP_vkEnumerateDeviceExtensionProperties;
    stream->write(&opcode_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->putString(pLayerName);
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkExtensionProperties**)&pProperties, sizeof(VkExtensionProperties*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkExtensionProperties* check_pProperties;
    stream->read((VkExtensionProperties**)&check_pProperties, sizeof(VkExtensionProperties*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkExtensionProperties(stream, (VkExtensionProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkLayerProperties(countingStream, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceLayerProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceLayerProperties = OP_vkEnumerateInstanceLayerProperties;
    stream->write(&opcode_vkEnumerateInstanceLayerProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceLayerProperties, sizeof(uint32_t));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkLayerProperties* check_pProperties;
    stream->read((VkLayerProperties**)&check_pProperties, sizeof(VkLayerProperties*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkLayerProperties(countingStream, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceLayerProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateDeviceLayerProperties = OP_vkEnumerateDeviceLayerProperties;
    stream->write(&opcode_vkEnumerateDeviceLayerProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateDeviceLayerProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkLayerProperties**)&pProperties, sizeof(VkLayerProperties*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkLayerProperties* check_pProperties;
    stream->read((VkLayerProperties**)&check_pProperties, sizeof(VkLayerProperties*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkLayerProperties(stream, (VkLayerProperties*)(pProperties + i));
        }
    }
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}

void VkEncoder::vkGetDeviceQueue(
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&queueIndex, sizeof(uint32_t));
        countingStream->write((VkQueue*)pQueue, sizeof(VkQueue));
    }
    uint32_t packetSize_vkGetDeviceQueue = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceQueue = OP_vkGetDeviceQueue;
    stream->write(&opcode_vkGetDeviceQueue, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceQueue, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&queueIndex, sizeof(uint32_t));
    stream->write((VkQueue*)pQueue, sizeof(VkQueue));
    stream->read((VkQueue*)pQueue, sizeof(VkQueue));
}

VkResult VkEncoder::vkQueueSubmit(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
        countingStream->write((uint32_t*)&submitCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            marshal_VkSubmitInfo(countingStream, (const VkSubmitInfo*)(pSubmits + i));
        }
        countingStream->write((VkFence*)&fence, sizeof(VkFence));
    }
    uint32_t packetSize_vkQueueSubmit = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueSubmit = OP_vkQueueSubmit;
    stream->write(&opcode_vkQueueSubmit, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueSubmit, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    stream->write((uint32_t*)&submitCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        marshal_VkSubmitInfo(stream, (const VkSubmitInfo*)(pSubmits + i));
    }
    stream->write((VkFence*)&fence, sizeof(VkFence));
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
    return vkQueueSubmit_VkResult_return;
}

VkResult VkEncoder::vkQueueWaitIdle(
    VkQueue queue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
    }
    uint32_t packetSize_vkQueueWaitIdle = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueWaitIdle = OP_vkQueueWaitIdle;
    stream->write(&opcode_vkQueueWaitIdle, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueWaitIdle, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    return vkQueueWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkDeviceWaitIdle(
    VkDevice device)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
    }
    uint32_t packetSize_vkDeviceWaitIdle = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDeviceWaitIdle = OP_vkDeviceWaitIdle;
    stream->write(&opcode_vkDeviceWaitIdle, sizeof(uint32_t));
    stream->write(&packetSize_vkDeviceWaitIdle, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    return vkDeviceWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkAllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkMemoryAllocateInfo(countingStream, (const VkMemoryAllocateInfo*)(pAllocateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
    }
    uint32_t packetSize_vkAllocateMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateMemory = OP_vkAllocateMemory;
    stream->write(&opcode_vkAllocateMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateMemory, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryAllocateInfo(stream, (const VkMemoryAllocateInfo*)(pAllocateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
    stream->read((VkDeviceMemory*)pMemory, sizeof(VkDeviceMemory));
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
    return vkAllocateMemory_VkResult_return;
}

void VkEncoder::vkFreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkFreeMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeMemory = OP_vkFreeMemory;
    stream->write(&opcode_vkFreeMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeMemory, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkMapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&size, sizeof(VkDeviceSize));
        countingStream->write((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
        countingStream->write((void***)&ppData, sizeof(void**));
        if (ppData)
        {
            countingStream->write((void**)ppData, sizeof(void*));
        }
    }
    uint32_t packetSize_vkMapMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMapMemory = OP_vkMapMemory;
    stream->write(&opcode_vkMapMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkMapMemory, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&size, sizeof(VkDeviceSize));
    stream->write((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
    stream->write((void***)&ppData, sizeof(void**));
    if (ppData)
    {
        stream->write((void**)ppData, sizeof(void*));
    }
    void** check_ppData;
    stream->read((void***)&check_ppData, sizeof(void**));
    if (ppData)
    {
        if (!(check_ppData))
        {
            fprintf(stderr, "fatal: ppData inconsistent between guest and host\n");
        }
        stream->read((void**)ppData, sizeof(void*));
    }
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    stream->read(&vkMapMemory_VkResult_return, sizeof(VkResult));
    return vkMapMemory_VkResult_return;
}

void VkEncoder::vkUnmapMemory(
    VkDevice device,
    VkDeviceMemory memory)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    }
    uint32_t packetSize_vkUnmapMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUnmapMemory = OP_vkUnmapMemory;
    stream->write(&opcode_vkUnmapMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkUnmapMemory, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
}

VkResult VkEncoder::vkFlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            marshal_VkMappedMemoryRange(countingStream, (const VkMappedMemoryRange*)(pMemoryRanges + i));
        }
    }
    uint32_t packetSize_vkFlushMappedMemoryRanges = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFlushMappedMemoryRanges = OP_vkFlushMappedMemoryRanges;
    stream->write(&opcode_vkFlushMappedMemoryRanges, sizeof(uint32_t));
    stream->write(&packetSize_vkFlushMappedMemoryRanges, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(stream, (const VkMappedMemoryRange*)(pMemoryRanges + i));
    }
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    return vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult VkEncoder::vkInvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            marshal_VkMappedMemoryRange(countingStream, (const VkMappedMemoryRange*)(pMemoryRanges + i));
        }
    }
    uint32_t packetSize_vkInvalidateMappedMemoryRanges = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkInvalidateMappedMemoryRanges = OP_vkInvalidateMappedMemoryRanges;
    stream->write(&opcode_vkInvalidateMappedMemoryRanges, sizeof(uint32_t));
    stream->write(&packetSize_vkInvalidateMappedMemoryRanges, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        marshal_VkMappedMemoryRange(stream, (const VkMappedMemoryRange*)(pMemoryRanges + i));
    }
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}

void VkEncoder::vkGetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
        countingStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkGetDeviceMemoryCommitment = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceMemoryCommitment = OP_vkGetDeviceMemoryCommitment;
    stream->write(&opcode_vkGetDeviceMemoryCommitment, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceMemoryCommitment, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    stream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    stream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
}

VkResult VkEncoder::vkBindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
        countingStream->write((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkBindBufferMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory = OP_vkBindBufferMemory;
    stream->write(&opcode_vkBindBufferMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    stream->write((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    return vkBindBufferMemory_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
        countingStream->write((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkBindImageMemory = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory = OP_vkBindImageMemory;
    stream->write(&opcode_vkBindImageMemory, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkImage*)&image, sizeof(VkImage));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    stream->write((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
    return vkBindImageMemory_VkResult_return;
}

void VkEncoder::vkGetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements = OP_vkGetBufferMemoryRequirements;
    stream->write(&opcode_vkGetBufferMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
}

void VkEncoder::vkGetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        marshal_VkMemoryRequirements(countingStream, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements = OP_vkGetImageMemoryRequirements;
    stream->write(&opcode_vkGetImageMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkImage*)&image, sizeof(VkImage));
    marshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements(stream, (VkMemoryRequirements*)(pMemoryRequirements));
}

void VkEncoder::vkGetImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        countingStream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        countingStream->write((VkSparseImageMemoryRequirements**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements*));
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements(countingStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements = OP_vkGetImageSparseMemoryRequirements;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkImage*)&image, sizeof(VkImage));
    stream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    stream->write((VkSparseImageMemoryRequirements**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements*));
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
    uint32_t* check_pSparseMemoryRequirementCount;
    stream->read((uint32_t**)&check_pSparseMemoryRequirementCount, sizeof(uint32_t*));
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    VkSparseImageMemoryRequirements* check_pSparseMemoryRequirements;
    stream->read((VkSparseImageMemoryRequirements**)&check_pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements*));
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements(stream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkFormat*)&format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&type, sizeof(VkImageType));
        countingStream->write((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
        countingStream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkSparseImageFormatProperties**)&pProperties, sizeof(VkSparseImageFormatProperties*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties(countingStream, (VkSparseImageFormatProperties*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties = OP_vkGetPhysicalDeviceSparseImageFormatProperties;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkFormat*)&format, sizeof(VkFormat));
    stream->write((VkImageType*)&type, sizeof(VkImageType));
    stream->write((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
    stream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkSparseImageFormatProperties**)&pProperties, sizeof(VkSparseImageFormatProperties*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkSparseImageFormatProperties* check_pProperties;
    stream->read((VkSparseImageFormatProperties**)&check_pProperties, sizeof(VkSparseImageFormatProperties*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties(stream, (VkSparseImageFormatProperties*)(pProperties + i));
        }
    }
}

VkResult VkEncoder::vkQueueBindSparse(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
        countingStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindSparseInfo(countingStream, (const VkBindSparseInfo*)(pBindInfo + i));
        }
        countingStream->write((VkFence*)&fence, sizeof(VkFence));
    }
    uint32_t packetSize_vkQueueBindSparse = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueBindSparse = OP_vkQueueBindSparse;
    stream->write(&opcode_vkQueueBindSparse, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueBindSparse, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    stream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindSparseInfo(stream, (const VkBindSparseInfo*)(pBindInfo + i));
    }
    stream->write((VkFence*)&fence, sizeof(VkFence));
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    stream->read(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    return vkQueueBindSparse_VkResult_return;
}

VkResult VkEncoder::vkCreateFence(
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkFenceCreateInfo(countingStream, (const VkFenceCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkFence*)pFence, sizeof(VkFence));
    }
    uint32_t packetSize_vkCreateFence = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateFence = OP_vkCreateFence;
    stream->write(&opcode_vkCreateFence, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateFence, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFenceCreateInfo(stream, (const VkFenceCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkFence*)pFence, sizeof(VkFence));
    stream->read((VkFence*)pFence, sizeof(VkFence));
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFence_VkResult_return, sizeof(VkResult));
    return vkCreateFence_VkResult_return;
}

void VkEncoder::vkDestroyFence(
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkFence*)&fence, sizeof(VkFence));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyFence = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyFence = OP_vkDestroyFence;
    stream->write(&opcode_vkDestroyFence, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyFence, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkFence*)&fence, sizeof(VkFence));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkResetFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&fenceCount, sizeof(uint32_t));
        countingStream->write((const VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    }
    uint32_t packetSize_vkResetFences = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetFences = OP_vkResetFences;
    stream->write(&opcode_vkResetFences, sizeof(uint32_t));
    stream->write(&packetSize_vkResetFences, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&fenceCount, sizeof(uint32_t));
    stream->write((const VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    stream->read(&vkResetFences_VkResult_return, sizeof(VkResult));
    return vkResetFences_VkResult_return;
}

VkResult VkEncoder::vkGetFenceStatus(
    VkDevice device,
    VkFence fence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkFence*)&fence, sizeof(VkFence));
    }
    uint32_t packetSize_vkGetFenceStatus = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceStatus = OP_vkGetFenceStatus;
    stream->write(&opcode_vkGetFenceStatus, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceStatus, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkFence*)&fence, sizeof(VkFence));
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    return vkGetFenceStatus_VkResult_return;
}

VkResult VkEncoder::vkWaitForFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&fenceCount, sizeof(uint32_t));
        countingStream->write((const VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
        countingStream->write((VkBool32*)&waitAll, sizeof(VkBool32));
        countingStream->write((uint64_t*)&timeout, sizeof(uint64_t));
    }
    uint32_t packetSize_vkWaitForFences = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkWaitForFences = OP_vkWaitForFences;
    stream->write(&opcode_vkWaitForFences, sizeof(uint32_t));
    stream->write(&packetSize_vkWaitForFences, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&fenceCount, sizeof(uint32_t));
    stream->write((const VkFence*)pFences, ((fenceCount)) * sizeof(const VkFence));
    stream->write((VkBool32*)&waitAll, sizeof(VkBool32));
    stream->write((uint64_t*)&timeout, sizeof(uint64_t));
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    stream->read(&vkWaitForFences_VkResult_return, sizeof(VkResult));
    return vkWaitForFences_VkResult_return;
}

VkResult VkEncoder::vkCreateSemaphore(
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSemaphoreCreateInfo(countingStream, (const VkSemaphoreCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
    }
    uint32_t packetSize_vkCreateSemaphore = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSemaphore = OP_vkCreateSemaphore;
    stream->write(&opcode_vkCreateSemaphore, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSemaphore, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSemaphoreCreateInfo(stream, (const VkSemaphoreCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
    stream->read((VkSemaphore*)pSemaphore, sizeof(VkSemaphore));
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    return vkCreateSemaphore_VkResult_return;
}

void VkEncoder::vkDestroySemaphore(
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySemaphore = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySemaphore = OP_vkDestroySemaphore;
    stream->write(&opcode_vkDestroySemaphore, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySemaphore, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateEvent(
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkEventCreateInfo(countingStream, (const VkEventCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkEvent*)pEvent, sizeof(VkEvent));
    }
    uint32_t packetSize_vkCreateEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateEvent = OP_vkCreateEvent;
    stream->write(&opcode_vkCreateEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateEvent, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkEventCreateInfo(stream, (const VkEventCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkEvent*)pEvent, sizeof(VkEvent));
    stream->read((VkEvent*)pEvent, sizeof(VkEvent));
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    stream->read(&vkCreateEvent_VkResult_return, sizeof(VkResult));
    return vkCreateEvent_VkResult_return;
}

void VkEncoder::vkDestroyEvent(
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkEvent*)&event, sizeof(VkEvent));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyEvent = OP_vkDestroyEvent;
    stream->write(&opcode_vkDestroyEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyEvent, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkEvent*)&event, sizeof(VkEvent));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkGetEventStatus(
    VkDevice device,
    VkEvent event)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkEvent*)&event, sizeof(VkEvent));
    }
    uint32_t packetSize_vkGetEventStatus = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetEventStatus = OP_vkGetEventStatus;
    stream->write(&opcode_vkGetEventStatus, sizeof(uint32_t));
    stream->write(&packetSize_vkGetEventStatus, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkEvent*)&event, sizeof(VkEvent));
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
    return vkGetEventStatus_VkResult_return;
}

VkResult VkEncoder::vkSetEvent(
    VkDevice device,
    VkEvent event)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkEvent*)&event, sizeof(VkEvent));
    }
    uint32_t packetSize_vkSetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetEvent = OP_vkSetEvent;
    stream->write(&opcode_vkSetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkSetEvent, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkEvent*)&event, sizeof(VkEvent));
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkSetEvent_VkResult_return, sizeof(VkResult));
    return vkSetEvent_VkResult_return;
}

VkResult VkEncoder::vkResetEvent(
    VkDevice device,
    VkEvent event)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkEvent*)&event, sizeof(VkEvent));
    }
    uint32_t packetSize_vkResetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetEvent = OP_vkResetEvent;
    stream->write(&opcode_vkResetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkResetEvent, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkEvent*)&event, sizeof(VkEvent));
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkResetEvent_VkResult_return, sizeof(VkResult));
    return vkResetEvent_VkResult_return;
}

VkResult VkEncoder::vkCreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkQueryPoolCreateInfo(countingStream, (const VkQueryPoolCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
    }
    uint32_t packetSize_vkCreateQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateQueryPool = OP_vkCreateQueryPool;
    stream->write(&opcode_vkCreateQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateQueryPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkQueryPoolCreateInfo(stream, (const VkQueryPoolCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
    stream->read((VkQueryPool*)pQueryPool, sizeof(VkQueryPool));
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    return vkCreateQueryPool_VkResult_return;
}

void VkEncoder::vkDestroyQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyQueryPool = OP_vkDestroyQueryPool;
    stream->write(&opcode_vkDestroyQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyQueryPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkGetQueryPoolResults(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&queryCount, sizeof(uint32_t));
        countingStream->write((size_t*)&dataSize, sizeof(size_t));
        countingStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
        countingStream->write((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
        countingStream->write((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
    }
    uint32_t packetSize_vkGetQueryPoolResults = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetQueryPoolResults = OP_vkGetQueryPoolResults;
    stream->write(&opcode_vkGetQueryPoolResults, sizeof(uint32_t));
    stream->write(&packetSize_vkGetQueryPoolResults, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&queryCount, sizeof(uint32_t));
    stream->write((size_t*)&dataSize, sizeof(size_t));
    stream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
    stream->write((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
    stream->write((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    stream->read(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    return vkGetQueryPoolResults_VkResult_return;
}

VkResult VkEncoder::vkCreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkBufferCreateInfo(countingStream, (const VkBufferCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkBuffer*)pBuffer, sizeof(VkBuffer));
    }
    uint32_t packetSize_vkCreateBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBuffer = OP_vkCreateBuffer;
    stream->write(&opcode_vkCreateBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBuffer, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferCreateInfo(stream, (const VkBufferCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkBuffer*)pBuffer, sizeof(VkBuffer));
    stream->read((VkBuffer*)pBuffer, sizeof(VkBuffer));
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
    return vkCreateBuffer_VkResult_return;
}

void VkEncoder::vkDestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyBuffer = OP_vkDestroyBuffer;
    stream->write(&opcode_vkDestroyBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyBuffer, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkBufferViewCreateInfo(countingStream, (const VkBufferViewCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkBufferView*)pView, sizeof(VkBufferView));
    }
    uint32_t packetSize_vkCreateBufferView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateBufferView = OP_vkCreateBufferView;
    stream->write(&opcode_vkCreateBufferView, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateBufferView, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferViewCreateInfo(stream, (const VkBufferViewCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkBufferView*)pView, sizeof(VkBufferView));
    stream->read((VkBufferView*)pView, sizeof(VkBufferView));
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
    return vkCreateBufferView_VkResult_return;
}

void VkEncoder::vkDestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkBufferView*)&bufferView, sizeof(VkBufferView));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyBufferView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyBufferView = OP_vkDestroyBufferView;
    stream->write(&opcode_vkDestroyBufferView, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyBufferView, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkBufferView*)&bufferView, sizeof(VkBufferView));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImageCreateInfo(countingStream, (const VkImageCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkImage*)pImage, sizeof(VkImage));
    }
    uint32_t packetSize_vkCreateImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImage = OP_vkCreateImage;
    stream->write(&opcode_vkCreateImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImage, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageCreateInfo(stream, (const VkImageCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkImage*)pImage, sizeof(VkImage));
    stream->read((VkImage*)pImage, sizeof(VkImage));
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImage_VkResult_return, sizeof(VkResult));
    return vkCreateImage_VkResult_return;
}

void VkEncoder::vkDestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyImage = OP_vkDestroyImage;
    stream->write(&opcode_vkDestroyImage, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyImage, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkImage*)&image, sizeof(VkImage));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void VkEncoder::vkGetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        marshal_VkImageSubresource(countingStream, (const VkImageSubresource*)(pSubresource));
        marshal_VkSubresourceLayout(countingStream, (VkSubresourceLayout*)(pLayout));
    }
    uint32_t packetSize_vkGetImageSubresourceLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSubresourceLayout = OP_vkGetImageSubresourceLayout;
    stream->write(&opcode_vkGetImageSubresourceLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSubresourceLayout, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkImage*)&image, sizeof(VkImage));
    marshal_VkImageSubresource(stream, (const VkImageSubresource*)(pSubresource));
    marshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
    unmarshal_VkSubresourceLayout(stream, (VkSubresourceLayout*)(pLayout));
}

VkResult VkEncoder::vkCreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImageViewCreateInfo(countingStream, (const VkImageViewCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkImageView*)pView, sizeof(VkImageView));
    }
    uint32_t packetSize_vkCreateImageView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateImageView = OP_vkCreateImageView;
    stream->write(&opcode_vkCreateImageView, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateImageView, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageViewCreateInfo(stream, (const VkImageViewCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkImageView*)pView, sizeof(VkImageView));
    stream->read((VkImageView*)pView, sizeof(VkImageView));
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageView_VkResult_return, sizeof(VkResult));
    return vkCreateImageView_VkResult_return;
}

void VkEncoder::vkDestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkImageView*)&imageView, sizeof(VkImageView));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyImageView = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyImageView = OP_vkDestroyImageView;
    stream->write(&opcode_vkDestroyImageView, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyImageView, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkImageView*)&imageView, sizeof(VkImageView));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateShaderModule(
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkShaderModuleCreateInfo(countingStream, (const VkShaderModuleCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
    }
    uint32_t packetSize_vkCreateShaderModule = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateShaderModule = OP_vkCreateShaderModule;
    stream->write(&opcode_vkCreateShaderModule, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateShaderModule, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkShaderModuleCreateInfo(stream, (const VkShaderModuleCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
    stream->read((VkShaderModule*)pShaderModule, sizeof(VkShaderModule));
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    stream->read(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    return vkCreateShaderModule_VkResult_return;
}

void VkEncoder::vkDestroyShaderModule(
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkShaderModule*)&shaderModule, sizeof(VkShaderModule));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyShaderModule = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyShaderModule = OP_vkDestroyShaderModule;
    stream->write(&opcode_vkDestroyShaderModule, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyShaderModule, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkShaderModule*)&shaderModule, sizeof(VkShaderModule));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreatePipelineCache(
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkPipelineCacheCreateInfo(countingStream, (const VkPipelineCacheCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
    }
    uint32_t packetSize_vkCreatePipelineCache = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreatePipelineCache = OP_vkCreatePipelineCache;
    stream->write(&opcode_vkCreatePipelineCache, sizeof(uint32_t));
    stream->write(&packetSize_vkCreatePipelineCache, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkPipelineCacheCreateInfo(stream, (const VkPipelineCacheCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
    stream->read((VkPipelineCache*)pPipelineCache, sizeof(VkPipelineCache));
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    return vkCreatePipelineCache_VkResult_return;
}

void VkEncoder::vkDestroyPipelineCache(
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipelineCache = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipelineCache = OP_vkDestroyPipelineCache;
    stream->write(&opcode_vkDestroyPipelineCache, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipelineCache, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkGetPipelineCacheData(
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
        countingStream->write((size_t**)&pDataSize, sizeof(size_t*));
        if (pDataSize)
        {
            countingStream->write((size_t*)pDataSize, sizeof(size_t));
        }
        countingStream->write((void**)&pData, sizeof(void*));
        if (pData)
        {
            countingStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetPipelineCacheData = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPipelineCacheData = OP_vkGetPipelineCacheData;
    stream->write(&opcode_vkGetPipelineCacheData, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPipelineCacheData, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    stream->write((size_t**)&pDataSize, sizeof(size_t*));
    if (pDataSize)
    {
        stream->write((size_t*)pDataSize, sizeof(size_t));
    }
    stream->write((void**)&pData, sizeof(void*));
    if (pData)
    {
        stream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    size_t* check_pDataSize;
    stream->read((size_t**)&check_pDataSize, sizeof(size_t*));
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        stream->read((size_t*)pDataSize, sizeof(size_t));
    }
    void* check_pData;
    stream->read((void**)&check_pData, sizeof(void*));
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    return vkGetPipelineCacheData_VkResult_return;
}

VkResult VkEncoder::vkMergePipelineCaches(
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipelineCache*)&dstCache, sizeof(VkPipelineCache));
        countingStream->write((uint32_t*)&srcCacheCount, sizeof(uint32_t));
        countingStream->write((const VkPipelineCache*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    }
    uint32_t packetSize_vkMergePipelineCaches = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMergePipelineCaches = OP_vkMergePipelineCaches;
    stream->write(&opcode_vkMergePipelineCaches, sizeof(uint32_t));
    stream->write(&packetSize_vkMergePipelineCaches, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipelineCache*)&dstCache, sizeof(VkPipelineCache));
    stream->write((uint32_t*)&srcCacheCount, sizeof(uint32_t));
    stream->write((const VkPipelineCache*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    stream->read(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    return vkMergePipelineCaches_VkResult_return;
}

VkResult VkEncoder::vkCreateGraphicsPipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
        countingStream->write((uint32_t*)&createInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            marshal_VkGraphicsPipelineCreateInfo(countingStream, (const VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
        }
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    }
    uint32_t packetSize_vkCreateGraphicsPipelines = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateGraphicsPipelines = OP_vkCreateGraphicsPipelines;
    stream->write(&opcode_vkCreateGraphicsPipelines, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateGraphicsPipelines, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    stream->write((uint32_t*)&createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkGraphicsPipelineCreateInfo(stream, (const VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
    }
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    stream->read((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    return vkCreateGraphicsPipelines_VkResult_return;
}

VkResult VkEncoder::vkCreateComputePipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
        countingStream->write((uint32_t*)&createInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            marshal_VkComputePipelineCreateInfo(countingStream, (const VkComputePipelineCreateInfo*)(pCreateInfos + i));
        }
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    }
    uint32_t packetSize_vkCreateComputePipelines = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateComputePipelines = OP_vkCreateComputePipelines;
    stream->write(&opcode_vkCreateComputePipelines, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateComputePipelines, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipelineCache*)&pipelineCache, sizeof(VkPipelineCache));
    stream->write((uint32_t*)&createInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        marshal_VkComputePipelineCreateInfo(stream, (const VkComputePipelineCreateInfo*)(pCreateInfos + i));
    }
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    stream->read((VkPipeline*)pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    return vkCreateComputePipelines_VkResult_return;
}

void VkEncoder::vkDestroyPipeline(
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipeline = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipeline = OP_vkDestroyPipeline;
    stream->write(&opcode_vkDestroyPipeline, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipeline, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreatePipelineLayout(
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkPipelineLayoutCreateInfo(countingStream, (const VkPipelineLayoutCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
    }
    uint32_t packetSize_vkCreatePipelineLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreatePipelineLayout = OP_vkCreatePipelineLayout;
    stream->write(&opcode_vkCreatePipelineLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkCreatePipelineLayout, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkPipelineLayoutCreateInfo(stream, (const VkPipelineLayoutCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
    stream->read((VkPipelineLayout*)pPipelineLayout, sizeof(VkPipelineLayout));
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    return vkCreatePipelineLayout_VkResult_return;
}

void VkEncoder::vkDestroyPipelineLayout(
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipelineLayout*)&pipelineLayout, sizeof(VkPipelineLayout));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyPipelineLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyPipelineLayout = OP_vkDestroyPipelineLayout;
    stream->write(&opcode_vkDestroyPipelineLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyPipelineLayout, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipelineLayout*)&pipelineLayout, sizeof(VkPipelineLayout));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSamplerCreateInfo(countingStream, (const VkSamplerCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSampler*)pSampler, sizeof(VkSampler));
    }
    uint32_t packetSize_vkCreateSampler = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSampler = OP_vkCreateSampler;
    stream->write(&opcode_vkCreateSampler, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSampler, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSamplerCreateInfo(stream, (const VkSamplerCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSampler*)pSampler, sizeof(VkSampler));
    stream->read((VkSampler*)pSampler, sizeof(VkSampler));
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSampler_VkResult_return, sizeof(VkResult));
    return vkCreateSampler_VkResult_return;
}

void VkEncoder::vkDestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSampler*)&sampler, sizeof(VkSampler));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySampler = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySampler = OP_vkDestroySampler;
    stream->write(&opcode_vkDestroySampler, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySampler, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSampler*)&sampler, sizeof(VkSampler));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateDescriptorSetLayout(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
    }
    uint32_t packetSize_vkCreateDescriptorSetLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorSetLayout = OP_vkCreateDescriptorSetLayout;
    stream->write(&opcode_vkCreateDescriptorSetLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorSetLayout, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
    stream->read((VkDescriptorSetLayout*)pSetLayout, sizeof(VkDescriptorSetLayout));
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    return vkCreateDescriptorSetLayout_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorSetLayout(
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorSetLayout*)&descriptorSetLayout, sizeof(VkDescriptorSetLayout));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorSetLayout = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorSetLayout = OP_vkDestroyDescriptorSetLayout;
    stream->write(&opcode_vkDestroyDescriptorSetLayout, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorSetLayout, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorSetLayout*)&descriptorSetLayout, sizeof(VkDescriptorSetLayout));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateDescriptorPool(
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorPoolCreateInfo(countingStream, (const VkDescriptorPoolCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
    }
    uint32_t packetSize_vkCreateDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorPool = OP_vkCreateDescriptorPool;
    stream->write(&opcode_vkCreateDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorPoolCreateInfo(stream, (const VkDescriptorPoolCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
    stream->read((VkDescriptorPool*)pDescriptorPool, sizeof(VkDescriptorPool));
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    return vkCreateDescriptorPool_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorPool = OP_vkDestroyDescriptorPool;
    stream->write(&opcode_vkDestroyDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkResetDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
        countingStream->write((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
    }
    uint32_t packetSize_vkResetDescriptorPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetDescriptorPool = OP_vkResetDescriptorPool;
    stream->write(&opcode_vkResetDescriptorPool, sizeof(uint32_t));
    stream->write(&packetSize_vkResetDescriptorPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    stream->write((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    return vkResetDescriptorPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateDescriptorSets(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorSetAllocateInfo(countingStream, (const VkDescriptorSetAllocateInfo*)(pAllocateInfo));
        countingStream->write((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    }
    uint32_t packetSize_vkAllocateDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateDescriptorSets = OP_vkAllocateDescriptorSets;
    stream->write(&opcode_vkAllocateDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateDescriptorSets, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetAllocateInfo(stream, (const VkDescriptorSetAllocateInfo*)(pAllocateInfo));
    stream->write((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    stream->read((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    return vkAllocateDescriptorSets_VkResult_return;
}

VkResult VkEncoder::vkFreeDescriptorSets(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
        countingStream->write((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
        countingStream->write((const VkDescriptorSet**)&pDescriptorSets, sizeof(const VkDescriptorSet*));
        if (pDescriptorSets)
        {
            countingStream->write((const VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
        }
    }
    uint32_t packetSize_vkFreeDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeDescriptorSets = OP_vkFreeDescriptorSets;
    stream->write(&opcode_vkFreeDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeDescriptorSets, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorPool*)&descriptorPool, sizeof(VkDescriptorPool));
    stream->write((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
    stream->write((const VkDescriptorSet**)&pDescriptorSets, sizeof(const VkDescriptorSet*));
    if (pDescriptorSets)
    {
        stream->write((const VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    }
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    return vkFreeDescriptorSets_VkResult_return;
}

void VkEncoder::vkUpdateDescriptorSets(
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            marshal_VkWriteDescriptorSet(countingStream, (const VkWriteDescriptorSet*)(pDescriptorWrites + i));
        }
        countingStream->write((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            marshal_VkCopyDescriptorSet(countingStream, (const VkCopyDescriptorSet*)(pDescriptorCopies + i));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSets = OP_vkUpdateDescriptorSets;
    stream->write(&opcode_vkUpdateDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSets, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(stream, (const VkWriteDescriptorSet*)(pDescriptorWrites + i));
    }
    stream->write((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        marshal_VkCopyDescriptorSet(stream, (const VkCopyDescriptorSet*)(pDescriptorCopies + i));
    }
}

VkResult VkEncoder::vkCreateFramebuffer(
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkFramebufferCreateInfo(countingStream, (const VkFramebufferCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
    }
    uint32_t packetSize_vkCreateFramebuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateFramebuffer = OP_vkCreateFramebuffer;
    stream->write(&opcode_vkCreateFramebuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateFramebuffer, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFramebufferCreateInfo(stream, (const VkFramebufferCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
    stream->read((VkFramebuffer*)pFramebuffer, sizeof(VkFramebuffer));
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    return vkCreateFramebuffer_VkResult_return;
}

void VkEncoder::vkDestroyFramebuffer(
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkFramebuffer*)&framebuffer, sizeof(VkFramebuffer));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyFramebuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyFramebuffer = OP_vkDestroyFramebuffer;
    stream->write(&opcode_vkDestroyFramebuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyFramebuffer, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkFramebuffer*)&framebuffer, sizeof(VkFramebuffer));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateRenderPass(
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkRenderPassCreateInfo(countingStream, (const VkRenderPassCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    }
    uint32_t packetSize_vkCreateRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateRenderPass = OP_vkCreateRenderPass;
    stream->write(&opcode_vkCreateRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateRenderPass, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkRenderPassCreateInfo(stream, (const VkRenderPassCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    stream->read((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    return vkCreateRenderPass_VkResult_return;
}

void VkEncoder::vkDestroyRenderPass(
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyRenderPass = OP_vkDestroyRenderPass;
    stream->write(&opcode_vkDestroyRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyRenderPass, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void VkEncoder::vkGetRenderAreaGranularity(
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
        marshal_VkExtent2D(countingStream, (VkExtent2D*)(pGranularity));
    }
    uint32_t packetSize_vkGetRenderAreaGranularity = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRenderAreaGranularity = OP_vkGetRenderAreaGranularity;
    stream->write(&opcode_vkGetRenderAreaGranularity, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRenderAreaGranularity, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkRenderPass*)&renderPass, sizeof(VkRenderPass));
    marshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
    unmarshal_VkExtent2D(stream, (VkExtent2D*)(pGranularity));
}

VkResult VkEncoder::vkCreateCommandPool(
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkCommandPoolCreateInfo(countingStream, (const VkCommandPoolCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
    }
    uint32_t packetSize_vkCreateCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateCommandPool = OP_vkCreateCommandPool;
    stream->write(&opcode_vkCreateCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateCommandPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkCommandPoolCreateInfo(stream, (const VkCommandPoolCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
    stream->read((VkCommandPool*)pCommandPool, sizeof(VkCommandPool));
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    return vkCreateCommandPool_VkResult_return;
}

void VkEncoder::vkDestroyCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyCommandPool = OP_vkDestroyCommandPool;
    stream->write(&opcode_vkDestroyCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyCommandPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkResetCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
        countingStream->write((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
    }
    uint32_t packetSize_vkResetCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandPool = OP_vkResetCommandPool;
    stream->write(&opcode_vkResetCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    stream->write((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
    return vkResetCommandPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateCommandBuffers(
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkCommandBufferAllocateInfo(countingStream, (const VkCommandBufferAllocateInfo*)(pAllocateInfo));
        countingStream->write((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
    }
    uint32_t packetSize_vkAllocateCommandBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAllocateCommandBuffers = OP_vkAllocateCommandBuffers;
    stream->write(&opcode_vkAllocateCommandBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkAllocateCommandBuffers, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkCommandBufferAllocateInfo(stream, (const VkCommandBufferAllocateInfo*)(pAllocateInfo));
    stream->write((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
    stream->read((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    return vkAllocateCommandBuffers_VkResult_return;
}

void VkEncoder::vkFreeCommandBuffers(
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
        countingStream->write((uint32_t*)&commandBufferCount, sizeof(uint32_t));
        countingStream->write((const VkCommandBuffer**)&pCommandBuffers, sizeof(const VkCommandBuffer*));
        if (pCommandBuffers)
        {
            countingStream->write((const VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
        }
    }
    uint32_t packetSize_vkFreeCommandBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkFreeCommandBuffers = OP_vkFreeCommandBuffers;
    stream->write(&opcode_vkFreeCommandBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkFreeCommandBuffers, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    stream->write((uint32_t*)&commandBufferCount, sizeof(uint32_t));
    stream->write((const VkCommandBuffer**)&pCommandBuffers, sizeof(const VkCommandBuffer*));
    if (pCommandBuffers)
    {
        stream->write((const VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
}

VkResult VkEncoder::vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkCommandBufferBeginInfo(countingStream, (const VkCommandBufferBeginInfo*)(pBeginInfo));
    }
    uint32_t packetSize_vkBeginCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBeginCommandBuffer = OP_vkBeginCommandBuffer;
    stream->write(&opcode_vkBeginCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkBeginCommandBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkCommandBufferBeginInfo(stream, (const VkCommandBufferBeginInfo*)(pBeginInfo));
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    return vkBeginCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkEndCommandBuffer(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    }
    uint32_t packetSize_vkEndCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEndCommandBuffer = OP_vkEndCommandBuffer;
    stream->write(&opcode_vkEndCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkEndCommandBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    return vkEndCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
    }
    uint32_t packetSize_vkResetCommandBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkResetCommandBuffer = OP_vkResetCommandBuffer;
    stream->write(&opcode_vkResetCommandBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkResetCommandBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    return vkResetCommandBuffer_VkResult_return;
}

void VkEncoder::vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
        countingStream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
    }
    uint32_t packetSize_vkCmdBindPipeline = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindPipeline = OP_vkCmdBindPipeline;
    stream->write(&opcode_vkCmdBindPipeline, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindPipeline, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    stream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
}

void VkEncoder::vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&firstViewport, sizeof(uint32_t));
        countingStream->write((uint32_t*)&viewportCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            marshal_VkViewport(countingStream, (const VkViewport*)(pViewports + i));
        }
    }
    uint32_t packetSize_vkCmdSetViewport = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetViewport = OP_vkCmdSetViewport;
    stream->write(&opcode_vkCmdSetViewport, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetViewport, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&firstViewport, sizeof(uint32_t));
    stream->write((uint32_t*)&viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewport(stream, (const VkViewport*)(pViewports + i));
    }
}

void VkEncoder::vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&firstScissor, sizeof(uint32_t));
        countingStream->write((uint32_t*)&scissorCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            marshal_VkRect2D(countingStream, (const VkRect2D*)(pScissors + i));
        }
    }
    uint32_t packetSize_vkCmdSetScissor = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetScissor = OP_vkCmdSetScissor;
    stream->write(&opcode_vkCmdSetScissor, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetScissor, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&firstScissor, sizeof(uint32_t));
    stream->write((uint32_t*)&scissorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        marshal_VkRect2D(stream, (const VkRect2D*)(pScissors + i));
    }
}

void VkEncoder::vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    float lineWidth)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((float*)&lineWidth, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetLineWidth = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetLineWidth = OP_vkCmdSetLineWidth;
    stream->write(&opcode_vkCmdSetLineWidth, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetLineWidth, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((float*)&lineWidth, sizeof(float));
}

void VkEncoder::vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((float*)&depthBiasConstantFactor, sizeof(float));
        countingStream->write((float*)&depthBiasClamp, sizeof(float));
        countingStream->write((float*)&depthBiasSlopeFactor, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetDepthBias = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDepthBias = OP_vkCmdSetDepthBias;
    stream->write(&opcode_vkCmdSetDepthBias, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDepthBias, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((float*)&depthBiasConstantFactor, sizeof(float));
    stream->write((float*)&depthBiasClamp, sizeof(float));
    stream->write((float*)&depthBiasSlopeFactor, sizeof(float));
}

void VkEncoder::vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    const float blendConstants)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((const float*)&blendConstants, 4 * sizeof(const float));
    }
    uint32_t packetSize_vkCmdSetBlendConstants = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetBlendConstants = OP_vkCmdSetBlendConstants;
    stream->write(&opcode_vkCmdSetBlendConstants, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetBlendConstants, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((const float*)&blendConstants, 4 * sizeof(const float));
}

void VkEncoder::vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((float*)&minDepthBounds, sizeof(float));
        countingStream->write((float*)&maxDepthBounds, sizeof(float));
    }
    uint32_t packetSize_vkCmdSetDepthBounds = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDepthBounds = OP_vkCmdSetDepthBounds;
    stream->write(&opcode_vkCmdSetDepthBounds, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDepthBounds, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((float*)&minDepthBounds, sizeof(float));
    stream->write((float*)&maxDepthBounds, sizeof(float));
}

void VkEncoder::vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&compareMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilCompareMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilCompareMask = OP_vkCmdSetStencilCompareMask;
    stream->write(&opcode_vkCmdSetStencilCompareMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilCompareMask, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&compareMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&writeMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilWriteMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilWriteMask = OP_vkCmdSetStencilWriteMask;
    stream->write(&opcode_vkCmdSetStencilWriteMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilWriteMask, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&writeMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
        countingStream->write((uint32_t*)&reference, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetStencilReference = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetStencilReference = OP_vkCmdSetStencilReference;
    stream->write(&opcode_vkCmdSetStencilReference, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetStencilReference, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
    stream->write((uint32_t*)&reference, sizeof(uint32_t));
}

void VkEncoder::vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
        countingStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
        countingStream->write((uint32_t*)&firstSet, sizeof(uint32_t));
        countingStream->write((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
        countingStream->write((const VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
        countingStream->write((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
        countingStream->write((const uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
    }
    uint32_t packetSize_vkCmdBindDescriptorSets = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindDescriptorSets = OP_vkCmdBindDescriptorSets;
    stream->write(&opcode_vkCmdBindDescriptorSets, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindDescriptorSets, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    stream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    stream->write((uint32_t*)&firstSet, sizeof(uint32_t));
    stream->write((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
    stream->write((const VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
    stream->write((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
    stream->write((const uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
}

void VkEncoder::vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((VkIndexType*)&indexType, sizeof(VkIndexType));
    }
    uint32_t packetSize_vkCmdBindIndexBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindIndexBuffer = OP_vkCmdBindIndexBuffer;
    stream->write(&opcode_vkCmdBindIndexBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindIndexBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((VkIndexType*)&indexType, sizeof(VkIndexType));
}

void VkEncoder::vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&firstBinding, sizeof(uint32_t));
        countingStream->write((uint32_t*)&bindingCount, sizeof(uint32_t));
        countingStream->write((const VkBuffer*)pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
        countingStream->write((const VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
    }
    uint32_t packetSize_vkCmdBindVertexBuffers = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBindVertexBuffers = OP_vkCmdBindVertexBuffers;
    stream->write(&opcode_vkCmdBindVertexBuffers, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBindVertexBuffers, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&firstBinding, sizeof(uint32_t));
    stream->write((uint32_t*)&bindingCount, sizeof(uint32_t));
    stream->write((const VkBuffer*)pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
    stream->write((const VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
}

void VkEncoder::vkCmdDraw(
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&vertexCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&instanceCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&firstVertex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&firstInstance, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDraw = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDraw = OP_vkCmdDraw;
    stream->write(&opcode_vkCmdDraw, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDraw, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&vertexCount, sizeof(uint32_t));
    stream->write((uint32_t*)&instanceCount, sizeof(uint32_t));
    stream->write((uint32_t*)&firstVertex, sizeof(uint32_t));
    stream->write((uint32_t*)&firstInstance, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&indexCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&instanceCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&firstIndex, sizeof(uint32_t));
        countingStream->write((int32_t*)&vertexOffset, sizeof(int32_t));
        countingStream->write((uint32_t*)&firstInstance, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexed = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexed = OP_vkCmdDrawIndexed;
    stream->write(&opcode_vkCmdDrawIndexed, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexed, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&indexCount, sizeof(uint32_t));
    stream->write((uint32_t*)&instanceCount, sizeof(uint32_t));
    stream->write((uint32_t*)&firstIndex, sizeof(uint32_t));
    stream->write((int32_t*)&vertexOffset, sizeof(int32_t));
    stream->write((uint32_t*)&firstInstance, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&drawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirect = OP_vkCmdDrawIndirect;
    stream->write(&opcode_vkCmdDrawIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirect, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&drawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&drawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirect = OP_vkCmdDrawIndexedIndirect;
    stream->write(&opcode_vkCmdDrawIndexedIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirect, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&drawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatch = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatch = OP_vkCmdDispatch;
    stream->write(&opcode_vkCmdDispatch, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatch, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    }
    uint32_t packetSize_vkCmdDispatchIndirect = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchIndirect = OP_vkCmdDispatchIndirect;
    stream->write(&opcode_vkCmdDispatchIndirect, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchIndirect, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
}

void VkEncoder::vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
        countingStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
        countingStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferCopy(countingStream, (const VkBufferCopy*)(pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyBuffer = OP_vkCmdCopyBuffer;
    stream->write(&opcode_vkCmdCopyBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
    stream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    stream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferCopy(stream, (const VkBufferCopy*)(pRegions + i));
    }
}

void VkEncoder::vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkImage*)&srcImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
        countingStream->write((VkImage*)&dstImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageCopy(countingStream, (const VkImageCopy*)(pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyImage = OP_vkCmdCopyImage;
    stream->write(&opcode_vkCmdCopyImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyImage, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkImage*)&srcImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    stream->write((VkImage*)&dstImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageCopy(stream, (const VkImageCopy*)(pRegions + i));
    }
}

void VkEncoder::vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkImage*)&srcImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
        countingStream->write((VkImage*)&dstImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageBlit(countingStream, (const VkImageBlit*)(pRegions + i));
        }
        countingStream->write((VkFilter*)&filter, sizeof(VkFilter));
    }
    uint32_t packetSize_vkCmdBlitImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBlitImage = OP_vkCmdBlitImage;
    stream->write(&opcode_vkCmdBlitImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBlitImage, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkImage*)&srcImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    stream->write((VkImage*)&dstImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageBlit(stream, (const VkImageBlit*)(pRegions + i));
    }
    stream->write((VkFilter*)&filter, sizeof(VkFilter));
}

void VkEncoder::vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
        countingStream->write((VkImage*)&dstImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferImageCopy(countingStream, (const VkBufferImageCopy*)(pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyBufferToImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyBufferToImage = OP_vkCmdCopyBufferToImage;
    stream->write(&opcode_vkCmdCopyBufferToImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyBufferToImage, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&srcBuffer, sizeof(VkBuffer));
    stream->write((VkImage*)&dstImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(stream, (const VkBufferImageCopy*)(pRegions + i));
    }
}

void VkEncoder::vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkImage*)&srcImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
        countingStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
        countingStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkBufferImageCopy(countingStream, (const VkBufferImageCopy*)(pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdCopyImageToBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyImageToBuffer = OP_vkCmdCopyImageToBuffer;
    stream->write(&opcode_vkCmdCopyImageToBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyImageToBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkImage*)&srcImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    stream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    stream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkBufferImageCopy(stream, (const VkBufferImageCopy*)(pRegions + i));
    }
}

void VkEncoder::vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
        countingStream->write((const void*)pData, ((dataSize)) * sizeof(const uint8_t));
    }
    uint32_t packetSize_vkCmdUpdateBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdUpdateBuffer = OP_vkCmdUpdateBuffer;
    stream->write(&opcode_vkCmdUpdateBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdUpdateBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
    stream->write((const void*)pData, ((dataSize)) * sizeof(const uint8_t));
}

void VkEncoder::vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&size, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&data, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdFillBuffer = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdFillBuffer = OP_vkCmdFillBuffer;
    stream->write(&opcode_vkCmdFillBuffer, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdFillBuffer, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&size, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&data, sizeof(uint32_t));
}

void VkEncoder::vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
        marshal_VkClearColorValue(countingStream, (const VkClearColorValue*)(pColor));
        countingStream->write((uint32_t*)&rangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            marshal_VkImageSubresourceRange(countingStream, (const VkImageSubresourceRange*)(pRanges + i));
        }
    }
    uint32_t packetSize_vkCmdClearColorImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearColorImage = OP_vkCmdClearColorImage;
    stream->write(&opcode_vkCmdClearColorImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearColorImage, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkImage*)&image, sizeof(VkImage));
    stream->write((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
    marshal_VkClearColorValue(stream, (const VkClearColorValue*)(pColor));
    stream->write((uint32_t*)&rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(stream, (const VkImageSubresourceRange*)(pRanges + i));
    }
}

void VkEncoder::vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkImage*)&image, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
        marshal_VkClearDepthStencilValue(countingStream, (const VkClearDepthStencilValue*)(pDepthStencil));
        countingStream->write((uint32_t*)&rangeCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            marshal_VkImageSubresourceRange(countingStream, (const VkImageSubresourceRange*)(pRanges + i));
        }
    }
    uint32_t packetSize_vkCmdClearDepthStencilImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearDepthStencilImage = OP_vkCmdClearDepthStencilImage;
    stream->write(&opcode_vkCmdClearDepthStencilImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearDepthStencilImage, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkImage*)&image, sizeof(VkImage));
    stream->write((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
    marshal_VkClearDepthStencilValue(stream, (const VkClearDepthStencilValue*)(pDepthStencil));
    stream->write((uint32_t*)&rangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        marshal_VkImageSubresourceRange(stream, (const VkImageSubresourceRange*)(pRanges + i));
    }
}

void VkEncoder::vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&attachmentCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            marshal_VkClearAttachment(countingStream, (const VkClearAttachment*)(pAttachments + i));
        }
        countingStream->write((uint32_t*)&rectCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            marshal_VkClearRect(countingStream, (const VkClearRect*)(pRects + i));
        }
    }
    uint32_t packetSize_vkCmdClearAttachments = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdClearAttachments = OP_vkCmdClearAttachments;
    stream->write(&opcode_vkCmdClearAttachments, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdClearAttachments, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        marshal_VkClearAttachment(stream, (const VkClearAttachment*)(pAttachments + i));
    }
    stream->write((uint32_t*)&rectCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        marshal_VkClearRect(stream, (const VkClearRect*)(pRects + i));
    }
}

void VkEncoder::vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkImage*)&srcImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
        countingStream->write((VkImage*)&dstImage, sizeof(VkImage));
        countingStream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
        countingStream->write((uint32_t*)&regionCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            marshal_VkImageResolve(countingStream, (const VkImageResolve*)(pRegions + i));
        }
    }
    uint32_t packetSize_vkCmdResolveImage = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResolveImage = OP_vkCmdResolveImage;
    stream->write(&opcode_vkCmdResolveImage, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResolveImage, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkImage*)&srcImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
    stream->write((VkImage*)&dstImage, sizeof(VkImage));
    stream->write((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
    stream->write((uint32_t*)&regionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        marshal_VkImageResolve(stream, (const VkImageResolve*)(pRegions + i));
    }
}

void VkEncoder::vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkEvent*)&event, sizeof(VkEvent));
        countingStream->write((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
    }
    uint32_t packetSize_vkCmdSetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetEvent = OP_vkCmdSetEvent;
    stream->write(&opcode_vkCmdSetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetEvent, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkEvent*)&event, sizeof(VkEvent));
    stream->write((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
}

void VkEncoder::vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkEvent*)&event, sizeof(VkEvent));
        countingStream->write((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
    }
    uint32_t packetSize_vkCmdResetEvent = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResetEvent = OP_vkCmdResetEvent;
    stream->write(&opcode_vkCmdResetEvent, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResetEvent, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkEvent*)&event, sizeof(VkEvent));
    stream->write((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
}

void VkEncoder::vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&eventCount, sizeof(uint32_t));
        countingStream->write((const VkEvent*)pEvents, ((eventCount)) * sizeof(const VkEvent));
        countingStream->write((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            marshal_VkMemoryBarrier(countingStream, (const VkMemoryBarrier*)(pMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            marshal_VkBufferMemoryBarrier(countingStream, (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            marshal_VkImageMemoryBarrier(countingStream, (const VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
        }
    }
    uint32_t packetSize_vkCmdWaitEvents = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWaitEvents = OP_vkCmdWaitEvents;
    stream->write(&opcode_vkCmdWaitEvents, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWaitEvents, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&eventCount, sizeof(uint32_t));
    stream->write((const VkEvent*)pEvents, ((eventCount)) * sizeof(const VkEvent));
    stream->write((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
    stream->write((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(stream, (const VkMemoryBarrier*)(pMemoryBarriers + i));
    }
    stream->write((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(stream, (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
    }
    stream->write((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(stream, (const VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
    }
}

void VkEncoder::vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
        countingStream->write((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
        countingStream->write((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            marshal_VkMemoryBarrier(countingStream, (const VkMemoryBarrier*)(pMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            marshal_VkBufferMemoryBarrier(countingStream, (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
        }
        countingStream->write((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            marshal_VkImageMemoryBarrier(countingStream, (const VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
        }
    }
    uint32_t packetSize_vkCmdPipelineBarrier = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPipelineBarrier = OP_vkCmdPipelineBarrier;
    stream->write(&opcode_vkCmdPipelineBarrier, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPipelineBarrier, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
    stream->write((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
    stream->write((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        marshal_VkMemoryBarrier(stream, (const VkMemoryBarrier*)(pMemoryBarriers + i));
    }
    stream->write((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        marshal_VkBufferMemoryBarrier(stream, (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
    }
    stream->write((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        marshal_VkImageMemoryBarrier(stream, (const VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
    }
}

void VkEncoder::vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((uint32_t*)&query, sizeof(uint32_t));
        countingStream->write((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
    }
    uint32_t packetSize_vkCmdBeginQuery = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginQuery = OP_vkCmdBeginQuery;
    stream->write(&opcode_vkCmdBeginQuery, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginQuery, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((uint32_t*)&query, sizeof(uint32_t));
    stream->write((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
}

void VkEncoder::vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((uint32_t*)&query, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdEndQuery = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndQuery = OP_vkCmdEndQuery;
    stream->write(&opcode_vkCmdEndQuery, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndQuery, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((uint32_t*)&query, sizeof(uint32_t));
}

void VkEncoder::vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&queryCount, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdResetQueryPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdResetQueryPool = OP_vkCmdResetQueryPool;
    stream->write(&opcode_vkCmdResetQueryPool, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdResetQueryPool, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&queryCount, sizeof(uint32_t));
}

void VkEncoder::vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((uint32_t*)&query, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdWriteTimestamp = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWriteTimestamp = OP_vkCmdWriteTimestamp;
    stream->write(&opcode_vkCmdWriteTimestamp, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWriteTimestamp, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((uint32_t*)&query, sizeof(uint32_t));
}

void VkEncoder::vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
        countingStream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
        countingStream->write((uint32_t*)&queryCount, sizeof(uint32_t));
        countingStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
        countingStream->write((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
        countingStream->write((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
    }
    uint32_t packetSize_vkCmdCopyQueryPoolResults = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdCopyQueryPoolResults = OP_vkCmdCopyQueryPoolResults;
    stream->write(&opcode_vkCmdCopyQueryPoolResults, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdCopyQueryPoolResults, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkQueryPool*)&queryPool, sizeof(VkQueryPool));
    stream->write((uint32_t*)&firstQuery, sizeof(uint32_t));
    stream->write((uint32_t*)&queryCount, sizeof(uint32_t));
    stream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    stream->write((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
    stream->write((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
}

void VkEncoder::vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
        countingStream->write((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
        countingStream->write((uint32_t*)&offset, sizeof(uint32_t));
        countingStream->write((uint32_t*)&size, sizeof(uint32_t));
        countingStream->write((const void*)pValues, ((size)) * sizeof(const uint8_t));
    }
    uint32_t packetSize_vkCmdPushConstants = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushConstants = OP_vkCmdPushConstants;
    stream->write(&opcode_vkCmdPushConstants, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushConstants, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    stream->write((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
    stream->write((uint32_t*)&offset, sizeof(uint32_t));
    stream->write((uint32_t*)&size, sizeof(uint32_t));
    stream->write((const void*)pValues, ((size)) * sizeof(const uint8_t));
}

void VkEncoder::vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkRenderPassBeginInfo(countingStream, (const VkRenderPassBeginInfo*)(pRenderPassBegin));
        countingStream->write((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
    }
    uint32_t packetSize_vkCmdBeginRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginRenderPass = OP_vkCmdBeginRenderPass;
    stream->write(&opcode_vkCmdBeginRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginRenderPass, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkRenderPassBeginInfo(stream, (const VkRenderPassBeginInfo*)(pRenderPassBegin));
    stream->write((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
}

void VkEncoder::vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
    }
    uint32_t packetSize_vkCmdNextSubpass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdNextSubpass = OP_vkCmdNextSubpass;
    stream->write(&opcode_vkCmdNextSubpass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdNextSubpass, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
}

void VkEncoder::vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    }
    uint32_t packetSize_vkCmdEndRenderPass = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndRenderPass = OP_vkCmdEndRenderPass;
    stream->write(&opcode_vkCmdEndRenderPass, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndRenderPass, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void VkEncoder::vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&commandBufferCount, sizeof(uint32_t));
        countingStream->write((const VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
    }
    uint32_t packetSize_vkCmdExecuteCommands = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdExecuteCommands = OP_vkCmdExecuteCommands;
    stream->write(&opcode_vkCmdExecuteCommands, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdExecuteCommands, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&commandBufferCount, sizeof(uint32_t));
    stream->write((const VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
}

#endif
#ifdef VK_VERSION_1_1
VkResult VkEncoder::vkEnumerateInstanceVersion(
    uint32_t* pApiVersion)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
    }
    uint32_t packetSize_vkEnumerateInstanceVersion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumerateInstanceVersion = OP_vkEnumerateInstanceVersion;
    stream->write(&opcode_vkEnumerateInstanceVersion, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumerateInstanceVersion, sizeof(uint32_t));
    stream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
    stream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
    return vkEnumerateInstanceVersion_VkResult_return;
}

VkResult VkEncoder::vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindBufferMemoryInfo(countingStream, (const VkBindBufferMemoryInfo*)(pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindBufferMemory2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory2 = OP_vkBindBufferMemory2;
    stream->write(&opcode_vkBindBufferMemory2, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory2, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(stream, (const VkBindBufferMemoryInfo*)(pBindInfos + i));
    }
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    return vkBindBufferMemory2_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindImageMemoryInfo(countingStream, (const VkBindImageMemoryInfo*)(pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindImageMemory2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory2 = OP_vkBindImageMemory2;
    stream->write(&opcode_vkBindImageMemory2, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory2, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(stream, (const VkBindImageMemoryInfo*)(pBindInfos + i));
    }
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    return vkBindImageMemory2_VkResult_return;
}

void VkEncoder::vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&heapIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
        countingStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeatures = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeatures = OP_vkGetDeviceGroupPeerMemoryFeatures;
    stream->write(&opcode_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&heapIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
    stream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void VkEncoder::vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&deviceMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetDeviceMask = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDeviceMask = OP_vkCmdSetDeviceMask;
    stream->write(&opcode_vkCmdSetDeviceMask, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDeviceMask, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&deviceMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&baseGroupX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&baseGroupY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&baseGroupZ, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatchBase = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchBase = OP_vkCmdDispatchBase;
    stream->write(&opcode_vkCmdDispatchBase, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchBase, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&baseGroupX, sizeof(uint32_t));
    stream->write((uint32_t*)&baseGroupY, sizeof(uint32_t));
    stream->write((uint32_t*)&baseGroupZ, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

VkResult VkEncoder::vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
        if (pPhysicalDeviceGroupCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        }
        countingStream->write((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                marshal_VkPhysicalDeviceGroupProperties(countingStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroups = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDeviceGroups = OP_vkEnumeratePhysicalDeviceGroups;
    stream->write(&opcode_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
    if (pPhysicalDeviceGroupCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    stream->write((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            marshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    uint32_t* check_pPhysicalDeviceGroupCount;
    stream->read((uint32_t**)&check_pPhysicalDeviceGroupCount, sizeof(uint32_t*));
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    stream->read((VkPhysicalDeviceGroupProperties**)&check_pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

void VkEncoder::vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImageMemoryRequirementsInfo2(countingStream, (const VkImageMemoryRequirementsInfo2*)(pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements2 = OP_vkGetImageMemoryRequirements2;
    stream->write(&opcode_vkGetImageMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements2, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageMemoryRequirementsInfo2(stream, (const VkImageMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void VkEncoder::vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkBufferMemoryRequirementsInfo2(countingStream, (const VkBufferMemoryRequirementsInfo2*)(pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements2 = OP_vkGetBufferMemoryRequirements2;
    stream->write(&opcode_vkGetBufferMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements2, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferMemoryRequirementsInfo2(stream, (const VkBufferMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void VkEncoder::vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImageSparseMemoryRequirementsInfo2(countingStream, (const VkImageSparseMemoryRequirementsInfo2*)(pInfo));
        countingStream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        countingStream->write((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements2(countingStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements2 = OP_vkGetImageSparseMemoryRequirements2;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageSparseMemoryRequirementsInfo2(stream, (const VkImageSparseMemoryRequirementsInfo2*)(pInfo));
    stream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    stream->write((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    uint32_t* check_pSparseMemoryRequirementCount;
    stream->read((uint32_t**)&check_pSparseMemoryRequirementCount, sizeof(uint32_t*));
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    stream->read((VkSparseImageMemoryRequirements2**)&check_pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceFeatures2(countingStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures2 = OP_vkGetPhysicalDeviceFeatures2;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
}

void VkEncoder::vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceProperties2(countingStream, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties2 = OP_vkGetPhysicalDeviceProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkFormat*)&format, sizeof(VkFormat));
        marshal_VkFormatProperties2(countingStream, (VkFormatProperties2*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2 = OP_vkGetPhysicalDeviceFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkFormat*)&format, sizeof(VkFormat));
    marshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceImageFormatInfo2(countingStream, (const VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
        marshal_VkImageFormatProperties2(countingStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2 = OP_vkGetPhysicalDeviceImageFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceImageFormatInfo2(stream, (const VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
    marshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties2(countingStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2 = OP_vkGetPhysicalDeviceQueueFamilyProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    uint32_t* check_pQueueFamilyPropertyCount;
    stream->read((uint32_t**)&check_pQueueFamilyPropertyCount, sizeof(uint32_t*));
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    stream->read((VkQueueFamilyProperties2**)&check_pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceMemoryProperties2(countingStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2 = OP_vkGetPhysicalDeviceMemoryProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceSparseImageFormatInfo2(countingStream, (const VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties2(countingStream, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2 = OP_vkGetPhysicalDeviceSparseImageFormatProperties2;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (const VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkSparseImageFormatProperties2* check_pProperties;
    stream->read((VkSparseImageFormatProperties2**)&check_pProperties, sizeof(VkSparseImageFormatProperties2*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
}

void VkEncoder::vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
        countingStream->write((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
    }
    uint32_t packetSize_vkTrimCommandPool = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkTrimCommandPool = OP_vkTrimCommandPool;
    stream->write(&opcode_vkTrimCommandPool, sizeof(uint32_t));
    stream->write(&packetSize_vkTrimCommandPool, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    stream->write((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
}

void VkEncoder::vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDeviceQueueInfo2(countingStream, (const VkDeviceQueueInfo2*)(pQueueInfo));
        countingStream->write((VkQueue*)pQueue, sizeof(VkQueue));
    }
    uint32_t packetSize_vkGetDeviceQueue2 = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceQueue2 = OP_vkGetDeviceQueue2;
    stream->write(&opcode_vkGetDeviceQueue2, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceQueue2, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDeviceQueueInfo2(stream, (const VkDeviceQueueInfo2*)(pQueueInfo));
    stream->write((VkQueue*)pQueue, sizeof(VkQueue));
    stream->read((VkQueue*)pQueue, sizeof(VkQueue));
}

VkResult VkEncoder::vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSamplerYcbcrConversionCreateInfo(countingStream, (const VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSamplerYcbcrConversion = OP_vkCreateSamplerYcbcrConversion;
    stream->write(&opcode_vkCreateSamplerYcbcrConversion, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSamplerYcbcrConversion, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSamplerYcbcrConversionCreateInfo(stream, (const VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    stream->read((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversion = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySamplerYcbcrConversion = OP_vkDestroySamplerYcbcrConversion;
    stream->write(&opcode_vkDestroySamplerYcbcrConversion, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySamplerYcbcrConversion, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorUpdateTemplateCreateInfo(countingStream, (const VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorUpdateTemplate = OP_vkCreateDescriptorUpdateTemplate;
    stream->write(&opcode_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorUpdateTemplateCreateInfo(stream, (const VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->read((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorUpdateTemplate = OP_vkDestroyDescriptorUpdateTemplate;
    stream->write(&opcode_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void VkEncoder::vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
        countingStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
        countingStream->write((const void**)&pData, sizeof(const void*));
        if (pData)
        {
            countingStream->write((const void*)pData, sizeof(const uint8_t));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplate = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplate = OP_vkUpdateDescriptorSetWithTemplate;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
    stream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->write((const void**)&pData, sizeof(const void*));
    if (pData)
    {
        stream->write((const void*)pData, sizeof(const uint8_t));
    }
}

void VkEncoder::vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceExternalBufferInfo(countingStream, (const VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
        marshal_VkExternalBufferProperties(countingStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferProperties = OP_vkGetPhysicalDeviceExternalBufferProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalBufferInfo(stream, (const VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
    marshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
}

void VkEncoder::vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceExternalFenceInfo(countingStream, (const VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
        marshal_VkExternalFenceProperties(countingStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFenceProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalFenceProperties = OP_vkGetPhysicalDeviceExternalFenceProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalFenceInfo(stream, (const VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
    marshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
}

void VkEncoder::vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceExternalSemaphoreInfo(countingStream, (const VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
        marshal_VkExternalSemaphoreProperties(countingStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphoreProperties = OP_vkGetPhysicalDeviceExternalSemaphoreProperties;
    stream->write(&opcode_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (const VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
}

void VkEncoder::vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
        marshal_VkDescriptorSetLayoutSupport(countingStream, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupport = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDescriptorSetLayoutSupport = OP_vkGetDescriptorSetLayoutSupport;
    stream->write(&opcode_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
}

#endif
#ifdef VK_KHR_surface
void VkEncoder::vkDestroySurfaceKHR(
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySurfaceKHR = OP_vkDestroySurfaceKHR;
    stream->write(&opcode_vkDestroySurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        countingStream->write((VkBool32*)pSupported, sizeof(VkBool32));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceSupportKHR = OP_vkGetPhysicalDeviceSurfaceSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    stream->write((VkBool32*)pSupported, sizeof(VkBool32));
    stream->read((VkBool32*)pSupported, sizeof(VkBool32));
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        marshal_VkSurfaceCapabilitiesKHR(countingStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    marshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    unmarshal_VkSurfaceCapabilitiesKHR(stream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        countingStream->write((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
        if (pSurfaceFormatCount)
        {
            countingStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        }
        countingStream->write((VkSurfaceFormatKHR**)&pSurfaceFormats, sizeof(VkSurfaceFormatKHR*));
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                marshal_VkSurfaceFormatKHR(countingStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormatsKHR = OP_vkGetPhysicalDeviceSurfaceFormatsKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    stream->write((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
    if (pSurfaceFormatCount)
    {
        stream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    stream->write((VkSurfaceFormatKHR**)&pSurfaceFormats, sizeof(VkSurfaceFormatKHR*));
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            marshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    uint32_t* check_pSurfaceFormatCount;
    stream->read((uint32_t**)&check_pSurfaceFormatCount, sizeof(uint32_t*));
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    VkSurfaceFormatKHR* check_pSurfaceFormats;
    stream->read((VkSurfaceFormatKHR**)&check_pSurfaceFormats, sizeof(VkSurfaceFormatKHR*));
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormatKHR(stream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        countingStream->write((uint32_t**)&pPresentModeCount, sizeof(uint32_t*));
        if (pPresentModeCount)
        {
            countingStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
        }
        countingStream->write((VkPresentModeKHR**)&pPresentModes, sizeof(VkPresentModeKHR*));
        if (pPresentModes)
        {
            countingStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfacePresentModesKHR = OP_vkGetPhysicalDeviceSurfacePresentModesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    stream->write((uint32_t**)&pPresentModeCount, sizeof(uint32_t*));
    if (pPresentModeCount)
    {
        stream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    stream->write((VkPresentModeKHR**)&pPresentModes, sizeof(VkPresentModeKHR*));
    if (pPresentModes)
    {
        stream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    uint32_t* check_pPresentModeCount;
    stream->read((uint32_t**)&check_pPresentModeCount, sizeof(uint32_t*));
    if (pPresentModeCount)
    {
        if (!(check_pPresentModeCount))
        {
            fprintf(stderr, "fatal: pPresentModeCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    VkPresentModeKHR* check_pPresentModes;
    stream->read((VkPresentModeKHR**)&check_pPresentModes, sizeof(VkPresentModeKHR*));
    if (pPresentModes)
    {
        if (!(check_pPresentModes))
        {
            fprintf(stderr, "fatal: pPresentModes inconsistent between guest and host\n");
        }
        stream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_swapchain
VkResult VkEncoder::vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSwapchainCreateInfoKHR(countingStream, (const VkSwapchainCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
    }
    uint32_t packetSize_vkCreateSwapchainKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSwapchainKHR = OP_vkCreateSwapchainKHR;
    stream->write(&opcode_vkCreateSwapchainKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSwapchainKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSwapchainCreateInfoKHR(stream, (const VkSwapchainCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
    stream->read((VkSwapchainKHR*)pSwapchain, sizeof(VkSwapchainKHR));
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    return vkCreateSwapchainKHR_VkResult_return;
}

void VkEncoder::vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySwapchainKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySwapchainKHR = OP_vkDestroySwapchainKHR;
    stream->write(&opcode_vkDestroySwapchainKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySwapchainKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
        countingStream->write((uint32_t**)&pSwapchainImageCount, sizeof(uint32_t*));
        if (pSwapchainImageCount)
        {
            countingStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
        }
        countingStream->write((VkImage**)&pSwapchainImages, sizeof(VkImage*));
        if (pSwapchainImages)
        {
            countingStream->write((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
        }
    }
    uint32_t packetSize_vkGetSwapchainImagesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainImagesKHR = OP_vkGetSwapchainImagesKHR;
    stream->write(&opcode_vkGetSwapchainImagesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainImagesKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    stream->write((uint32_t**)&pSwapchainImageCount, sizeof(uint32_t*));
    if (pSwapchainImageCount)
    {
        stream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    stream->write((VkImage**)&pSwapchainImages, sizeof(VkImage*));
    if (pSwapchainImages)
    {
        stream->write((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
    }
    uint32_t* check_pSwapchainImageCount;
    stream->read((uint32_t**)&check_pSwapchainImageCount, sizeof(uint32_t*));
    if (pSwapchainImageCount)
    {
        if (!(check_pSwapchainImageCount))
        {
            fprintf(stderr, "fatal: pSwapchainImageCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    VkImage* check_pSwapchainImages;
    stream->read((VkImage**)&check_pSwapchainImages, sizeof(VkImage*));
    if (pSwapchainImages)
    {
        if (!(check_pSwapchainImages))
        {
            fprintf(stderr, "fatal: pSwapchainImages inconsistent between guest and host\n");
        }
        stream->read((VkImage*)pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
    }
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    return vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
        countingStream->write((uint64_t*)&timeout, sizeof(uint64_t));
        countingStream->write((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
        countingStream->write((VkFence*)&fence, sizeof(VkFence));
        countingStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkAcquireNextImageKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireNextImageKHR = OP_vkAcquireNextImageKHR;
    stream->write(&opcode_vkAcquireNextImageKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireNextImageKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    stream->write((uint64_t*)&timeout, sizeof(uint64_t));
    stream->write((VkSemaphore*)&semaphore, sizeof(VkSemaphore));
    stream->write((VkFence*)&fence, sizeof(VkFence));
    stream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    return vkAcquireNextImageKHR_VkResult_return;
}

VkResult VkEncoder::vkQueuePresentKHR(
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
        marshal_VkPresentInfoKHR(countingStream, (const VkPresentInfoKHR*)(pPresentInfo));
    }
    uint32_t packetSize_vkQueuePresentKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueuePresentKHR = OP_vkQueuePresentKHR;
    stream->write(&opcode_vkQueuePresentKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkQueuePresentKHR, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    marshal_VkPresentInfoKHR(stream, (const VkPresentInfoKHR*)(pPresentInfo));
    VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
    stream->read(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    return vkQueuePresentKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDeviceGroupPresentCapabilitiesKHR(countingStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    uint32_t packetSize_vkGetDeviceGroupPresentCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPresentCapabilitiesKHR = OP_vkGetDeviceGroupPresentCapabilitiesKHR;
    stream->write(&opcode_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    unmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        countingStream->write((VkDeviceGroupPresentModeFlagsKHR**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR*));
        if (pModes)
        {
            countingStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
        }
    }
    uint32_t packetSize_vkGetDeviceGroupSurfacePresentModesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupSurfacePresentModesKHR = OP_vkGetDeviceGroupSurfacePresentModesKHR;
    stream->write(&opcode_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    stream->write((VkDeviceGroupPresentModeFlagsKHR**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR*));
    if (pModes)
    {
        stream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    VkDeviceGroupPresentModeFlagsKHR* check_pModes;
    stream->read((VkDeviceGroupPresentModeFlagsKHR**)&check_pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR*));
    if (pModes)
    {
        if (!(check_pModes))
        {
            fprintf(stderr, "fatal: pModes inconsistent between guest and host\n");
        }
        stream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        countingStream->write((uint32_t**)&pRectCount, sizeof(uint32_t*));
        if (pRectCount)
        {
            countingStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
        }
        countingStream->write((VkRect2D**)&pRects, sizeof(VkRect2D*));
        if (pRects)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
            {
                marshal_VkRect2D(countingStream, (VkRect2D*)(pRects + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDevicePresentRectanglesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDevicePresentRectanglesKHR = OP_vkGetPhysicalDevicePresentRectanglesKHR;
    stream->write(&opcode_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    stream->write((uint32_t**)&pRectCount, sizeof(uint32_t*));
    if (pRectCount)
    {
        stream->write((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    stream->write((VkRect2D**)&pRects, sizeof(VkRect2D*));
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            marshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    uint32_t* check_pRectCount;
    stream->read((uint32_t**)&check_pRectCount, sizeof(uint32_t*));
    if (pRectCount)
    {
        if (!(check_pRectCount))
        {
            fprintf(stderr, "fatal: pRectCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    VkRect2D* check_pRects;
    stream->read((VkRect2D**)&check_pRects, sizeof(VkRect2D*));
    if (pRects)
    {
        if (!(check_pRects))
        {
            fprintf(stderr, "fatal: pRects inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            unmarshal_VkRect2D(stream, (VkRect2D*)(pRects + i));
        }
    }
    VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkAcquireNextImageInfoKHR(countingStream, (const VkAcquireNextImageInfoKHR*)(pAcquireInfo));
        countingStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkAcquireNextImage2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireNextImage2KHR = OP_vkAcquireNextImage2KHR;
    stream->write(&opcode_vkAcquireNextImage2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireNextImage2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkAcquireNextImageInfoKHR(stream, (const VkAcquireNextImageInfoKHR*)(pAcquireInfo));
    stream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    return vkAcquireNextImage2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display
VkResult VkEncoder::vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayPropertiesKHR**)&pProperties, sizeof(VkDisplayPropertiesKHR*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPropertiesKHR(countingStream, (VkDisplayPropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPropertiesKHR = OP_vkGetPhysicalDeviceDisplayPropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayPropertiesKHR**)&pProperties, sizeof(VkDisplayPropertiesKHR*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkDisplayPropertiesKHR* check_pProperties;
    stream->read((VkDisplayPropertiesKHR**)&check_pProperties, sizeof(VkDisplayPropertiesKHR*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPropertiesKHR(stream, (VkDisplayPropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayPlanePropertiesKHR**)&pProperties, sizeof(VkDisplayPlanePropertiesKHR*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPlanePropertiesKHR(countingStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayPlanePropertiesKHR**)&pProperties, sizeof(VkDisplayPlanePropertiesKHR*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkDisplayPlanePropertiesKHR* check_pProperties;
    stream->read((VkDisplayPlanePropertiesKHR**)&check_pProperties, sizeof(VkDisplayPlanePropertiesKHR*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlanePropertiesKHR(stream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&planeIndex, sizeof(uint32_t));
        countingStream->write((uint32_t**)&pDisplayCount, sizeof(uint32_t*));
        if (pDisplayCount)
        {
            countingStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayKHR**)&pDisplays, sizeof(VkDisplayKHR*));
        if (pDisplays)
        {
            countingStream->write((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
        }
    }
    uint32_t packetSize_vkGetDisplayPlaneSupportedDisplaysKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneSupportedDisplaysKHR = OP_vkGetDisplayPlaneSupportedDisplaysKHR;
    stream->write(&opcode_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&planeIndex, sizeof(uint32_t));
    stream->write((uint32_t**)&pDisplayCount, sizeof(uint32_t*));
    if (pDisplayCount)
    {
        stream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayKHR**)&pDisplays, sizeof(VkDisplayKHR*));
    if (pDisplays)
    {
        stream->write((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
    }
    uint32_t* check_pDisplayCount;
    stream->read((uint32_t**)&check_pDisplayCount, sizeof(uint32_t*));
    if (pDisplayCount)
    {
        if (!(check_pDisplayCount))
        {
            fprintf(stderr, "fatal: pDisplayCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    VkDisplayKHR* check_pDisplays;
    stream->read((VkDisplayKHR**)&check_pDisplays, sizeof(VkDisplayKHR*));
    if (pDisplays)
    {
        if (!(check_pDisplays))
        {
            fprintf(stderr, "fatal: pDisplays inconsistent between guest and host\n");
        }
        stream->read((VkDisplayKHR*)pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
    }
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    return vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayModePropertiesKHR**)&pProperties, sizeof(VkDisplayModePropertiesKHR*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayModePropertiesKHR(countingStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayModePropertiesKHR = OP_vkGetDisplayModePropertiesKHR;
    stream->write(&opcode_vkGetDisplayModePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayModePropertiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayModePropertiesKHR**)&pProperties, sizeof(VkDisplayModePropertiesKHR*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkDisplayModePropertiesKHR* check_pProperties;
    stream->read((VkDisplayModePropertiesKHR**)&check_pProperties, sizeof(VkDisplayModePropertiesKHR*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModePropertiesKHR(stream, (VkDisplayModePropertiesKHR*)(pProperties + i));
        }
    }
    VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
        marshal_VkDisplayModeCreateInfoKHR(countingStream, (const VkDisplayModeCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
    }
    uint32_t packetSize_vkCreateDisplayModeKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDisplayModeKHR = OP_vkCreateDisplayModeKHR;
    stream->write(&opcode_vkCreateDisplayModeKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDisplayModeKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    marshal_VkDisplayModeCreateInfoKHR(stream, (const VkDisplayModeCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
    stream->read((VkDisplayModeKHR*)pMode, sizeof(VkDisplayModeKHR));
    VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    return vkCreateDisplayModeKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkDisplayModeKHR*)&mode, sizeof(VkDisplayModeKHR));
        countingStream->write((uint32_t*)&planeIndex, sizeof(uint32_t));
        marshal_VkDisplayPlaneCapabilitiesKHR(countingStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilitiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneCapabilitiesKHR = OP_vkGetDisplayPlaneCapabilitiesKHR;
    stream->write(&opcode_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkDisplayModeKHR*)&mode, sizeof(VkDisplayModeKHR));
    stream->write((uint32_t*)&planeIndex, sizeof(uint32_t));
    marshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    unmarshal_VkDisplayPlaneCapabilitiesKHR(stream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkDisplaySurfaceCreateInfoKHR(countingStream, (const VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateDisplayPlaneSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDisplayPlaneSurfaceKHR = OP_vkCreateDisplayPlaneSurfaceKHR;
    stream->write(&opcode_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkDisplaySurfaceCreateInfoKHR(stream, (const VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display_swapchain
VkResult VkEncoder::vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&swapchainCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            marshal_VkSwapchainCreateInfoKHR(countingStream, (const VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
        }
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
    }
    uint32_t packetSize_vkCreateSharedSwapchainsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSharedSwapchainsKHR = OP_vkCreateSharedSwapchainsKHR;
    stream->write(&opcode_vkCreateSharedSwapchainsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSharedSwapchainsKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&swapchainCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkSwapchainCreateInfoKHR(stream, (const VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
    }
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
    stream->read((VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_xlib_surface
VkResult VkEncoder::vkCreateXlibSurfaceKHR(
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkXlibSurfaceCreateInfoKHR(countingStream, (const VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateXlibSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateXlibSurfaceKHR = OP_vkCreateXlibSurfaceKHR;
    stream->write(&opcode_vkCreateXlibSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateXlibSurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkXlibSurfaceCreateInfoKHR(stream, (const VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateXlibSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((VisualID*)&visualID, sizeof(VisualID));
    }
    uint32_t packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR = OP_vkGetPhysicalDeviceXlibPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((VisualID*)&visualID, sizeof(VisualID));
    stream->read((Display*)dpy, sizeof(Display));
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_xcb_surface
VkResult VkEncoder::vkCreateXcbSurfaceKHR(
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkXcbSurfaceCreateInfoKHR(countingStream, (const VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateXcbSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateXcbSurfaceKHR = OP_vkCreateXcbSurfaceKHR;
    stream->write(&opcode_vkCreateXcbSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateXcbSurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkXcbSurfaceCreateInfoKHR(stream, (const VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateXcbSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
        countingStream->write((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
    }
    uint32_t packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR = OP_vkGetPhysicalDeviceXcbPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    stream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    stream->write((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
    stream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_wayland_surface
VkResult VkEncoder::vkCreateWaylandSurfaceKHR(
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkWaylandSurfaceCreateInfoKHR(countingStream, (const VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateWaylandSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateWaylandSurfaceKHR = OP_vkCreateWaylandSurfaceKHR;
    stream->write(&opcode_vkCreateWaylandSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateWaylandSurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkWaylandSurfaceCreateInfoKHR(stream, (const VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((wl_display*)display, sizeof(wl_display));
    }
    uint32_t packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR = OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    stream->write((wl_display*)display, sizeof(wl_display));
    stream->read((wl_display*)display, sizeof(wl_display));
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_mir_surface
VkResult VkEncoder::vkCreateMirSurfaceKHR(
    VkInstance instance,
    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkMirSurfaceCreateInfoKHR(countingStream, (const VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateMirSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateMirSurfaceKHR = OP_vkCreateMirSurfaceKHR;
    stream->write(&opcode_vkCreateMirSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateMirSurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkMirSurfaceCreateInfoKHR(stream, (const VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateMirSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    MirConnection* connection)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
        countingStream->write((MirConnection*)connection, sizeof(MirConnection));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMirPresentationSupportKHR = OP_vkGetPhysicalDeviceMirPresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMirPresentationSupportKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    stream->write((MirConnection*)connection, sizeof(MirConnection));
    stream->read((MirConnection*)connection, sizeof(MirConnection));
    VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_android_surface
VkResult VkEncoder::vkCreateAndroidSurfaceKHR(
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkAndroidSurfaceCreateInfoKHR(countingStream, (const VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateAndroidSurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateAndroidSurfaceKHR = OP_vkCreateAndroidSurfaceKHR;
    stream->write(&opcode_vkCreateAndroidSurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateAndroidSurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkAndroidSurfaceCreateInfoKHR(stream, (const VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_surface
VkResult VkEncoder::vkCreateWin32SurfaceKHR(
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkWin32SurfaceCreateInfoKHR(countingStream, (const VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateWin32SurfaceKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateWin32SurfaceKHR = OP_vkCreateWin32SurfaceKHR;
    stream->write(&opcode_vkCreateWin32SurfaceKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateWin32SurfaceKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkWin32SurfaceCreateInfoKHR(stream, (const VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    return vkCreateWin32SurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    }
    uint32_t packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR = OP_vkGetPhysicalDeviceWin32PresentationSupportKHR;
    stream->write(&opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    return vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkEncoder::vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceFeatures2(countingStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFeatures2KHR = OP_vkGetPhysicalDeviceFeatures2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
    unmarshal_VkPhysicalDeviceFeatures2(stream, (VkPhysicalDeviceFeatures2*)(pFeatures));
}

void VkEncoder::vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceProperties2(countingStream, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceProperties2KHR = OP_vkGetPhysicalDeviceProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
    unmarshal_VkPhysicalDeviceProperties2(stream, (VkPhysicalDeviceProperties2*)(pProperties));
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkFormat*)&format, sizeof(VkFormat));
        marshal_VkFormatProperties2(countingStream, (VkFormatProperties2*)(pFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2KHR = OP_vkGetPhysicalDeviceFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkFormat*)&format, sizeof(VkFormat));
    marshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
    unmarshal_VkFormatProperties2(stream, (VkFormatProperties2*)(pFormatProperties));
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceImageFormatInfo2(countingStream, (const VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
        marshal_VkImageFormatProperties2(countingStream, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2KHR = OP_vkGetPhysicalDeviceImageFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceImageFormatInfo2(stream, (const VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
    marshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    unmarshal_VkImageFormatProperties2(stream, (VkImageFormatProperties2*)(pImageFormatProperties));
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
        if (pQueueFamilyPropertyCount)
        {
            countingStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                marshal_VkQueueFamilyProperties2(countingStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR = OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pQueueFamilyPropertyCount, sizeof(uint32_t*));
    if (pQueueFamilyPropertyCount)
    {
        stream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkQueueFamilyProperties2**)&pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            marshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
    uint32_t* check_pQueueFamilyPropertyCount;
    stream->read((uint32_t**)&check_pQueueFamilyPropertyCount, sizeof(uint32_t*));
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    stream->read((VkQueueFamilyProperties2**)&check_pQueueFamilyProperties, sizeof(VkQueueFamilyProperties2*));
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            unmarshal_VkQueueFamilyProperties2(stream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
        }
    }
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceMemoryProperties2(countingStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2KHR = OP_vkGetPhysicalDeviceMemoryProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceSparseImageFormatInfo2(countingStream, (const VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkSparseImageFormatProperties2(countingStream, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, (const VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkSparseImageFormatProperties2**)&pProperties, sizeof(VkSparseImageFormatProperties2*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkSparseImageFormatProperties2* check_pProperties;
    stream->read((VkSparseImageFormatProperties2**)&check_pProperties, sizeof(VkSparseImageFormatProperties2*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkSparseImageFormatProperties2(stream, (VkSparseImageFormatProperties2*)(pProperties + i));
        }
    }
}

#endif
#ifdef VK_KHR_device_group
void VkEncoder::vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&heapIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
        countingStream->write((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
        countingStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR = OP_vkGetDeviceGroupPeerMemoryFeaturesKHR;
    stream->write(&opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&heapIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
    stream->write((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
    stream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
}

void VkEncoder::vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&deviceMask, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdSetDeviceMaskKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDeviceMaskKHR = OP_vkCmdSetDeviceMaskKHR;
    stream->write(&opcode_vkCmdSetDeviceMaskKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDeviceMaskKHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&deviceMask, sizeof(uint32_t));
}

void VkEncoder::vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&baseGroupX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&baseGroupY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&baseGroupZ, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
        countingStream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDispatchBaseKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDispatchBaseKHR = OP_vkCmdDispatchBaseKHR;
    stream->write(&opcode_vkCmdDispatchBaseKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDispatchBaseKHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&baseGroupX, sizeof(uint32_t));
    stream->write((uint32_t*)&baseGroupY, sizeof(uint32_t));
    stream->write((uint32_t*)&baseGroupZ, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountX, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountY, sizeof(uint32_t));
    stream->write((uint32_t*)&groupCountZ, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
void VkEncoder::vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
        countingStream->write((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
    }
    uint32_t packetSize_vkTrimCommandPoolKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkTrimCommandPoolKHR = OP_vkTrimCommandPoolKHR;
    stream->write(&opcode_vkTrimCommandPoolKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkTrimCommandPoolKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkCommandPool*)&commandPool, sizeof(VkCommandPool));
    stream->write((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
}

#endif
#ifdef VK_KHR_device_group_creation
VkResult VkEncoder::vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
        if (pPhysicalDeviceGroupCount)
        {
            countingStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        }
        countingStream->write((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                marshal_VkPhysicalDeviceGroupProperties(countingStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroupsKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkEnumeratePhysicalDeviceGroupsKHR = OP_vkEnumeratePhysicalDeviceGroupsKHR;
    stream->write(&opcode_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((uint32_t**)&pPhysicalDeviceGroupCount, sizeof(uint32_t*));
    if (pPhysicalDeviceGroupCount)
    {
        stream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    stream->write((VkPhysicalDeviceGroupProperties**)&pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            marshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    uint32_t* check_pPhysicalDeviceGroupCount;
    stream->read((uint32_t**)&check_pPhysicalDeviceGroupCount, sizeof(uint32_t*));
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    stream->read((VkPhysicalDeviceGroupProperties**)&check_pPhysicalDeviceGroupProperties, sizeof(VkPhysicalDeviceGroupProperties*));
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            unmarshal_VkPhysicalDeviceGroupProperties(stream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    return vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceExternalBufferInfo(countingStream, (const VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
        marshal_VkExternalBufferProperties(countingStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR = OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalBufferInfo(stream, (const VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
    marshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
    unmarshal_VkExternalBufferProperties(stream, (VkExternalBufferProperties*)(pExternalBufferProperties));
}

#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkMemoryGetWin32HandleInfoKHR(countingStream, (const VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetMemoryWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandleKHR = OP_vkGetMemoryWin32HandleKHR;
    stream->write(&opcode_vkGetMemoryWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandleKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryGetWin32HandleInfoKHR(stream, (const VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((HANDLE*)&handle, sizeof(HANDLE));
        marshal_VkMemoryWin32HandlePropertiesKHR(countingStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    uint32_t packetSize_vkGetMemoryWin32HandlePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandlePropertiesKHR = OP_vkGetMemoryWin32HandlePropertiesKHR;
    stream->write(&opcode_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((HANDLE*)&handle, sizeof(HANDLE));
    marshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    unmarshal_VkMemoryWin32HandlePropertiesKHR(stream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_fd
VkResult VkEncoder::vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkMemoryGetFdInfoKHR(countingStream, (const VkMemoryGetFdInfoKHR*)(pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetMemoryFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryFdKHR = OP_vkGetMemoryFdKHR;
    stream->write(&opcode_vkGetMemoryFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryFdKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryGetFdInfoKHR(stream, (const VkMemoryGetFdInfoKHR*)(pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    return vkGetMemoryFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((int*)&fd, sizeof(int));
        marshal_VkMemoryFdPropertiesKHR(countingStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    uint32_t packetSize_vkGetMemoryFdPropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryFdPropertiesKHR = OP_vkGetMemoryFdPropertiesKHR;
    stream->write(&opcode_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((int*)&fd, sizeof(int));
    marshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    unmarshal_VkMemoryFdPropertiesKHR(stream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceExternalSemaphoreInfo(countingStream, (const VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
        marshal_VkExternalSemaphoreProperties(countingStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, (const VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
    marshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    unmarshal_VkExternalSemaphoreProperties(stream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
}

#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
VkResult VkEncoder::vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImportSemaphoreWin32HandleInfoKHR(countingStream, (const VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
    }
    uint32_t packetSize_vkImportSemaphoreWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportSemaphoreWin32HandleKHR = OP_vkImportSemaphoreWin32HandleKHR;
    stream->write(&opcode_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportSemaphoreWin32HandleInfoKHR(stream, (const VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSemaphoreGetWin32HandleInfoKHR(countingStream, (const VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetSemaphoreWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSemaphoreWin32HandleKHR = OP_vkGetSemaphoreWin32HandleKHR;
    stream->write(&opcode_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSemaphoreGetWin32HandleInfoKHR(stream, (const VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
VkResult VkEncoder::vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImportSemaphoreFdInfoKHR(countingStream, (const VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
    }
    uint32_t packetSize_vkImportSemaphoreFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportSemaphoreFdKHR = OP_vkImportSemaphoreFdKHR;
    stream->write(&opcode_vkImportSemaphoreFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportSemaphoreFdKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportSemaphoreFdInfoKHR(stream, (const VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    return vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSemaphoreGetFdInfoKHR(countingStream, (const VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetSemaphoreFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSemaphoreFdKHR = OP_vkGetSemaphoreFdKHR;
    stream->write(&opcode_vkGetSemaphoreFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSemaphoreFdKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSemaphoreGetFdInfoKHR(stream, (const VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    return vkGetSemaphoreFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_push_descriptor
void VkEncoder::vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
        countingStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
        countingStream->write((uint32_t*)&set, sizeof(uint32_t));
        countingStream->write((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            marshal_VkWriteDescriptorSet(countingStream, (const VkWriteDescriptorSet*)(pDescriptorWrites + i));
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushDescriptorSetKHR = OP_vkCmdPushDescriptorSetKHR;
    stream->write(&opcode_vkCmdPushDescriptorSetKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushDescriptorSetKHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
    stream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    stream->write((uint32_t*)&set, sizeof(uint32_t));
    stream->write((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        marshal_VkWriteDescriptorSet(stream, (const VkWriteDescriptorSet*)(pDescriptorWrites + i));
    }
}

void VkEncoder::vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
        countingStream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
        countingStream->write((uint32_t*)&set, sizeof(uint32_t));
        countingStream->write((const void**)&pData, sizeof(const void*));
        if (pData)
        {
            countingStream->write((const void*)pData, sizeof(const uint8_t));
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetWithTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdPushDescriptorSetWithTemplateKHR = OP_vkCmdPushDescriptorSetWithTemplateKHR;
    stream->write(&opcode_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->write((VkPipelineLayout*)&layout, sizeof(VkPipelineLayout));
    stream->write((uint32_t*)&set, sizeof(uint32_t));
    stream->write((const void**)&pData, sizeof(const void*));
    if (pData)
    {
        stream->write((const void*)pData, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
VkResult VkEncoder::vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorUpdateTemplateCreateInfo(countingStream, (const VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDescriptorUpdateTemplateKHR = OP_vkCreateDescriptorUpdateTemplateKHR;
    stream->write(&opcode_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorUpdateTemplateCreateInfo(stream, (const VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->read((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDescriptorUpdateTemplateKHR = OP_vkDestroyDescriptorUpdateTemplateKHR;
    stream->write(&opcode_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void VkEncoder::vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
        countingStream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
        countingStream->write((const void**)&pData, sizeof(const void*));
        if (pData)
        {
            countingStream->write((const void*)pData, sizeof(const uint8_t));
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateKHR = OP_vkUpdateDescriptorSetWithTemplateKHR;
    stream->write(&opcode_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDescriptorSet*)&descriptorSet, sizeof(VkDescriptorSet));
    stream->write((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
    stream->write((const void**)&pData, sizeof(const void*));
    if (pData)
    {
        stream->write((const void*)pData, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_KHR_create_renderpass2
VkResult VkEncoder::vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2KHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkRenderPassCreateInfo2KHR(countingStream, (const VkRenderPassCreateInfo2KHR*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    }
    uint32_t packetSize_vkCreateRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateRenderPass2KHR = OP_vkCreateRenderPass2KHR;
    stream->write(&opcode_vkCreateRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateRenderPass2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkRenderPassCreateInfo2KHR(stream, (const VkRenderPassCreateInfo2KHR*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    stream->read((VkRenderPass*)pRenderPass, sizeof(VkRenderPass));
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    return vkCreateRenderPass2KHR_VkResult_return;
}

void VkEncoder::vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkRenderPassBeginInfo(countingStream, (const VkRenderPassBeginInfo*)(pRenderPassBegin));
        marshal_VkSubpassBeginInfoKHR(countingStream, (const VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
    }
    uint32_t packetSize_vkCmdBeginRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginRenderPass2KHR = OP_vkCmdBeginRenderPass2KHR;
    stream->write(&opcode_vkCmdBeginRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginRenderPass2KHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkRenderPassBeginInfo(stream, (const VkRenderPassBeginInfo*)(pRenderPassBegin));
    marshal_VkSubpassBeginInfoKHR(stream, (const VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
}

void VkEncoder::vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfoKHR* pSubpassBeginInfo,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkSubpassBeginInfoKHR(countingStream, (const VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
        marshal_VkSubpassEndInfoKHR(countingStream, (const VkSubpassEndInfoKHR*)(pSubpassEndInfo));
    }
    uint32_t packetSize_vkCmdNextSubpass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdNextSubpass2KHR = OP_vkCmdNextSubpass2KHR;
    stream->write(&opcode_vkCmdNextSubpass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdNextSubpass2KHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkSubpassBeginInfoKHR(stream, (const VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
    marshal_VkSubpassEndInfoKHR(stream, (const VkSubpassEndInfoKHR*)(pSubpassEndInfo));
}

void VkEncoder::vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfoKHR* pSubpassEndInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkSubpassEndInfoKHR(countingStream, (const VkSubpassEndInfoKHR*)(pSubpassEndInfo));
    }
    uint32_t packetSize_vkCmdEndRenderPass2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndRenderPass2KHR = OP_vkCmdEndRenderPass2KHR;
    stream->write(&opcode_vkCmdEndRenderPass2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndRenderPass2KHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkSubpassEndInfoKHR(stream, (const VkSubpassEndInfoKHR*)(pSubpassEndInfo));
}

#endif
#ifdef VK_KHR_shared_presentable_image
VkResult VkEncoder::vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    }
    uint32_t packetSize_vkGetSwapchainStatusKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainStatusKHR = OP_vkGetSwapchainStatusKHR;
    stream->write(&opcode_vkGetSwapchainStatusKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainStatusKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    return vkGetSwapchainStatusKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceExternalFenceInfo(countingStream, (const VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
        marshal_VkExternalFenceProperties(countingStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR = OP_vkGetPhysicalDeviceExternalFencePropertiesKHR;
    stream->write(&opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceExternalFenceInfo(stream, (const VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
    marshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
    unmarshal_VkExternalFenceProperties(stream, (VkExternalFenceProperties*)(pExternalFenceProperties));
}

#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
VkResult VkEncoder::vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImportFenceWin32HandleInfoKHR(countingStream, (const VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
    }
    uint32_t packetSize_vkImportFenceWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportFenceWin32HandleKHR = OP_vkImportFenceWin32HandleKHR;
    stream->write(&opcode_vkImportFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportFenceWin32HandleInfoKHR(stream, (const VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkFenceGetWin32HandleInfoKHR(countingStream, (const VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetFenceWin32HandleKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceWin32HandleKHR = OP_vkGetFenceWin32HandleKHR;
    stream->write(&opcode_vkGetFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceWin32HandleKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFenceGetWin32HandleInfoKHR(stream, (const VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    return vkGetFenceWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_fd
VkResult VkEncoder::vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImportFenceFdInfoKHR(countingStream, (const VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
    }
    uint32_t packetSize_vkImportFenceFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkImportFenceFdKHR = OP_vkImportFenceFdKHR;
    stream->write(&opcode_vkImportFenceFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkImportFenceFdKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImportFenceFdInfoKHR(stream, (const VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    return vkImportFenceFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkFenceGetFdInfoKHR(countingStream, (const VkFenceGetFdInfoKHR*)(pGetFdInfo));
        countingStream->write((int*)pFd, sizeof(int));
    }
    uint32_t packetSize_vkGetFenceFdKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetFenceFdKHR = OP_vkGetFenceFdKHR;
    stream->write(&opcode_vkGetFenceFdKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetFenceFdKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkFenceGetFdInfoKHR(stream, (const VkFenceGetFdInfoKHR*)(pGetFdInfo));
    stream->write((int*)pFd, sizeof(int));
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    return vkGetFenceFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceSurfaceInfo2KHR(countingStream, (const VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
        marshal_VkSurfaceCapabilities2KHR(countingStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR = OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (const VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
    marshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    unmarshal_VkSurfaceCapabilities2KHR(stream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkPhysicalDeviceSurfaceInfo2KHR(countingStream, (const VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
        countingStream->write((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
        if (pSurfaceFormatCount)
        {
            countingStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        }
        countingStream->write((VkSurfaceFormat2KHR**)&pSurfaceFormats, sizeof(VkSurfaceFormat2KHR*));
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                marshal_VkSurfaceFormat2KHR(countingStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormats2KHR = OP_vkGetPhysicalDeviceSurfaceFormats2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, (const VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
    stream->write((uint32_t**)&pSurfaceFormatCount, sizeof(uint32_t*));
    if (pSurfaceFormatCount)
    {
        stream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    stream->write((VkSurfaceFormat2KHR**)&pSurfaceFormats, sizeof(VkSurfaceFormat2KHR*));
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            marshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    uint32_t* check_pSurfaceFormatCount;
    stream->read((uint32_t**)&check_pSurfaceFormatCount, sizeof(uint32_t*));
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    VkSurfaceFormat2KHR* check_pSurfaceFormats;
    stream->read((VkSurfaceFormat2KHR**)&check_pSurfaceFormats, sizeof(VkSurfaceFormat2KHR*));
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            unmarshal_VkSurfaceFormat2KHR(stream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
VkResult VkEncoder::vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayProperties2KHR**)&pProperties, sizeof(VkDisplayProperties2KHR*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayProperties2KHR(countingStream, (VkDisplayProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayProperties2KHR = OP_vkGetPhysicalDeviceDisplayProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayProperties2KHR**)&pProperties, sizeof(VkDisplayProperties2KHR*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkDisplayProperties2KHR* check_pProperties;
    stream->read((VkDisplayProperties2KHR**)&check_pProperties, sizeof(VkDisplayProperties2KHR*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayProperties2KHR(stream, (VkDisplayProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayPlaneProperties2KHR**)&pProperties, sizeof(VkDisplayPlaneProperties2KHR*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayPlaneProperties2KHR(countingStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
    stream->write(&opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayPlaneProperties2KHR**)&pProperties, sizeof(VkDisplayPlaneProperties2KHR*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkDisplayPlaneProperties2KHR* check_pProperties;
    stream->read((VkDisplayPlaneProperties2KHR**)&check_pProperties, sizeof(VkDisplayPlaneProperties2KHR*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayPlaneProperties2KHR(stream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
        countingStream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
        if (pPropertyCount)
        {
            countingStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
        }
        countingStream->write((VkDisplayModeProperties2KHR**)&pProperties, sizeof(VkDisplayModeProperties2KHR*));
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                marshal_VkDisplayModeProperties2KHR(countingStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModeProperties2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayModeProperties2KHR = OP_vkGetDisplayModeProperties2KHR;
    stream->write(&opcode_vkGetDisplayModeProperties2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayModeProperties2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    stream->write((uint32_t**)&pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        stream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    stream->write((VkDisplayModeProperties2KHR**)&pProperties, sizeof(VkDisplayModeProperties2KHR*));
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            marshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    uint32_t* check_pPropertyCount;
    stream->read((uint32_t**)&check_pPropertyCount, sizeof(uint32_t*));
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    VkDisplayModeProperties2KHR* check_pProperties;
    stream->read((VkDisplayModeProperties2KHR**)&check_pProperties, sizeof(VkDisplayModeProperties2KHR*));
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            unmarshal_VkDisplayModeProperties2KHR(stream, (VkDisplayModeProperties2KHR*)(pProperties + i));
        }
    }
    VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    return vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkDisplayPlaneInfo2KHR(countingStream, (const VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
        marshal_VkDisplayPlaneCapabilities2KHR(countingStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilities2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDisplayPlaneCapabilities2KHR = OP_vkGetDisplayPlaneCapabilities2KHR;
    stream->write(&opcode_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkDisplayPlaneInfo2KHR(stream, (const VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
    marshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    unmarshal_VkDisplayPlaneCapabilities2KHR(stream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    return vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkEncoder::vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImageMemoryRequirementsInfo2(countingStream, (const VkImageMemoryRequirementsInfo2*)(pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageMemoryRequirements2KHR = OP_vkGetImageMemoryRequirements2KHR;
    stream->write(&opcode_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageMemoryRequirementsInfo2(stream, (const VkImageMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void VkEncoder::vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkBufferMemoryRequirementsInfo2(countingStream, (const VkBufferMemoryRequirementsInfo2*)(pInfo));
        marshal_VkMemoryRequirements2(countingStream, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetBufferMemoryRequirements2KHR = OP_vkGetBufferMemoryRequirements2KHR;
    stream->write(&opcode_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkBufferMemoryRequirementsInfo2(stream, (const VkBufferMemoryRequirementsInfo2*)(pInfo));
    marshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
    unmarshal_VkMemoryRequirements2(stream, (VkMemoryRequirements2*)(pMemoryRequirements));
}

void VkEncoder::vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkImageSparseMemoryRequirementsInfo2(countingStream, (const VkImageSparseMemoryRequirementsInfo2*)(pInfo));
        countingStream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
        if (pSparseMemoryRequirementCount)
        {
            countingStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        }
        countingStream->write((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                marshal_VkSparseImageMemoryRequirements2(countingStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetImageSparseMemoryRequirements2KHR = OP_vkGetImageSparseMemoryRequirements2KHR;
    stream->write(&opcode_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkImageSparseMemoryRequirementsInfo2(stream, (const VkImageSparseMemoryRequirementsInfo2*)(pInfo));
    stream->write((uint32_t**)&pSparseMemoryRequirementCount, sizeof(uint32_t*));
    if (pSparseMemoryRequirementCount)
    {
        stream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    stream->write((VkSparseImageMemoryRequirements2**)&pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            marshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
    uint32_t* check_pSparseMemoryRequirementCount;
    stream->read((uint32_t**)&check_pSparseMemoryRequirementCount, sizeof(uint32_t*));
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    stream->read((VkSparseImageMemoryRequirements2**)&check_pSparseMemoryRequirements, sizeof(VkSparseImageMemoryRequirements2*));
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            unmarshal_VkSparseImageMemoryRequirements2(stream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
        }
    }
}

#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult VkEncoder::vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkSamplerYcbcrConversionCreateInfo(countingStream, (const VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversionKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateSamplerYcbcrConversionKHR = OP_vkCreateSamplerYcbcrConversionKHR;
    stream->write(&opcode_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkSamplerYcbcrConversionCreateInfo(stream, (const VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    stream->read((VkSamplerYcbcrConversion*)pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversionKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroySamplerYcbcrConversionKHR = OP_vkDestroySamplerYcbcrConversionKHR;
    stream->write(&opcode_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSamplerYcbcrConversion*)&ycbcrConversion, sizeof(VkSamplerYcbcrConversion));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

#endif
#ifdef VK_KHR_bind_memory2
VkResult VkEncoder::vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindBufferMemoryInfo(countingStream, (const VkBindBufferMemoryInfo*)(pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindBufferMemory2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindBufferMemory2KHR = OP_vkBindBufferMemory2KHR;
    stream->write(&opcode_vkBindBufferMemory2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkBindBufferMemory2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindBufferMemoryInfo(stream, (const VkBindBufferMemoryInfo*)(pBindInfos + i));
    }
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    return vkBindBufferMemory2KHR_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            marshal_VkBindImageMemoryInfo(countingStream, (const VkBindImageMemoryInfo*)(pBindInfos + i));
        }
    }
    uint32_t packetSize_vkBindImageMemory2KHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkBindImageMemory2KHR = OP_vkBindImageMemory2KHR;
    stream->write(&opcode_vkBindImageMemory2KHR, sizeof(uint32_t));
    stream->write(&packetSize_vkBindImageMemory2KHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&bindInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        marshal_VkBindImageMemoryInfo(stream, (const VkBindImageMemoryInfo*)(pBindInfos + i));
    }
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    return vkBindImageMemory2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_maintenance3
void VkEncoder::vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDescriptorSetLayoutCreateInfo(countingStream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
        marshal_VkDescriptorSetLayoutSupport(countingStream, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupportKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetDescriptorSetLayoutSupportKHR = OP_vkGetDescriptorSetLayoutSupportKHR;
    stream->write(&opcode_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDescriptorSetLayoutCreateInfo(stream, (const VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
    marshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
    unmarshal_VkDescriptorSetLayoutSupport(stream, (VkDescriptorSetLayoutSupport*)(pSupport));
}

#endif
#ifdef VK_KHR_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirectCountKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirectCountKHR = OP_vkCmdDrawIndirectCountKHR;
    stream->write(&opcode_vkCmdDrawIndirectCountKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirectCountKHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountKHR = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirectCountKHR = OP_vkCmdDrawIndexedIndirectCountKHR;
    stream->write(&opcode_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&stride, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_EXT_debug_report
VkResult VkEncoder::vkCreateDebugReportCallbackEXT(
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkDebugReportCallbackCreateInfoEXT(countingStream, (const VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
    }
    uint32_t packetSize_vkCreateDebugReportCallbackEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDebugReportCallbackEXT = OP_vkCreateDebugReportCallbackEXT;
    stream->write(&opcode_vkCreateDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkDebugReportCallbackCreateInfoEXT(stream, (const VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
    stream->read((VkDebugReportCallbackEXT*)pCallback, sizeof(VkDebugReportCallbackEXT));
    VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    return vkCreateDebugReportCallbackEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((VkDebugReportCallbackEXT*)&callback, sizeof(VkDebugReportCallbackEXT));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDebugReportCallbackEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDebugReportCallbackEXT = OP_vkDestroyDebugReportCallbackEXT;
    stream->write(&opcode_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((VkDebugReportCallbackEXT*)&callback, sizeof(VkDebugReportCallbackEXT));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void VkEncoder::vkDebugReportMessageEXT(
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
        countingStream->write((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
        countingStream->write((uint64_t*)&object, sizeof(uint64_t));
        countingStream->write((size_t*)&location, sizeof(size_t));
        countingStream->write((int32_t*)&messageCode, sizeof(int32_t));
        countingStream->putString(pLayerPrefix);
        countingStream->putString(pMessage);
    }
    uint32_t packetSize_vkDebugReportMessageEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugReportMessageEXT = OP_vkDebugReportMessageEXT;
    stream->write(&opcode_vkDebugReportMessageEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugReportMessageEXT, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
    stream->write((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
    stream->write((uint64_t*)&object, sizeof(uint64_t));
    stream->write((size_t*)&location, sizeof(size_t));
    stream->write((int32_t*)&messageCode, sizeof(int32_t));
    stream->putString(pLayerPrefix);
    stream->putString(pMessage);
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
VkResult VkEncoder::vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDebugMarkerObjectTagInfoEXT(countingStream, (const VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
    }
    uint32_t packetSize_vkDebugMarkerSetObjectTagEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugMarkerSetObjectTagEXT = OP_vkDebugMarkerSetObjectTagEXT;
    stream->write(&opcode_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugMarkerObjectTagInfoEXT(stream, (const VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult VkEncoder::vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDebugMarkerObjectNameInfoEXT(countingStream, (const VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
    }
    uint32_t packetSize_vkDebugMarkerSetObjectNameEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDebugMarkerSetObjectNameEXT = OP_vkDebugMarkerSetObjectNameEXT;
    stream->write(&opcode_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugMarkerObjectNameInfoEXT(stream, (const VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

void VkEncoder::vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkDebugMarkerMarkerInfoEXT(countingStream, (const VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
    }
    uint32_t packetSize_vkCmdDebugMarkerBeginEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerBeginEXT = OP_vkCmdDebugMarkerBeginEXT;
    stream->write(&opcode_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugMarkerMarkerInfoEXT(stream, (const VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
}

void VkEncoder::vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    }
    uint32_t packetSize_vkCmdDebugMarkerEndEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerEndEXT = OP_vkCmdDebugMarkerEndEXT;
    stream->write(&opcode_vkCmdDebugMarkerEndEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerEndEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void VkEncoder::vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkDebugMarkerMarkerInfoEXT(countingStream, (const VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
    }
    uint32_t packetSize_vkCmdDebugMarkerInsertEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDebugMarkerInsertEXT = OP_vkCmdDebugMarkerInsertEXT;
    stream->write(&opcode_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugMarkerMarkerInfoEXT(stream, (const VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndirectCountAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndirectCountAMD = OP_vkCmdDrawIndirectCountAMD;
    stream->write(&opcode_vkCmdDrawIndirectCountAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndirectCountAMD, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&stride, sizeof(uint32_t));
}

void VkEncoder::vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
        countingStream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
        countingStream->write((uint32_t*)&stride, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdDrawIndexedIndirectCountAMD = OP_vkCmdDrawIndexedIndirectCountAMD;
    stream->write(&opcode_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkBuffer*)&buffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
    stream->write((VkBuffer*)&countBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&maxDrawCount, sizeof(uint32_t));
    stream->write((uint32_t*)&stride, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
VkResult VkEncoder::vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
        countingStream->write((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
        countingStream->write((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
        countingStream->write((size_t**)&pInfoSize, sizeof(size_t*));
        if (pInfoSize)
        {
            countingStream->write((size_t*)pInfoSize, sizeof(size_t));
        }
        countingStream->write((void**)&pInfo, sizeof(void*));
        if (pInfo)
        {
            countingStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetShaderInfoAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetShaderInfoAMD = OP_vkGetShaderInfoAMD;
    stream->write(&opcode_vkGetShaderInfoAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkGetShaderInfoAMD, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkPipeline*)&pipeline, sizeof(VkPipeline));
    stream->write((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
    stream->write((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
    stream->write((size_t**)&pInfoSize, sizeof(size_t*));
    if (pInfoSize)
    {
        stream->write((size_t*)pInfoSize, sizeof(size_t));
    }
    stream->write((void**)&pInfo, sizeof(void*));
    if (pInfo)
    {
        stream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    size_t* check_pInfoSize;
    stream->read((size_t**)&check_pInfoSize, sizeof(size_t*));
    if (pInfoSize)
    {
        if (!(check_pInfoSize))
        {
            fprintf(stderr, "fatal: pInfoSize inconsistent between guest and host\n");
        }
        stream->read((size_t*)pInfoSize, sizeof(size_t));
    }
    void* check_pInfo;
    stream->read((void**)&check_pInfo, sizeof(void*));
    if (pInfo)
    {
        if (!(check_pInfo))
        {
            fprintf(stderr, "fatal: pInfo inconsistent between guest and host\n");
        }
        stream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    stream->read(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    return vkGetShaderInfoAMD_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
VkResult VkEncoder::vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkFormat*)&format, sizeof(VkFormat));
        countingStream->write((VkImageType*)&type, sizeof(VkImageType));
        countingStream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
        countingStream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
        countingStream->write((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
        countingStream->write((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
        marshal_VkExternalImageFormatPropertiesNV(countingStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    stream->write(&opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkFormat*)&format, sizeof(VkFormat));
    stream->write((VkImageType*)&type, sizeof(VkImageType));
    stream->write((VkImageTiling*)&tiling, sizeof(VkImageTiling));
    stream->write((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
    stream->write((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
    stream->write((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    marshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    unmarshal_VkExternalImageFormatPropertiesNV(stream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
        countingStream->write((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
        countingStream->write((HANDLE*)pHandle, sizeof(HANDLE));
    }
    uint32_t packetSize_vkGetMemoryWin32HandleNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryWin32HandleNV = OP_vkGetMemoryWin32HandleNV;
    stream->write(&opcode_vkGetMemoryWin32HandleNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryWin32HandleNV, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDeviceMemory*)&memory, sizeof(VkDeviceMemory));
    stream->write((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    stream->write((HANDLE*)pHandle, sizeof(HANDLE));
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    return vkGetMemoryWin32HandleNV_VkResult_return;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
VkResult VkEncoder::vkCreateViSurfaceNN(
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkViSurfaceCreateInfoNN(countingStream, (const VkViSurfaceCreateInfoNN*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateViSurfaceNN = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateViSurfaceNN = OP_vkCreateViSurfaceNN;
    stream->write(&opcode_vkCreateViSurfaceNN, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateViSurfaceNN, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkViSurfaceCreateInfoNN(stream, (const VkViSurfaceCreateInfoNN*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
    stream->read(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    return vkCreateViSurfaceNN_VkResult_return;
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void VkEncoder::vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkConditionalRenderingBeginInfoEXT(countingStream, (const VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
    }
    uint32_t packetSize_vkCmdBeginConditionalRenderingEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginConditionalRenderingEXT = OP_vkCmdBeginConditionalRenderingEXT;
    stream->write(&opcode_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkConditionalRenderingBeginInfoEXT(stream, (const VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
}

void VkEncoder::vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    }
    uint32_t packetSize_vkCmdEndConditionalRenderingEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndConditionalRenderingEXT = OP_vkCmdEndConditionalRenderingEXT;
    stream->write(&opcode_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

#endif
#ifdef VK_NVX_device_generated_commands
void VkEncoder::vkCmdProcessCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkCmdProcessCommandsInfoNVX(countingStream, (const VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
    }
    uint32_t packetSize_vkCmdProcessCommandsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdProcessCommandsNVX = OP_vkCmdProcessCommandsNVX;
    stream->write(&opcode_vkCmdProcessCommandsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdProcessCommandsNVX, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkCmdProcessCommandsInfoNVX(stream, (const VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
}

void VkEncoder::vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkCmdReserveSpaceForCommandsInfoNVX(countingStream, (const VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
    }
    uint32_t packetSize_vkCmdReserveSpaceForCommandsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdReserveSpaceForCommandsNVX = OP_vkCmdReserveSpaceForCommandsNVX;
    stream->write(&opcode_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdReserveSpaceForCommandsNVX, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkCmdReserveSpaceForCommandsInfoNVX(stream, (const VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
}

VkResult VkEncoder::vkCreateIndirectCommandsLayoutNVX(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkIndirectCommandsLayoutCreateInfoNVX(countingStream, (const VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    }
    uint32_t packetSize_vkCreateIndirectCommandsLayoutNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateIndirectCommandsLayoutNVX = OP_vkCreateIndirectCommandsLayoutNVX;
    stream->write(&opcode_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkIndirectCommandsLayoutCreateInfoNVX(stream, (const VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    stream->read((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
    return vkCreateIndirectCommandsLayoutNVX_VkResult_return;
}

void VkEncoder::vkDestroyIndirectCommandsLayoutNVX(
    VkDevice device,
    VkIndirectCommandsLayoutNVX indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyIndirectCommandsLayoutNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyIndirectCommandsLayoutNVX = OP_vkDestroyIndirectCommandsLayoutNVX;
    stream->write(&opcode_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyIndirectCommandsLayoutNVX, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkCreateObjectTableNVX(
    VkDevice device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkObjectTableCreateInfoNVX(countingStream, (const VkObjectTableCreateInfoNVX*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
    }
    uint32_t packetSize_vkCreateObjectTableNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateObjectTableNVX = OP_vkCreateObjectTableNVX;
    stream->write(&opcode_vkCreateObjectTableNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateObjectTableNVX, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkObjectTableCreateInfoNVX(stream, (const VkObjectTableCreateInfoNVX*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
    stream->read((VkObjectTableNVX*)pObjectTable, sizeof(VkObjectTableNVX));
    VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
    stream->read(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
    return vkCreateObjectTableNVX_VkResult_return;
}

void VkEncoder::vkDestroyObjectTableNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyObjectTableNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyObjectTableNVX = OP_vkDestroyObjectTableNVX;
    stream->write(&opcode_vkDestroyObjectTableNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyObjectTableNVX, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkRegisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
        countingStream->write((uint32_t*)&objectCount, sizeof(uint32_t));
        countingStream->write((const uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    }
    uint32_t packetSize_vkRegisterObjectsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterObjectsNVX = OP_vkRegisterObjectsNVX;
    stream->write(&opcode_vkRegisterObjectsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterObjectsNVX, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    stream->write((uint32_t*)&objectCount, sizeof(uint32_t));
    stream->write((const uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
    return vkRegisterObjectsNVX_VkResult_return;
}

VkResult VkEncoder::vkUnregisterObjectsNVX(
    VkDevice device,
    VkObjectTableNVX objectTable,
    uint32_t objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
        countingStream->write((uint32_t*)&objectCount, sizeof(uint32_t));
        countingStream->write((const VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
        countingStream->write((const uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    }
    uint32_t packetSize_vkUnregisterObjectsNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkUnregisterObjectsNVX = OP_vkUnregisterObjectsNVX;
    stream->write(&opcode_vkUnregisterObjectsNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkUnregisterObjectsNVX, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkObjectTableNVX*)&objectTable, sizeof(VkObjectTableNVX));
    stream->write((uint32_t*)&objectCount, sizeof(uint32_t));
    stream->write((const VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
    stream->write((const uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
    VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
    stream->read(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
    return vkUnregisterObjectsNVX_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        marshal_VkDeviceGeneratedCommandsFeaturesNVX(countingStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
        marshal_VkDeviceGeneratedCommandsLimitsNVX(countingStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    }
    uint32_t packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX;
    stream->write(&opcode_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    marshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    marshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
    unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(stream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
    unmarshal_VkDeviceGeneratedCommandsLimitsNVX(stream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void VkEncoder::vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&firstViewport, sizeof(uint32_t));
        countingStream->write((uint32_t*)&viewportCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            marshal_VkViewportWScalingNV(countingStream, (const VkViewportWScalingNV*)(pViewportWScalings + i));
        }
    }
    uint32_t packetSize_vkCmdSetViewportWScalingNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetViewportWScalingNV = OP_vkCmdSetViewportWScalingNV;
    stream->write(&opcode_vkCmdSetViewportWScalingNV, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetViewportWScalingNV, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&firstViewport, sizeof(uint32_t));
    stream->write((uint32_t*)&viewportCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        marshal_VkViewportWScalingNV(stream, (const VkViewportWScalingNV*)(pViewportWScalings + i));
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
VkResult VkEncoder::vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    }
    uint32_t packetSize_vkReleaseDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkReleaseDisplayEXT = OP_vkReleaseDisplayEXT;
    stream->write(&opcode_vkReleaseDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkReleaseDisplayEXT, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    return vkReleaseDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_acquire_xlib_display
VkResult VkEncoder::vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    }
    uint32_t packetSize_vkAcquireXlibDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkAcquireXlibDisplayEXT = OP_vkAcquireXlibDisplayEXT;
    stream->write(&opcode_vkAcquireXlibDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkAcquireXlibDisplayEXT, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    stream->read((Display*)dpy, sizeof(Display));
    VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    return vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult VkEncoder::vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((Display*)dpy, sizeof(Display));
        countingStream->write((RROutput*)&rrOutput, sizeof(RROutput));
        countingStream->write((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
    }
    uint32_t packetSize_vkGetRandROutputDisplayEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRandROutputDisplayEXT = OP_vkGetRandROutputDisplayEXT;
    stream->write(&opcode_vkGetRandROutputDisplayEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRandROutputDisplayEXT, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((Display*)dpy, sizeof(Display));
    stream->write((RROutput*)&rrOutput, sizeof(RROutput));
    stream->write((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
    stream->read((Display*)dpy, sizeof(Display));
    stream->read((VkDisplayKHR*)pDisplay, sizeof(VkDisplayKHR));
    VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    return vkGetRandROutputDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_surface_counter
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
        marshal_VkSurfaceCapabilities2EXT(countingStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT = OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT;
    stream->write(&opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkSurfaceKHR*)&surface, sizeof(VkSurfaceKHR));
    marshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    unmarshal_VkSurfaceCapabilities2EXT(stream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    return vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_control
VkResult VkEncoder::vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
        marshal_VkDisplayPowerInfoEXT(countingStream, (const VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
    }
    uint32_t packetSize_vkDisplayPowerControlEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDisplayPowerControlEXT = OP_vkDisplayPowerControlEXT;
    stream->write(&opcode_vkDisplayPowerControlEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDisplayPowerControlEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    marshal_VkDisplayPowerInfoEXT(stream, (const VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    return vkDisplayPowerControlEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDeviceEventInfoEXT(countingStream, (const VkDeviceEventInfoEXT*)(pDeviceEventInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkFence*)pFence, sizeof(VkFence));
    }
    uint32_t packetSize_vkRegisterDeviceEventEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterDeviceEventEXT = OP_vkRegisterDeviceEventEXT;
    stream->write(&opcode_vkRegisterDeviceEventEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterDeviceEventEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDeviceEventInfoEXT(stream, (const VkDeviceEventInfoEXT*)(pDeviceEventInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkFence*)pFence, sizeof(VkFence));
    stream->read((VkFence*)pFence, sizeof(VkFence));
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    return vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
        marshal_VkDisplayEventInfoEXT(countingStream, (const VkDisplayEventInfoEXT*)(pDisplayEventInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkFence*)pFence, sizeof(VkFence));
    }
    uint32_t packetSize_vkRegisterDisplayEventEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkRegisterDisplayEventEXT = OP_vkRegisterDisplayEventEXT;
    stream->write(&opcode_vkRegisterDisplayEventEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkRegisterDisplayEventEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkDisplayKHR*)&display, sizeof(VkDisplayKHR));
    marshal_VkDisplayEventInfoEXT(stream, (const VkDisplayEventInfoEXT*)(pDisplayEventInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkFence*)pFence, sizeof(VkFence));
    stream->read((VkFence*)pFence, sizeof(VkFence));
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    return vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult VkEncoder::vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
        countingStream->write((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
        countingStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    }
    uint32_t packetSize_vkGetSwapchainCounterEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetSwapchainCounterEXT = OP_vkGetSwapchainCounterEXT;
    stream->write(&opcode_vkGetSwapchainCounterEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetSwapchainCounterEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    stream->write((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    stream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
    stream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    return vkGetSwapchainCounterEXT_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_display_timing
VkResult VkEncoder::vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
        marshal_VkRefreshCycleDurationGOOGLE(countingStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    uint32_t packetSize_vkGetRefreshCycleDurationGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetRefreshCycleDurationGOOGLE = OP_vkGetRefreshCycleDurationGOOGLE;
    stream->write(&opcode_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    marshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    unmarshal_VkRefreshCycleDurationGOOGLE(stream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
        countingStream->write((uint32_t**)&pPresentationTimingCount, sizeof(uint32_t*));
        if (pPresentationTimingCount)
        {
            countingStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
        }
        countingStream->write((VkPastPresentationTimingGOOGLE**)&pPresentationTimings, sizeof(VkPastPresentationTimingGOOGLE*));
        if (pPresentationTimings)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
            {
                marshal_VkPastPresentationTimingGOOGLE(countingStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
            }
        }
    }
    uint32_t packetSize_vkGetPastPresentationTimingGOOGLE = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPastPresentationTimingGOOGLE = OP_vkGetPastPresentationTimingGOOGLE;
    stream->write(&opcode_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkSwapchainKHR*)&swapchain, sizeof(VkSwapchainKHR));
    stream->write((uint32_t**)&pPresentationTimingCount, sizeof(uint32_t*));
    if (pPresentationTimingCount)
    {
        stream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    stream->write((VkPastPresentationTimingGOOGLE**)&pPresentationTimings, sizeof(VkPastPresentationTimingGOOGLE*));
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            marshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    uint32_t* check_pPresentationTimingCount;
    stream->read((uint32_t**)&check_pPresentationTimingCount, sizeof(uint32_t*));
    if (pPresentationTimingCount)
    {
        if (!(check_pPresentationTimingCount))
        {
            fprintf(stderr, "fatal: pPresentationTimingCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    VkPastPresentationTimingGOOGLE* check_pPresentationTimings;
    stream->read((VkPastPresentationTimingGOOGLE**)&check_pPresentationTimings, sizeof(VkPastPresentationTimingGOOGLE*));
    if (pPresentationTimings)
    {
        if (!(check_pPresentationTimings))
        {
            fprintf(stderr, "fatal: pPresentationTimings inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            unmarshal_VkPastPresentationTimingGOOGLE(stream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
        }
    }
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
void VkEncoder::vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
        countingStream->write((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            marshal_VkRect2D(countingStream, (const VkRect2D*)(pDiscardRectangles + i));
        }
    }
    uint32_t packetSize_vkCmdSetDiscardRectangleEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetDiscardRectangleEXT = OP_vkCmdSetDiscardRectangleEXT;
    stream->write(&opcode_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
    stream->write((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        marshal_VkRect2D(stream, (const VkRect2D*)(pDiscardRectangles + i));
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void VkEncoder::vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((uint32_t*)&swapchainCount, sizeof(uint32_t));
        countingStream->write((const VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            marshal_VkHdrMetadataEXT(countingStream, (const VkHdrMetadataEXT*)(pMetadata + i));
        }
    }
    uint32_t packetSize_vkSetHdrMetadataEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetHdrMetadataEXT = OP_vkSetHdrMetadataEXT;
    stream->write(&opcode_vkSetHdrMetadataEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetHdrMetadataEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((uint32_t*)&swapchainCount, sizeof(uint32_t));
    stream->write((const VkSwapchainKHR*)pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        marshal_VkHdrMetadataEXT(stream, (const VkHdrMetadataEXT*)(pMetadata + i));
    }
}

#endif
#ifdef VK_MVK_ios_surface
VkResult VkEncoder::vkCreateIOSSurfaceMVK(
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkIOSSurfaceCreateInfoMVK(countingStream, (const VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateIOSSurfaceMVK = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateIOSSurfaceMVK = OP_vkCreateIOSSurfaceMVK;
    stream->write(&opcode_vkCreateIOSSurfaceMVK, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateIOSSurfaceMVK, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkIOSSurfaceCreateInfoMVK(stream, (const VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    return vkCreateIOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_macos_surface
VkResult VkEncoder::vkCreateMacOSSurfaceMVK(
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkMacOSSurfaceCreateInfoMVK(countingStream, (const VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    }
    uint32_t packetSize_vkCreateMacOSSurfaceMVK = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateMacOSSurfaceMVK = OP_vkCreateMacOSSurfaceMVK;
    stream->write(&opcode_vkCreateMacOSSurfaceMVK, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateMacOSSurfaceMVK, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkMacOSSurfaceCreateInfoMVK(stream, (const VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    stream->read((VkSurfaceKHR*)pSurface, sizeof(VkSurfaceKHR));
    VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    return vkCreateMacOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
VkResult VkEncoder::vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDebugUtilsObjectNameInfoEXT(countingStream, (const VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
    }
    uint32_t packetSize_vkSetDebugUtilsObjectNameEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetDebugUtilsObjectNameEXT = OP_vkSetDebugUtilsObjectNameEXT;
    stream->write(&opcode_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugUtilsObjectNameInfoEXT(stream, (const VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult VkEncoder::vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkDebugUtilsObjectTagInfoEXT(countingStream, (const VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
    }
    uint32_t packetSize_vkSetDebugUtilsObjectTagEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSetDebugUtilsObjectTagEXT = OP_vkSetDebugUtilsObjectTagEXT;
    stream->write(&opcode_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkDebugUtilsObjectTagInfoEXT(stream, (const VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

void VkEncoder::vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
        marshal_VkDebugUtilsLabelEXT(countingStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
    }
    uint32_t packetSize_vkQueueBeginDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueBeginDebugUtilsLabelEXT = OP_vkQueueBeginDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    marshal_VkDebugUtilsLabelEXT(stream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void VkEncoder::vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
    }
    uint32_t packetSize_vkQueueEndDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueEndDebugUtilsLabelEXT = OP_vkQueueEndDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
}

void VkEncoder::vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
        marshal_VkDebugUtilsLabelEXT(countingStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
    }
    uint32_t packetSize_vkQueueInsertDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkQueueInsertDebugUtilsLabelEXT = OP_vkQueueInsertDebugUtilsLabelEXT;
    stream->write(&opcode_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    marshal_VkDebugUtilsLabelEXT(stream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void VkEncoder::vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkDebugUtilsLabelEXT(countingStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
    }
    uint32_t packetSize_vkCmdBeginDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdBeginDebugUtilsLabelEXT = OP_vkCmdBeginDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugUtilsLabelEXT(stream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

void VkEncoder::vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    }
    uint32_t packetSize_vkCmdEndDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdEndDebugUtilsLabelEXT = OP_vkCmdEndDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
}

void VkEncoder::vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkDebugUtilsLabelEXT(countingStream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
    }
    uint32_t packetSize_vkCmdInsertDebugUtilsLabelEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdInsertDebugUtilsLabelEXT = OP_vkCmdInsertDebugUtilsLabelEXT;
    stream->write(&opcode_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkDebugUtilsLabelEXT(stream, (const VkDebugUtilsLabelEXT*)(pLabelInfo));
}

VkResult VkEncoder::vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        marshal_VkDebugUtilsMessengerCreateInfoEXT(countingStream, (const VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
    }
    uint32_t packetSize_vkCreateDebugUtilsMessengerEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateDebugUtilsMessengerEXT = OP_vkCreateDebugUtilsMessengerEXT;
    stream->write(&opcode_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    marshal_VkDebugUtilsMessengerCreateInfoEXT(stream, (const VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
    stream->read((VkDebugUtilsMessengerEXT*)pMessenger, sizeof(VkDebugUtilsMessengerEXT));
    VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    return vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((VkDebugUtilsMessengerEXT*)&messenger, sizeof(VkDebugUtilsMessengerEXT));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyDebugUtilsMessengerEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyDebugUtilsMessengerEXT = OP_vkDestroyDebugUtilsMessengerEXT;
    stream->write(&opcode_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((VkDebugUtilsMessengerEXT*)&messenger, sizeof(VkDebugUtilsMessengerEXT));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

void VkEncoder::vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkInstance*)&instance, sizeof(VkInstance));
        countingStream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
        countingStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
        marshal_VkDebugUtilsMessengerCallbackDataEXT(countingStream, (const VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
    }
    uint32_t packetSize_vkSubmitDebugUtilsMessageEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkSubmitDebugUtilsMessageEXT = OP_vkSubmitDebugUtilsMessageEXT;
    stream->write(&opcode_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t));
    stream->write((VkInstance*)&instance, sizeof(VkInstance));
    stream->write((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    stream->write((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    marshal_VkDebugUtilsMessengerCallbackDataEXT(stream, (const VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
VkResult VkEncoder::vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((const AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
        marshal_VkAndroidHardwareBufferPropertiesANDROID(countingStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    uint32_t packetSize_vkGetAndroidHardwareBufferPropertiesANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetAndroidHardwareBufferPropertiesANDROID = OP_vkGetAndroidHardwareBufferPropertiesANDROID;
    stream->write(&opcode_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((const AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
    marshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    unmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(countingStream, (const VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
        countingStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    }
    uint32_t packetSize_vkGetMemoryAndroidHardwareBufferANDROID = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryAndroidHardwareBufferANDROID = OP_vkGetMemoryAndroidHardwareBufferANDROID;
    stream->write(&opcode_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(stream, (const VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
    stream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    stream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void VkEncoder::vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        marshal_VkSampleLocationsInfoEXT(countingStream, (const VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
    }
    uint32_t packetSize_vkCmdSetSampleLocationsEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetSampleLocationsEXT = OP_vkCmdSetSampleLocationsEXT;
    stream->write(&opcode_vkCmdSetSampleLocationsEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetSampleLocationsEXT, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    marshal_VkSampleLocationsInfoEXT(stream, (const VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
}

void VkEncoder::vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
        countingStream->write((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
        marshal_VkMultisamplePropertiesEXT(countingStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
    uint32_t packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT = OP_vkGetPhysicalDeviceMultisamplePropertiesEXT;
    stream->write(&opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t));
    stream->write((VkPhysicalDevice*)&physicalDevice, sizeof(VkPhysicalDevice));
    stream->write((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
    marshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    unmarshal_VkMultisamplePropertiesEXT(stream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
VkResult VkEncoder::vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        marshal_VkValidationCacheCreateInfoEXT(countingStream, (const VkValidationCacheCreateInfoEXT*)(pCreateInfo));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
        countingStream->write((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
    }
    uint32_t packetSize_vkCreateValidationCacheEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCreateValidationCacheEXT = OP_vkCreateValidationCacheEXT;
    stream->write(&opcode_vkCreateValidationCacheEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkCreateValidationCacheEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    marshal_VkValidationCacheCreateInfoEXT(stream, (const VkValidationCacheCreateInfoEXT*)(pCreateInfo));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
    stream->write((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
    stream->read((VkValidationCacheEXT*)pValidationCache, sizeof(VkValidationCacheEXT));
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    return vkCreateValidationCacheEXT_VkResult_return;
}

void VkEncoder::vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
        countingStream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
        if (pAllocator)
        {
            marshal_VkAllocationCallbacks(countingStream, (const VkAllocationCallbacks*)(pAllocator));
        }
    }
    uint32_t packetSize_vkDestroyValidationCacheEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkDestroyValidationCacheEXT = OP_vkDestroyValidationCacheEXT;
    stream->write(&opcode_vkDestroyValidationCacheEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkDestroyValidationCacheEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
    stream->write((const VkAllocationCallbacks**)&pAllocator, sizeof(const VkAllocationCallbacks*));
    if (pAllocator)
    {
        marshal_VkAllocationCallbacks(stream, (const VkAllocationCallbacks*)(pAllocator));
    }
}

VkResult VkEncoder::vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkValidationCacheEXT*)&dstCache, sizeof(VkValidationCacheEXT));
        countingStream->write((uint32_t*)&srcCacheCount, sizeof(uint32_t));
        countingStream->write((const VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    }
    uint32_t packetSize_vkMergeValidationCachesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkMergeValidationCachesEXT = OP_vkMergeValidationCachesEXT;
    stream->write(&opcode_vkMergeValidationCachesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkMergeValidationCachesEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkValidationCacheEXT*)&dstCache, sizeof(VkValidationCacheEXT));
    stream->write((uint32_t*)&srcCacheCount, sizeof(uint32_t));
    stream->write((const VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    return vkMergeValidationCachesEXT_VkResult_return;
}

VkResult VkEncoder::vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
        countingStream->write((size_t**)&pDataSize, sizeof(size_t*));
        if (pDataSize)
        {
            countingStream->write((size_t*)pDataSize, sizeof(size_t));
        }
        countingStream->write((void**)&pData, sizeof(void*));
        if (pData)
        {
            countingStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        }
    }
    uint32_t packetSize_vkGetValidationCacheDataEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetValidationCacheDataEXT = OP_vkGetValidationCacheDataEXT;
    stream->write(&opcode_vkGetValidationCacheDataEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetValidationCacheDataEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkValidationCacheEXT*)&validationCache, sizeof(VkValidationCacheEXT));
    stream->write((size_t**)&pDataSize, sizeof(size_t*));
    if (pDataSize)
    {
        stream->write((size_t*)pDataSize, sizeof(size_t));
    }
    stream->write((void**)&pData, sizeof(void*));
    if (pData)
    {
        stream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    size_t* check_pDataSize;
    stream->read((size_t**)&check_pDataSize, sizeof(size_t*));
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        stream->read((size_t*)pDataSize, sizeof(size_t));
    }
    void* check_pData;
    stream->read((void**)&check_pData, sizeof(void*));
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    return vkGetValidationCacheDataEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
VkResult VkEncoder::vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkDevice*)&device, sizeof(VkDevice));
        countingStream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
        countingStream->write((const void**)&pHostPointer, sizeof(const void*));
        if (pHostPointer)
        {
            countingStream->write((const void*)pHostPointer, sizeof(const uint8_t));
        }
        marshal_VkMemoryHostPointerPropertiesEXT(countingStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    uint32_t packetSize_vkGetMemoryHostPointerPropertiesEXT = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetMemoryHostPointerPropertiesEXT = OP_vkGetMemoryHostPointerPropertiesEXT;
    stream->write(&opcode_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t));
    stream->write(&packetSize_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t));
    stream->write((VkDevice*)&device, sizeof(VkDevice));
    stream->write((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    stream->write((const void**)&pHostPointer, sizeof(const void*));
    if (pHostPointer)
    {
        stream->write((const void*)pHostPointer, sizeof(const uint8_t));
    }
    marshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    unmarshal_VkMemoryHostPointerPropertiesEXT(stream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_buffer_marker
void VkEncoder::vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
        countingStream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
        countingStream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
        countingStream->write((uint32_t*)&marker, sizeof(uint32_t));
    }
    uint32_t packetSize_vkCmdWriteBufferMarkerAMD = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdWriteBufferMarkerAMD = OP_vkCmdWriteBufferMarkerAMD;
    stream->write(&opcode_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
    stream->write((VkBuffer*)&dstBuffer, sizeof(VkBuffer));
    stream->write((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
    stream->write((uint32_t*)&marker, sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void VkEncoder::vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
        countingStream->write((const void**)&pCheckpointMarker, sizeof(const void*));
        if (pCheckpointMarker)
        {
            countingStream->write((const void*)pCheckpointMarker, sizeof(const uint8_t));
        }
    }
    uint32_t packetSize_vkCmdSetCheckpointNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkCmdSetCheckpointNV = OP_vkCmdSetCheckpointNV;
    stream->write(&opcode_vkCmdSetCheckpointNV, sizeof(uint32_t));
    stream->write(&packetSize_vkCmdSetCheckpointNV, sizeof(uint32_t));
    stream->write((VkCommandBuffer*)&commandBuffer, sizeof(VkCommandBuffer));
    stream->write((const void**)&pCheckpointMarker, sizeof(const void*));
    if (pCheckpointMarker)
    {
        stream->write((const void*)pCheckpointMarker, sizeof(const uint8_t));
    }
}

void VkEncoder::vkGetQueueCheckpointDataNV(
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData)
{
    auto stream = mImpl->stream();
    auto countingStream = mImpl->countingStream();
    countingStream->rewind();
    {
        countingStream->write((VkQueue*)&queue, sizeof(VkQueue));
        countingStream->write((uint32_t**)&pCheckpointDataCount, sizeof(uint32_t*));
        if (pCheckpointDataCount)
        {
            countingStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
        }
        countingStream->write((VkCheckpointDataNV**)&pCheckpointData, sizeof(VkCheckpointDataNV*));
        if (pCheckpointData)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
            {
                marshal_VkCheckpointDataNV(countingStream, (VkCheckpointDataNV*)(pCheckpointData + i));
            }
        }
    }
    uint32_t packetSize_vkGetQueueCheckpointDataNV = 4 + 4 + (uint32_t)countingStream->bytesWritten();
    countingStream->rewind();
    uint32_t opcode_vkGetQueueCheckpointDataNV = OP_vkGetQueueCheckpointDataNV;
    stream->write(&opcode_vkGetQueueCheckpointDataNV, sizeof(uint32_t));
    stream->write(&packetSize_vkGetQueueCheckpointDataNV, sizeof(uint32_t));
    stream->write((VkQueue*)&queue, sizeof(VkQueue));
    stream->write((uint32_t**)&pCheckpointDataCount, sizeof(uint32_t*));
    if (pCheckpointDataCount)
    {
        stream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    stream->write((VkCheckpointDataNV**)&pCheckpointData, sizeof(VkCheckpointDataNV*));
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            marshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
    uint32_t* check_pCheckpointDataCount;
    stream->read((uint32_t**)&check_pCheckpointDataCount, sizeof(uint32_t*));
    if (pCheckpointDataCount)
    {
        if (!(check_pCheckpointDataCount))
        {
            fprintf(stderr, "fatal: pCheckpointDataCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    VkCheckpointDataNV* check_pCheckpointData;
    stream->read((VkCheckpointDataNV**)&check_pCheckpointData, sizeof(VkCheckpointDataNV*));
    if (pCheckpointData)
    {
        if (!(check_pCheckpointData))
        {
            fprintf(stderr, "fatal: pCheckpointData inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            unmarshal_VkCheckpointDataNV(stream, (VkCheckpointDataNV*)(pCheckpointData + i));
        }
    }
}

#endif


